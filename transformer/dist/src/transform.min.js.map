{"version":3,"sources":["src/node_modules/browser-pack/_prelude.js","src/node_modules/go-variants-engine/node_modules/lodash/_DataView.js","src/node_modules/go-variants-engine/node_modules/lodash/_Hash.js","src/node_modules/go-variants-engine/node_modules/lodash/_ListCache.js","src/node_modules/go-variants-engine/node_modules/lodash/_Map.js","src/node_modules/go-variants-engine/node_modules/lodash/_MapCache.js","src/node_modules/go-variants-engine/node_modules/lodash/_Promise.js","src/node_modules/go-variants-engine/node_modules/lodash/_Set.js","src/node_modules/go-variants-engine/node_modules/lodash/_SetCache.js","src/node_modules/go-variants-engine/node_modules/lodash/_Stack.js","src/node_modules/go-variants-engine/node_modules/lodash/_Symbol.js","src/node_modules/go-variants-engine/node_modules/lodash/_Uint8Array.js","src/node_modules/go-variants-engine/node_modules/lodash/_WeakMap.js","src/node_modules/go-variants-engine/node_modules/lodash/_addMapEntry.js","src/node_modules/go-variants-engine/node_modules/lodash/_addSetEntry.js","src/node_modules/go-variants-engine/node_modules/lodash/_arrayEach.js","src/node_modules/go-variants-engine/node_modules/lodash/_arrayFilter.js","src/node_modules/go-variants-engine/node_modules/lodash/_arrayLikeKeys.js","src/node_modules/go-variants-engine/node_modules/lodash/_arrayMap.js","src/node_modules/go-variants-engine/node_modules/lodash/_arrayPush.js","src/node_modules/go-variants-engine/node_modules/lodash/_arrayReduce.js","src/node_modules/go-variants-engine/node_modules/lodash/_arraySome.js","src/node_modules/go-variants-engine/node_modules/lodash/_assignValue.js","src/node_modules/go-variants-engine/node_modules/lodash/_assocIndexOf.js","src/node_modules/go-variants-engine/node_modules/lodash/_baseAssign.js","src/node_modules/go-variants-engine/node_modules/lodash/_baseAssignIn.js","src/node_modules/go-variants-engine/node_modules/lodash/_baseAssignValue.js","src/node_modules/go-variants-engine/node_modules/lodash/_baseClone.js","src/node_modules/go-variants-engine/node_modules/lodash/_baseCreate.js","src/node_modules/go-variants-engine/node_modules/lodash/_baseFindIndex.js","src/node_modules/go-variants-engine/node_modules/lodash/_baseGet.js","src/node_modules/go-variants-engine/node_modules/lodash/_baseGetAllKeys.js","src/node_modules/go-variants-engine/node_modules/lodash/_baseGetTag.js","src/node_modules/go-variants-engine/node_modules/lodash/_baseHasIn.js","src/node_modules/go-variants-engine/node_modules/lodash/_baseIsArguments.js","src/node_modules/go-variants-engine/node_modules/lodash/_baseIsEqual.js","src/node_modules/go-variants-engine/node_modules/lodash/_baseIsEqualDeep.js","src/node_modules/go-variants-engine/node_modules/lodash/_baseIsMatch.js","src/node_modules/go-variants-engine/node_modules/lodash/_baseIsNative.js","src/node_modules/go-variants-engine/node_modules/lodash/_baseIsTypedArray.js","src/node_modules/go-variants-engine/node_modules/lodash/_baseIteratee.js","src/node_modules/go-variants-engine/node_modules/lodash/_baseKeys.js","src/node_modules/go-variants-engine/node_modules/lodash/_baseKeysIn.js","src/node_modules/go-variants-engine/node_modules/lodash/_baseMatches.js","src/node_modules/go-variants-engine/node_modules/lodash/_baseMatchesProperty.js","src/node_modules/go-variants-engine/node_modules/lodash/_baseProperty.js","src/node_modules/go-variants-engine/node_modules/lodash/_basePropertyDeep.js","src/node_modules/go-variants-engine/node_modules/lodash/_baseTimes.js","src/node_modules/go-variants-engine/node_modules/lodash/_baseToString.js","src/node_modules/go-variants-engine/node_modules/lodash/_baseUnary.js","src/node_modules/go-variants-engine/node_modules/lodash/_cacheHas.js","src/node_modules/go-variants-engine/node_modules/lodash/_castPath.js","src/node_modules/go-variants-engine/node_modules/lodash/_cloneArrayBuffer.js","src/node_modules/go-variants-engine/node_modules/lodash/_cloneBuffer.js","src/node_modules/go-variants-engine/node_modules/lodash/_cloneDataView.js","src/node_modules/go-variants-engine/node_modules/lodash/_cloneMap.js","src/node_modules/go-variants-engine/node_modules/lodash/_cloneRegExp.js","src/node_modules/go-variants-engine/node_modules/lodash/_cloneSet.js","src/node_modules/go-variants-engine/node_modules/lodash/_cloneSymbol.js","src/node_modules/go-variants-engine/node_modules/lodash/_cloneTypedArray.js","src/node_modules/go-variants-engine/node_modules/lodash/_copyArray.js","src/node_modules/go-variants-engine/node_modules/lodash/_copyObject.js","src/node_modules/go-variants-engine/node_modules/lodash/_copySymbols.js","src/node_modules/go-variants-engine/node_modules/lodash/_copySymbolsIn.js","src/node_modules/go-variants-engine/node_modules/lodash/_coreJsData.js","src/node_modules/go-variants-engine/node_modules/lodash/_defineProperty.js","src/node_modules/go-variants-engine/node_modules/lodash/_equalArrays.js","src/node_modules/go-variants-engine/node_modules/lodash/_equalByTag.js","src/node_modules/go-variants-engine/node_modules/lodash/_equalObjects.js","src/node_modules/go-variants-engine/node_modules/lodash/_freeGlobal.js","src/node_modules/go-variants-engine/node_modules/lodash/_getAllKeys.js","src/node_modules/go-variants-engine/node_modules/lodash/_getAllKeysIn.js","src/node_modules/go-variants-engine/node_modules/lodash/_getMapData.js","src/node_modules/go-variants-engine/node_modules/lodash/_getMatchData.js","src/node_modules/go-variants-engine/node_modules/lodash/_getNative.js","src/node_modules/go-variants-engine/node_modules/lodash/_getPrototype.js","src/node_modules/go-variants-engine/node_modules/lodash/_getRawTag.js","src/node_modules/go-variants-engine/node_modules/lodash/_getSymbols.js","src/node_modules/go-variants-engine/node_modules/lodash/_getSymbolsIn.js","src/node_modules/go-variants-engine/node_modules/lodash/_getTag.js","src/node_modules/go-variants-engine/node_modules/lodash/_getValue.js","src/node_modules/go-variants-engine/node_modules/lodash/_hasPath.js","src/node_modules/go-variants-engine/node_modules/lodash/_hashClear.js","src/node_modules/go-variants-engine/node_modules/lodash/_hashDelete.js","src/node_modules/go-variants-engine/node_modules/lodash/_hashGet.js","src/node_modules/go-variants-engine/node_modules/lodash/_hashHas.js","src/node_modules/go-variants-engine/node_modules/lodash/_hashSet.js","src/node_modules/go-variants-engine/node_modules/lodash/_initCloneArray.js","src/node_modules/go-variants-engine/node_modules/lodash/_initCloneByTag.js","src/node_modules/go-variants-engine/node_modules/lodash/_initCloneObject.js","src/node_modules/go-variants-engine/node_modules/lodash/_isIndex.js","src/node_modules/go-variants-engine/node_modules/lodash/_isKey.js","src/node_modules/go-variants-engine/node_modules/lodash/_isKeyable.js","src/node_modules/go-variants-engine/node_modules/lodash/_isMasked.js","src/node_modules/go-variants-engine/node_modules/lodash/_isPrototype.js","src/node_modules/go-variants-engine/node_modules/lodash/_isStrictComparable.js","src/node_modules/go-variants-engine/node_modules/lodash/_listCacheClear.js","src/node_modules/go-variants-engine/node_modules/lodash/_listCacheDelete.js","src/node_modules/go-variants-engine/node_modules/lodash/_listCacheGet.js","src/node_modules/go-variants-engine/node_modules/lodash/_listCacheHas.js","src/node_modules/go-variants-engine/node_modules/lodash/_listCacheSet.js","src/node_modules/go-variants-engine/node_modules/lodash/_mapCacheClear.js","src/node_modules/go-variants-engine/node_modules/lodash/_mapCacheDelete.js","src/node_modules/go-variants-engine/node_modules/lodash/_mapCacheGet.js","src/node_modules/go-variants-engine/node_modules/lodash/_mapCacheHas.js","src/node_modules/go-variants-engine/node_modules/lodash/_mapCacheSet.js","src/node_modules/go-variants-engine/node_modules/lodash/_mapToArray.js","src/node_modules/go-variants-engine/node_modules/lodash/_matchesStrictComparable.js","src/node_modules/go-variants-engine/node_modules/lodash/_memoizeCapped.js","src/node_modules/go-variants-engine/node_modules/lodash/_nativeCreate.js","src/node_modules/go-variants-engine/node_modules/lodash/_nativeKeys.js","src/node_modules/go-variants-engine/node_modules/lodash/_nativeKeysIn.js","src/node_modules/go-variants-engine/node_modules/lodash/_nodeUtil.js","src/node_modules/go-variants-engine/node_modules/lodash/_objectToString.js","src/node_modules/go-variants-engine/node_modules/lodash/_overArg.js","src/node_modules/go-variants-engine/node_modules/lodash/_root.js","src/node_modules/go-variants-engine/node_modules/lodash/_setCacheAdd.js","src/node_modules/go-variants-engine/node_modules/lodash/_setCacheHas.js","src/node_modules/go-variants-engine/node_modules/lodash/_setToArray.js","src/node_modules/go-variants-engine/node_modules/lodash/_stackClear.js","src/node_modules/go-variants-engine/node_modules/lodash/_stackDelete.js","src/node_modules/go-variants-engine/node_modules/lodash/_stackGet.js","src/node_modules/go-variants-engine/node_modules/lodash/_stackHas.js","src/node_modules/go-variants-engine/node_modules/lodash/_stackSet.js","src/node_modules/go-variants-engine/node_modules/lodash/_stringToPath.js","src/node_modules/go-variants-engine/node_modules/lodash/_toKey.js","src/node_modules/go-variants-engine/node_modules/lodash/_toSource.js","src/node_modules/go-variants-engine/node_modules/lodash/clone.js","src/node_modules/go-variants-engine/node_modules/lodash/eq.js","src/node_modules/go-variants-engine/node_modules/lodash/findIndex.js","src/node_modules/go-variants-engine/node_modules/lodash/get.js","src/node_modules/go-variants-engine/node_modules/lodash/hasIn.js","src/node_modules/go-variants-engine/node_modules/lodash/identity.js","src/node_modules/go-variants-engine/node_modules/lodash/isArguments.js","src/node_modules/go-variants-engine/node_modules/lodash/isArray.js","src/node_modules/go-variants-engine/node_modules/lodash/isArrayLike.js","src/node_modules/go-variants-engine/node_modules/lodash/isBuffer.js","src/node_modules/go-variants-engine/node_modules/lodash/isFunction.js","src/node_modules/go-variants-engine/node_modules/lodash/isLength.js","src/node_modules/go-variants-engine/node_modules/lodash/isObject.js","src/node_modules/go-variants-engine/node_modules/lodash/isObjectLike.js","src/node_modules/go-variants-engine/node_modules/lodash/isSymbol.js","src/node_modules/go-variants-engine/node_modules/lodash/isTypedArray.js","src/node_modules/go-variants-engine/node_modules/lodash/keys.js","src/node_modules/go-variants-engine/node_modules/lodash/keysIn.js","src/node_modules/go-variants-engine/node_modules/lodash/memoize.js","src/node_modules/go-variants-engine/node_modules/lodash/property.js","src/node_modules/go-variants-engine/node_modules/lodash/stubArray.js","src/node_modules/go-variants-engine/node_modules/lodash/stubFalse.js","src/node_modules/go-variants-engine/node_modules/lodash/toFinite.js","src/node_modules/go-variants-engine/node_modules/lodash/toInteger.js","src/node_modules/go-variants-engine/node_modules/lodash/toNumber.js","src/node_modules/go-variants-engine/node_modules/lodash/toString.js","src/node_modules/go-variants-engine/src/engine.js","src/node_modules/lodash/_arrayIncludes.js","src/node_modules/lodash/_arrayIncludesWith.js","src/node_modules/lodash/_baseFlatten.js","src/node_modules/lodash/_baseIndexOf.js","src/node_modules/lodash/_baseIsNaN.js","src/node_modules/lodash/_baseUniq.js","src/node_modules/lodash/_createSet.js","src/node_modules/lodash/_freeGlobal.js","src/node_modules/lodash/_isFlattenable.js","src/node_modules/lodash/_strictIndexOf.js","src/node_modules/lodash/flatten.js","src/node_modules/lodash/noop.js","src/node_modules/lodash/uniqBy.js","src/node_modules/smartgame/index.js","src/node_modules/smartgamer/index.js","src/src/transform.js","src/src/transformer.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACzFA;AACA;AACA;AACA;AACA;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACnVA;;;;AAKA,OAAO,OAAP,GAAiB,UAAC,UAAD,EAAa,OAAb,EAAyB;AACxC;;AACA,MAAI,cAAc,QAAQ,eAAR,CAAlB;AAAA,MACE,YAAY,QAAQ,WAAR,CADd;AAAA,MAEE,aAAa,QAAQ,YAAR,CAFf;AAAA,MAGE,MAAM,QAAQ,oBAA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","file":"transform.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView');\n\nmodule.exports = DataView;\n","var hashClear = require('./_hashClear'),\n    hashDelete = require('./_hashDelete'),\n    hashGet = require('./_hashGet'),\n    hashHas = require('./_hashHas'),\n    hashSet = require('./_hashSet');\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\nmodule.exports = Hash;\n","var listCacheClear = require('./_listCacheClear'),\n    listCacheDelete = require('./_listCacheDelete'),\n    listCacheGet = require('./_listCacheGet'),\n    listCacheHas = require('./_listCacheHas'),\n    listCacheSet = require('./_listCacheSet');\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\nmodule.exports = ListCache;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map');\n\nmodule.exports = Map;\n","var mapCacheClear = require('./_mapCacheClear'),\n    mapCacheDelete = require('./_mapCacheDelete'),\n    mapCacheGet = require('./_mapCacheGet'),\n    mapCacheHas = require('./_mapCacheHas'),\n    mapCacheSet = require('./_mapCacheSet');\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\nmodule.exports = MapCache;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Promise = getNative(root, 'Promise');\n\nmodule.exports = Promise;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Set = getNative(root, 'Set');\n\nmodule.exports = Set;\n","var MapCache = require('./_MapCache'),\n    setCacheAdd = require('./_setCacheAdd'),\n    setCacheHas = require('./_setCacheHas');\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values == null ? 0 : values.length;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\nmodule.exports = SetCache;\n","var ListCache = require('./_ListCache'),\n    stackClear = require('./_stackClear'),\n    stackDelete = require('./_stackDelete'),\n    stackGet = require('./_stackGet'),\n    stackHas = require('./_stackHas'),\n    stackSet = require('./_stackSet');\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\nmodule.exports = Stack;\n","var root = require('./_root');\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n","var root = require('./_root');\n\n/** Built-in value references. */\nvar Uint8Array = root.Uint8Array;\n\nmodule.exports = Uint8Array;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar WeakMap = getNative(root, 'WeakMap');\n\nmodule.exports = WeakMap;\n","/**\n * Adds the key-value `pair` to `map`.\n *\n * @private\n * @param {Object} map The map to modify.\n * @param {Array} pair The key-value pair to add.\n * @returns {Object} Returns `map`.\n */\nfunction addMapEntry(map, pair) {\n  // Don't return `map.set` because it's not chainable in IE 11.\n  map.set(pair[0], pair[1]);\n  return map;\n}\n\nmodule.exports = addMapEntry;\n","/**\n * Adds `value` to `set`.\n *\n * @private\n * @param {Object} set The set to modify.\n * @param {*} value The value to add.\n * @returns {Object} Returns `set`.\n */\nfunction addSetEntry(set, value) {\n  // Don't return `set.add` because it's not chainable in IE 11.\n  set.add(value);\n  return set;\n}\n\nmodule.exports = addSetEntry;\n","/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\nmodule.exports = arrayEach;\n","/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayFilter;\n","var baseTimes = require('./_baseTimes'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isIndex = require('./_isIndex'),\n    isTypedArray = require('./isTypedArray');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayLikeKeys;\n","/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\nmodule.exports = arrayMap;\n","/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\nmodule.exports = arrayPush;\n","/**\n * A specialized version of `_.reduce` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @param {boolean} [initAccum] Specify using the first element of `array` as\n *  the initial value.\n * @returns {*} Returns the accumulated value.\n */\nfunction arrayReduce(array, iteratee, accumulator, initAccum) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  if (initAccum && length) {\n    accumulator = array[++index];\n  }\n  while (++index < length) {\n    accumulator = iteratee(accumulator, array[index], index, array);\n  }\n  return accumulator;\n}\n\nmodule.exports = arrayReduce;\n","/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nmodule.exports = arraySome;\n","var baseAssignValue = require('./_baseAssignValue'),\n    eq = require('./eq');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    baseAssignValue(object, key, value);\n  }\n}\n\nmodule.exports = assignValue;\n","var eq = require('./eq');\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = assocIndexOf;\n","var copyObject = require('./_copyObject'),\n    keys = require('./keys');\n\n/**\n * The base implementation of `_.assign` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssign(object, source) {\n  return object && copyObject(source, keys(source), object);\n}\n\nmodule.exports = baseAssign;\n","var copyObject = require('./_copyObject'),\n    keysIn = require('./keysIn');\n\n/**\n * The base implementation of `_.assignIn` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssignIn(object, source) {\n  return object && copyObject(source, keysIn(source), object);\n}\n\nmodule.exports = baseAssignIn;\n","var defineProperty = require('./_defineProperty');\n\n/**\n * The base implementation of `assignValue` and `assignMergeValue` without\n * value checks.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction baseAssignValue(object, key, value) {\n  if (key == '__proto__' && defineProperty) {\n    defineProperty(object, key, {\n      'configurable': true,\n      'enumerable': true,\n      'value': value,\n      'writable': true\n    });\n  } else {\n    object[key] = value;\n  }\n}\n\nmodule.exports = baseAssignValue;\n","var Stack = require('./_Stack'),\n    arrayEach = require('./_arrayEach'),\n    assignValue = require('./_assignValue'),\n    baseAssign = require('./_baseAssign'),\n    baseAssignIn = require('./_baseAssignIn'),\n    cloneBuffer = require('./_cloneBuffer'),\n    copyArray = require('./_copyArray'),\n    copySymbols = require('./_copySymbols'),\n    copySymbolsIn = require('./_copySymbolsIn'),\n    getAllKeys = require('./_getAllKeys'),\n    getAllKeysIn = require('./_getAllKeysIn'),\n    getTag = require('./_getTag'),\n    initCloneArray = require('./_initCloneArray'),\n    initCloneByTag = require('./_initCloneByTag'),\n    initCloneObject = require('./_initCloneObject'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isObject = require('./isObject'),\n    keys = require('./keys');\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_DEEP_FLAG = 1,\n    CLONE_FLAT_FLAG = 2,\n    CLONE_SYMBOLS_FLAG = 4;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values supported by `_.clone`. */\nvar cloneableTags = {};\ncloneableTags[argsTag] = cloneableTags[arrayTag] =\ncloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\ncloneableTags[boolTag] = cloneableTags[dateTag] =\ncloneableTags[float32Tag] = cloneableTags[float64Tag] =\ncloneableTags[int8Tag] = cloneableTags[int16Tag] =\ncloneableTags[int32Tag] = cloneableTags[mapTag] =\ncloneableTags[numberTag] = cloneableTags[objectTag] =\ncloneableTags[regexpTag] = cloneableTags[setTag] =\ncloneableTags[stringTag] = cloneableTags[symbolTag] =\ncloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\ncloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\ncloneableTags[errorTag] = cloneableTags[funcTag] =\ncloneableTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n * traversed objects.\n *\n * @private\n * @param {*} value The value to clone.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Deep clone\n *  2 - Flatten inherited properties\n *  4 - Clone symbols\n * @param {Function} [customizer] The function to customize cloning.\n * @param {string} [key] The key of `value`.\n * @param {Object} [object] The parent object of `value`.\n * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n * @returns {*} Returns the cloned value.\n */\nfunction baseClone(value, bitmask, customizer, key, object, stack) {\n  var result,\n      isDeep = bitmask & CLONE_DEEP_FLAG,\n      isFlat = bitmask & CLONE_FLAT_FLAG,\n      isFull = bitmask & CLONE_SYMBOLS_FLAG;\n\n  if (customizer) {\n    result = object ? customizer(value, key, object, stack) : customizer(value);\n  }\n  if (result !== undefined) {\n    return result;\n  }\n  if (!isObject(value)) {\n    return value;\n  }\n  var isArr = isArray(value);\n  if (isArr) {\n    result = initCloneArray(value);\n    if (!isDeep) {\n      return copyArray(value, result);\n    }\n  } else {\n    var tag = getTag(value),\n        isFunc = tag == funcTag || tag == genTag;\n\n    if (isBuffer(value)) {\n      return cloneBuffer(value, isDeep);\n    }\n    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n      result = (isFlat || isFunc) ? {} : initCloneObject(value);\n      if (!isDeep) {\n        return isFlat\n          ? copySymbolsIn(value, baseAssignIn(result, value))\n          : copySymbols(value, baseAssign(result, value));\n      }\n    } else {\n      if (!cloneableTags[tag]) {\n        return object ? value : {};\n      }\n      result = initCloneByTag(value, tag, baseClone, isDeep);\n    }\n  }\n  // Check for circular references and return its corresponding clone.\n  stack || (stack = new Stack);\n  var stacked = stack.get(value);\n  if (stacked) {\n    return stacked;\n  }\n  stack.set(value, result);\n\n  var keysFunc = isFull\n    ? (isFlat ? getAllKeysIn : getAllKeys)\n    : (isFlat ? keysIn : keys);\n\n  var props = isArr ? undefined : keysFunc(value);\n  arrayEach(props || value, function(subValue, key) {\n    if (props) {\n      key = subValue;\n      subValue = value[key];\n    }\n    // Recursively populate clone (susceptible to call stack limits).\n    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));\n  });\n  return result;\n}\n\nmodule.exports = baseClone;\n","var isObject = require('./isObject');\n\n/** Built-in value references. */\nvar objectCreate = Object.create;\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} proto The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nvar baseCreate = (function() {\n  function object() {}\n  return function(proto) {\n    if (!isObject(proto)) {\n      return {};\n    }\n    if (objectCreate) {\n      return objectCreate(proto);\n    }\n    object.prototype = proto;\n    var result = new object;\n    object.prototype = undefined;\n    return result;\n  };\n}());\n\nmodule.exports = baseCreate;\n","/**\n * The base implementation of `_.findIndex` and `_.findLastIndex` without\n * support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} predicate The function invoked per iteration.\n * @param {number} fromIndex The index to search from.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseFindIndex(array, predicate, fromIndex, fromRight) {\n  var length = array.length,\n      index = fromIndex + (fromRight ? 1 : -1);\n\n  while ((fromRight ? index-- : ++index < length)) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = baseFindIndex;\n","var castPath = require('./_castPath'),\n    toKey = require('./_toKey');\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = castPath(path, object);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\nmodule.exports = baseGet;\n","var arrayPush = require('./_arrayPush'),\n    isArray = require('./isArray');\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\nmodule.exports = baseGetAllKeys;\n","var Symbol = require('./_Symbol'),\n    getRawTag = require('./_getRawTag'),\n    objectToString = require('./_objectToString');\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n","/**\n * The base implementation of `_.hasIn` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHasIn(object, key) {\n  return object != null && key in Object(object);\n}\n\nmodule.exports = baseHasIn;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]';\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\nmodule.exports = baseIsArguments;\n","var baseIsEqualDeep = require('./_baseIsEqualDeep'),\n    isObjectLike = require('./isObjectLike');\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n}\n\nmodule.exports = baseIsEqual;\n","var Stack = require('./_Stack'),\n    equalArrays = require('./_equalArrays'),\n    equalByTag = require('./_equalByTag'),\n    equalObjects = require('./_equalObjects'),\n    getTag = require('./_getTag'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isTypedArray = require('./isTypedArray');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = objIsArr ? arrayTag : getTag(object),\n      othTag = othIsArr ? arrayTag : getTag(other);\n\n  objTag = objTag == argsTag ? objectTag : objTag;\n  othTag = othTag == argsTag ? objectTag : othTag;\n\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && isBuffer(object)) {\n    if (!isBuffer(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\n\nmodule.exports = baseIsEqualDeep;\n","var Stack = require('./_Stack'),\n    baseIsEqual = require('./_baseIsEqual');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * The base implementation of `_.isMatch` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Object} source The object of property values to match.\n * @param {Array} matchData The property names, values, and compare flags to match.\n * @param {Function} [customizer] The function to customize comparisons.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */\nfunction baseIsMatch(object, source, matchData, customizer) {\n  var index = matchData.length,\n      length = index,\n      noCustomizer = !customizer;\n\n  if (object == null) {\n    return !length;\n  }\n  object = Object(object);\n  while (index--) {\n    var data = matchData[index];\n    if ((noCustomizer && data[2])\n          ? data[1] !== object[data[0]]\n          : !(data[0] in object)\n        ) {\n      return false;\n    }\n  }\n  while (++index < length) {\n    data = matchData[index];\n    var key = data[0],\n        objValue = object[key],\n        srcValue = data[1];\n\n    if (noCustomizer && data[2]) {\n      if (objValue === undefined && !(key in object)) {\n        return false;\n      }\n    } else {\n      var stack = new Stack;\n      if (customizer) {\n        var result = customizer(objValue, srcValue, key, object, source, stack);\n      }\n      if (!(result === undefined\n            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\n            : result\n          )) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nmodule.exports = baseIsMatch;\n","var isFunction = require('./isFunction'),\n    isMasked = require('./_isMasked'),\n    isObject = require('./isObject'),\n    toSource = require('./_toSource');\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\nmodule.exports = baseIsNative;\n","var baseGetTag = require('./_baseGetTag'),\n    isLength = require('./isLength'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\nmodule.exports = baseIsTypedArray;\n","var baseMatches = require('./_baseMatches'),\n    baseMatchesProperty = require('./_baseMatchesProperty'),\n    identity = require('./identity'),\n    isArray = require('./isArray'),\n    property = require('./property');\n\n/**\n * The base implementation of `_.iteratee`.\n *\n * @private\n * @param {*} [value=_.identity] The value to convert to an iteratee.\n * @returns {Function} Returns the iteratee.\n */\nfunction baseIteratee(value) {\n  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n  if (typeof value == 'function') {\n    return value;\n  }\n  if (value == null) {\n    return identity;\n  }\n  if (typeof value == 'object') {\n    return isArray(value)\n      ? baseMatchesProperty(value[0], value[1])\n      : baseMatches(value);\n  }\n  return property(value);\n}\n\nmodule.exports = baseIteratee;\n","var isPrototype = require('./_isPrototype'),\n    nativeKeys = require('./_nativeKeys');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseKeys;\n","var isObject = require('./isObject'),\n    isPrototype = require('./_isPrototype'),\n    nativeKeysIn = require('./_nativeKeysIn');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeysIn(object) {\n  if (!isObject(object)) {\n    return nativeKeysIn(object);\n  }\n  var isProto = isPrototype(object),\n      result = [];\n\n  for (var key in object) {\n    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseKeysIn;\n","var baseIsMatch = require('./_baseIsMatch'),\n    getMatchData = require('./_getMatchData'),\n    matchesStrictComparable = require('./_matchesStrictComparable');\n\n/**\n * The base implementation of `_.matches` which doesn't clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatches(source) {\n  var matchData = getMatchData(source);\n  if (matchData.length == 1 && matchData[0][2]) {\n    return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n  }\n  return function(object) {\n    return object === source || baseIsMatch(object, source, matchData);\n  };\n}\n\nmodule.exports = baseMatches;\n","var baseIsEqual = require('./_baseIsEqual'),\n    get = require('./get'),\n    hasIn = require('./hasIn'),\n    isKey = require('./_isKey'),\n    isStrictComparable = require('./_isStrictComparable'),\n    matchesStrictComparable = require('./_matchesStrictComparable'),\n    toKey = require('./_toKey');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n *\n * @private\n * @param {string} path The path of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatchesProperty(path, srcValue) {\n  if (isKey(path) && isStrictComparable(srcValue)) {\n    return matchesStrictComparable(toKey(path), srcValue);\n  }\n  return function(object) {\n    var objValue = get(object, path);\n    return (objValue === undefined && objValue === srcValue)\n      ? hasIn(object, path)\n      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n  };\n}\n\nmodule.exports = baseMatchesProperty;\n","/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\nmodule.exports = baseProperty;\n","var baseGet = require('./_baseGet');\n\n/**\n * A specialized version of `baseProperty` which supports deep paths.\n *\n * @private\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyDeep(path) {\n  return function(object) {\n    return baseGet(object, path);\n  };\n}\n\nmodule.exports = basePropertyDeep;\n","/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\nmodule.exports = baseTimes;\n","var Symbol = require('./_Symbol'),\n    arrayMap = require('./_arrayMap'),\n    isArray = require('./isArray'),\n    isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = baseToString;\n","/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\nmodule.exports = baseUnary;\n","/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\nmodule.exports = cacheHas;\n","var isArray = require('./isArray'),\n    isKey = require('./_isKey'),\n    stringToPath = require('./_stringToPath'),\n    toString = require('./toString');\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value, object) {\n  if (isArray(value)) {\n    return value;\n  }\n  return isKey(value, object) ? [value] : stringToPath(toString(value));\n}\n\nmodule.exports = castPath;\n","var Uint8Array = require('./_Uint8Array');\n\n/**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */\nfunction cloneArrayBuffer(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n  return result;\n}\n\nmodule.exports = cloneArrayBuffer;\n","var root = require('./_root');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;\n\n/**\n * Creates a clone of  `buffer`.\n *\n * @private\n * @param {Buffer} buffer The buffer to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Buffer} Returns the cloned buffer.\n */\nfunction cloneBuffer(buffer, isDeep) {\n  if (isDeep) {\n    return buffer.slice();\n  }\n  var length = buffer.length,\n      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n\n  buffer.copy(result);\n  return result;\n}\n\nmodule.exports = cloneBuffer;\n","var cloneArrayBuffer = require('./_cloneArrayBuffer');\n\n/**\n * Creates a clone of `dataView`.\n *\n * @private\n * @param {Object} dataView The data view to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned data view.\n */\nfunction cloneDataView(dataView, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n}\n\nmodule.exports = cloneDataView;\n","var addMapEntry = require('./_addMapEntry'),\n    arrayReduce = require('./_arrayReduce'),\n    mapToArray = require('./_mapToArray');\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_DEEP_FLAG = 1;\n\n/**\n * Creates a clone of `map`.\n *\n * @private\n * @param {Object} map The map to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned map.\n */\nfunction cloneMap(map, isDeep, cloneFunc) {\n  var array = isDeep ? cloneFunc(mapToArray(map), CLONE_DEEP_FLAG) : mapToArray(map);\n  return arrayReduce(array, addMapEntry, new map.constructor);\n}\n\nmodule.exports = cloneMap;\n","/** Used to match `RegExp` flags from their coerced string values. */\nvar reFlags = /\\w*$/;\n\n/**\n * Creates a clone of `regexp`.\n *\n * @private\n * @param {Object} regexp The regexp to clone.\n * @returns {Object} Returns the cloned regexp.\n */\nfunction cloneRegExp(regexp) {\n  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n  result.lastIndex = regexp.lastIndex;\n  return result;\n}\n\nmodule.exports = cloneRegExp;\n","var addSetEntry = require('./_addSetEntry'),\n    arrayReduce = require('./_arrayReduce'),\n    setToArray = require('./_setToArray');\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_DEEP_FLAG = 1;\n\n/**\n * Creates a clone of `set`.\n *\n * @private\n * @param {Object} set The set to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned set.\n */\nfunction cloneSet(set, isDeep, cloneFunc) {\n  var array = isDeep ? cloneFunc(setToArray(set), CLONE_DEEP_FLAG) : setToArray(set);\n  return arrayReduce(array, addSetEntry, new set.constructor);\n}\n\nmodule.exports = cloneSet;\n","var Symbol = require('./_Symbol');\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * Creates a clone of the `symbol` object.\n *\n * @private\n * @param {Object} symbol The symbol object to clone.\n * @returns {Object} Returns the cloned symbol object.\n */\nfunction cloneSymbol(symbol) {\n  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n}\n\nmodule.exports = cloneSymbol;\n","var cloneArrayBuffer = require('./_cloneArrayBuffer');\n\n/**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */\nfunction cloneTypedArray(typedArray, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\n\nmodule.exports = cloneTypedArray;\n","/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\nmodule.exports = copyArray;\n","var assignValue = require('./_assignValue'),\n    baseAssignValue = require('./_baseAssignValue');\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n  var isNew = !object;\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    if (newValue === undefined) {\n      newValue = source[key];\n    }\n    if (isNew) {\n      baseAssignValue(object, key, newValue);\n    } else {\n      assignValue(object, key, newValue);\n    }\n  }\n  return object;\n}\n\nmodule.exports = copyObject;\n","var copyObject = require('./_copyObject'),\n    getSymbols = require('./_getSymbols');\n\n/**\n * Copies own symbols of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbols(source, object) {\n  return copyObject(source, getSymbols(source), object);\n}\n\nmodule.exports = copySymbols;\n","var copyObject = require('./_copyObject'),\n    getSymbolsIn = require('./_getSymbolsIn');\n\n/**\n * Copies own and inherited symbols of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbolsIn(source, object) {\n  return copyObject(source, getSymbolsIn(source), object);\n}\n\nmodule.exports = copySymbolsIn;\n","var root = require('./_root');\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\nmodule.exports = coreJsData;\n","var getNative = require('./_getNative');\n\nvar defineProperty = (function() {\n  try {\n    var func = getNative(Object, 'defineProperty');\n    func({}, '', {});\n    return func;\n  } catch (e) {}\n}());\n\nmodule.exports = defineProperty;\n","var SetCache = require('./_SetCache'),\n    arraySome = require('./_arraySome'),\n    cacheHas = require('./_cacheHas');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!cacheHas(seen, othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, bitmask, customizer, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\nmodule.exports = equalArrays;\n","var Symbol = require('./_Symbol'),\n    Uint8Array = require('./_Uint8Array'),\n    eq = require('./eq'),\n    equalArrays = require('./_equalArrays'),\n    mapToArray = require('./_mapToArray'),\n    setToArray = require('./_setToArray');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]';\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\nmodule.exports = equalByTag;\n","var getAllKeys = require('./_getAllKeys');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1;\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\nmodule.exports = equalObjects;\n","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n","var baseGetAllKeys = require('./_baseGetAllKeys'),\n    getSymbols = require('./_getSymbols'),\n    keys = require('./keys');\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\nmodule.exports = getAllKeys;\n","var baseGetAllKeys = require('./_baseGetAllKeys'),\n    getSymbolsIn = require('./_getSymbolsIn'),\n    keysIn = require('./keysIn');\n\n/**\n * Creates an array of own and inherited enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeysIn(object) {\n  return baseGetAllKeys(object, keysIn, getSymbolsIn);\n}\n\nmodule.exports = getAllKeysIn;\n","var isKeyable = require('./_isKeyable');\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\nmodule.exports = getMapData;\n","var isStrictComparable = require('./_isStrictComparable'),\n    keys = require('./keys');\n\n/**\n * Gets the property names, values, and compare flags of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the match data of `object`.\n */\nfunction getMatchData(object) {\n  var result = keys(object),\n      length = result.length;\n\n  while (length--) {\n    var key = result[length],\n        value = object[key];\n\n    result[length] = [key, value, isStrictComparable(value)];\n  }\n  return result;\n}\n\nmodule.exports = getMatchData;\n","var baseIsNative = require('./_baseIsNative'),\n    getValue = require('./_getValue');\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\nmodule.exports = getNative;\n","var overArg = require('./_overArg');\n\n/** Built-in value references. */\nvar getPrototype = overArg(Object.getPrototypeOf, Object);\n\nmodule.exports = getPrototype;\n","var Symbol = require('./_Symbol');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n","var arrayFilter = require('./_arrayFilter'),\n    stubArray = require('./stubArray');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\nmodule.exports = getSymbols;\n","var arrayPush = require('./_arrayPush'),\n    getPrototype = require('./_getPrototype'),\n    getSymbols = require('./_getSymbols'),\n    stubArray = require('./stubArray');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\n\n/**\n * Creates an array of the own and inherited enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {\n  var result = [];\n  while (object) {\n    arrayPush(result, getSymbols(object));\n    object = getPrototype(object);\n  }\n  return result;\n};\n\nmodule.exports = getSymbolsIn;\n","var DataView = require('./_DataView'),\n    Map = require('./_Map'),\n    Promise = require('./_Promise'),\n    Set = require('./_Set'),\n    WeakMap = require('./_WeakMap'),\n    baseGetTag = require('./_baseGetTag'),\n    toSource = require('./_toSource');\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    setTag = '[object Set]',\n    weakMapTag = '[object WeakMap]';\n\nvar dataViewTag = '[object DataView]';\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\nmodule.exports = getTag;\n","/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\nmodule.exports = getValue;\n","var castPath = require('./_castPath'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isIndex = require('./_isIndex'),\n    isLength = require('./isLength'),\n    toKey = require('./_toKey');\n\n/**\n * Checks if `path` exists on `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @param {Function} hasFunc The function to check properties.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n */\nfunction hasPath(object, path, hasFunc) {\n  path = castPath(path, object);\n\n  var index = -1,\n      length = path.length,\n      result = false;\n\n  while (++index < length) {\n    var key = toKey(path[index]);\n    if (!(result = object != null && hasFunc(object, key))) {\n      break;\n    }\n    object = object[key];\n  }\n  if (result || ++index != length) {\n    return result;\n  }\n  length = object == null ? 0 : object.length;\n  return !!length && isLength(length) && isIndex(key, length) &&\n    (isArray(object) || isArguments(object));\n}\n\nmodule.exports = hasPath;\n","var nativeCreate = require('./_nativeCreate');\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\nmodule.exports = hashClear;\n","/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = hashDelete;\n","var nativeCreate = require('./_nativeCreate');\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\nmodule.exports = hashGet;\n","var nativeCreate = require('./_nativeCreate');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\nmodule.exports = hashHas;\n","var nativeCreate = require('./_nativeCreate');\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\nmodule.exports = hashSet;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Initializes an array clone.\n *\n * @private\n * @param {Array} array The array to clone.\n * @returns {Array} Returns the initialized clone.\n */\nfunction initCloneArray(array) {\n  var length = array.length,\n      result = array.constructor(length);\n\n  // Add properties assigned by `RegExp#exec`.\n  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n    result.index = array.index;\n    result.input = array.input;\n  }\n  return result;\n}\n\nmodule.exports = initCloneArray;\n","var cloneArrayBuffer = require('./_cloneArrayBuffer'),\n    cloneDataView = require('./_cloneDataView'),\n    cloneMap = require('./_cloneMap'),\n    cloneRegExp = require('./_cloneRegExp'),\n    cloneSet = require('./_cloneSet'),\n    cloneSymbol = require('./_cloneSymbol'),\n    cloneTypedArray = require('./_cloneTypedArray');\n\n/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Initializes an object clone based on its `toStringTag`.\n *\n * **Note:** This function only supports cloning values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to clone.\n * @param {string} tag The `toStringTag` of the object to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneByTag(object, tag, cloneFunc, isDeep) {\n  var Ctor = object.constructor;\n  switch (tag) {\n    case arrayBufferTag:\n      return cloneArrayBuffer(object);\n\n    case boolTag:\n    case dateTag:\n      return new Ctor(+object);\n\n    case dataViewTag:\n      return cloneDataView(object, isDeep);\n\n    case float32Tag: case float64Tag:\n    case int8Tag: case int16Tag: case int32Tag:\n    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n      return cloneTypedArray(object, isDeep);\n\n    case mapTag:\n      return cloneMap(object, isDeep, cloneFunc);\n\n    case numberTag:\n    case stringTag:\n      return new Ctor(object);\n\n    case regexpTag:\n      return cloneRegExp(object);\n\n    case setTag:\n      return cloneSet(object, isDeep, cloneFunc);\n\n    case symbolTag:\n      return cloneSymbol(object);\n  }\n}\n\nmodule.exports = initCloneByTag;\n","var baseCreate = require('./_baseCreate'),\n    getPrototype = require('./_getPrototype'),\n    isPrototype = require('./_isPrototype');\n\n/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneObject(object) {\n  return (typeof object.constructor == 'function' && !isPrototype(object))\n    ? baseCreate(getPrototype(object))\n    : {};\n}\n\nmodule.exports = initCloneObject;\n","/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\nmodule.exports = isIndex;\n","var isArray = require('./isArray'),\n    isSymbol = require('./isSymbol');\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/;\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\nmodule.exports = isKey;\n","/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\nmodule.exports = isKeyable;\n","var coreJsData = require('./_coreJsData');\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\nmodule.exports = isMasked;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\nmodule.exports = isPrototype;\n","var isObject = require('./isObject');\n\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */\nfunction isStrictComparable(value) {\n  return value === value && !isObject(value);\n}\n\nmodule.exports = isStrictComparable;\n","/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\nmodule.exports = listCacheClear;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\nmodule.exports = listCacheDelete;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\nmodule.exports = listCacheGet;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\nmodule.exports = listCacheHas;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\nmodule.exports = listCacheSet;\n","var Hash = require('./_Hash'),\n    ListCache = require('./_ListCache'),\n    Map = require('./_Map');\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\nmodule.exports = mapCacheClear;\n","var getMapData = require('./_getMapData');\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = mapCacheDelete;\n","var getMapData = require('./_getMapData');\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\nmodule.exports = mapCacheGet;\n","var getMapData = require('./_getMapData');\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\nmodule.exports = mapCacheHas;\n","var getMapData = require('./_getMapData');\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\nmodule.exports = mapCacheSet;\n","/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\nmodule.exports = mapToArray;\n","/**\n * A specialized version of `matchesProperty` for source values suitable\n * for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction matchesStrictComparable(key, srcValue) {\n  return function(object) {\n    if (object == null) {\n      return false;\n    }\n    return object[key] === srcValue &&\n      (srcValue !== undefined || (key in Object(object)));\n  };\n}\n\nmodule.exports = matchesStrictComparable;\n","var memoize = require('./memoize');\n\n/** Used as the maximum memoize cache size. */\nvar MAX_MEMOIZE_SIZE = 500;\n\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */\nfunction memoizeCapped(func) {\n  var result = memoize(func, function(key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n\n  var cache = result.cache;\n  return result;\n}\n\nmodule.exports = memoizeCapped;\n","var getNative = require('./_getNative');\n\n/* Built-in method references that are verified to be native. */\nvar nativeCreate = getNative(Object, 'create');\n\nmodule.exports = nativeCreate;\n","var overArg = require('./_overArg');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = overArg(Object.keys, Object);\n\nmodule.exports = nativeKeys;\n","/**\n * This function is like\n * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * except that it includes inherited enumerable properties.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction nativeKeysIn(object) {\n  var result = [];\n  if (object != null) {\n    for (var key in Object(object)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = nativeKeysIn;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\nmodule.exports = nodeUtil;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n","/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\nmodule.exports = overArg;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n","/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\nmodule.exports = setCacheAdd;\n","/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\nmodule.exports = setCacheHas;\n","/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\nmodule.exports = setToArray;\n","var ListCache = require('./_ListCache');\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\nmodule.exports = stackClear;\n","/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\nmodule.exports = stackDelete;\n","/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\nmodule.exports = stackGet;\n","/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\nmodule.exports = stackHas;\n","var ListCache = require('./_ListCache'),\n    Map = require('./_Map'),\n    MapCache = require('./_MapCache');\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\nmodule.exports = stackSet;\n","var memoizeCapped = require('./_memoizeCapped');\n\n/** Used to match property names within property paths. */\nvar reLeadingDot = /^\\./,\n    rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoizeCapped(function(string) {\n  var result = [];\n  if (reLeadingDot.test(string)) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, string) {\n    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\nmodule.exports = stringToPath;\n","var isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = toKey;\n","/** Used for built-in method references. */\nvar funcProto = Function.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\nmodule.exports = toSource;\n","var baseClone = require('./_baseClone');\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_SYMBOLS_FLAG = 4;\n\n/**\n * Creates a shallow clone of `value`.\n *\n * **Note:** This method is loosely based on the\n * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)\n * and supports cloning arrays, array buffers, booleans, date objects, maps,\n * numbers, `Object` objects, regexes, sets, strings, symbols, and typed\n * arrays. The own enumerable properties of `arguments` objects are cloned\n * as plain objects. An empty object is returned for uncloneable values such\n * as error objects, functions, DOM nodes, and WeakMaps.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to clone.\n * @returns {*} Returns the cloned value.\n * @see _.cloneDeep\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var shallow = _.clone(objects);\n * console.log(shallow[0] === objects[0]);\n * // => true\n */\nfunction clone(value) {\n  return baseClone(value, CLONE_SYMBOLS_FLAG);\n}\n\nmodule.exports = clone;\n","/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\nmodule.exports = eq;\n","var baseFindIndex = require('./_baseFindIndex'),\n    baseIteratee = require('./_baseIteratee'),\n    toInteger = require('./toInteger');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * This method is like `_.find` except that it returns the index of the first\n * element `predicate` returns truthy for instead of the element itself.\n *\n * @static\n * @memberOf _\n * @since 1.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {number} Returns the index of the found element, else `-1`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'active': false },\n *   { 'user': 'fred',    'active': false },\n *   { 'user': 'pebbles', 'active': true }\n * ];\n *\n * _.findIndex(users, function(o) { return o.user == 'barney'; });\n * // => 0\n *\n * // The `_.matches` iteratee shorthand.\n * _.findIndex(users, { 'user': 'fred', 'active': false });\n * // => 1\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.findIndex(users, ['active', false]);\n * // => 0\n *\n * // The `_.property` iteratee shorthand.\n * _.findIndex(users, 'active');\n * // => 2\n */\nfunction findIndex(array, predicate, fromIndex) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return -1;\n  }\n  var index = fromIndex == null ? 0 : toInteger(fromIndex);\n  if (index < 0) {\n    index = nativeMax(length + index, 0);\n  }\n  return baseFindIndex(array, baseIteratee(predicate, 3), index);\n}\n\nmodule.exports = findIndex;\n","var baseGet = require('./_baseGet');\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\nmodule.exports = get;\n","var baseHasIn = require('./_baseHasIn'),\n    hasPath = require('./_hasPath');\n\n/**\n * Checks if `path` is a direct or inherited property of `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.hasIn(object, 'a');\n * // => true\n *\n * _.hasIn(object, 'a.b');\n * // => true\n *\n * _.hasIn(object, ['a', 'b']);\n * // => true\n *\n * _.hasIn(object, 'b');\n * // => false\n */\nfunction hasIn(object, path) {\n  return object != null && hasPath(object, path, baseHasIn);\n}\n\nmodule.exports = hasIn;\n","/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\nmodule.exports = identity;\n","var baseIsArguments = require('./_baseIsArguments'),\n    isObjectLike = require('./isObjectLike');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\nmodule.exports = isArguments;\n","/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nmodule.exports = isArray;\n","var isFunction = require('./isFunction'),\n    isLength = require('./isLength');\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\nmodule.exports = isArrayLike;\n","var root = require('./_root'),\n    stubFalse = require('./stubFalse');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\nmodule.exports = isBuffer;\n","var baseGetTag = require('./_baseGetTag'),\n    isObject = require('./isObject');\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nmodule.exports = isFunction;\n","/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\nmodule.exports = isLength;\n","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nmodule.exports = isSymbol;\n","var baseIsTypedArray = require('./_baseIsTypedArray'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\nmodule.exports = isTypedArray;\n","var arrayLikeKeys = require('./_arrayLikeKeys'),\n    baseKeys = require('./_baseKeys'),\n    isArrayLike = require('./isArrayLike');\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\nmodule.exports = keys;\n","var arrayLikeKeys = require('./_arrayLikeKeys'),\n    baseKeysIn = require('./_baseKeysIn'),\n    isArrayLike = require('./isArrayLike');\n\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\nfunction keysIn(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n}\n\nmodule.exports = keysIn;\n","var MapCache = require('./_MapCache');\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = MapCache;\n\nmodule.exports = memoize;\n","var baseProperty = require('./_baseProperty'),\n    basePropertyDeep = require('./_basePropertyDeep'),\n    isKey = require('./_isKey'),\n    toKey = require('./_toKey');\n\n/**\n * Creates a function that returns the value at `path` of a given object.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n * @example\n *\n * var objects = [\n *   { 'a': { 'b': 2 } },\n *   { 'a': { 'b': 1 } }\n * ];\n *\n * _.map(objects, _.property('a.b'));\n * // => [2, 1]\n *\n * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n * // => [1, 2]\n */\nfunction property(path) {\n  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n}\n\nmodule.exports = property;\n","/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\nmodule.exports = stubArray;\n","/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = stubFalse;\n","var toNumber = require('./toNumber');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_INTEGER = 1.7976931348623157e+308;\n\n/**\n * Converts `value` to a finite number.\n *\n * @static\n * @memberOf _\n * @since 4.12.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted number.\n * @example\n *\n * _.toFinite(3.2);\n * // => 3.2\n *\n * _.toFinite(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toFinite(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toFinite('3.2');\n * // => 3.2\n */\nfunction toFinite(value) {\n  if (!value) {\n    return value === 0 ? value : 0;\n  }\n  value = toNumber(value);\n  if (value === INFINITY || value === -INFINITY) {\n    var sign = (value < 0 ? -1 : 1);\n    return sign * MAX_INTEGER;\n  }\n  return value === value ? value : 0;\n}\n\nmodule.exports = toFinite;\n","var toFinite = require('./toFinite');\n\n/**\n * Converts `value` to an integer.\n *\n * **Note:** This method is loosely based on\n * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted integer.\n * @example\n *\n * _.toInteger(3.2);\n * // => 3\n *\n * _.toInteger(Number.MIN_VALUE);\n * // => 0\n *\n * _.toInteger(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toInteger('3.2');\n * // => 3\n */\nfunction toInteger(value) {\n  var result = toFinite(value),\n      remainder = result % 1;\n\n  return result === result ? (remainder ? result - remainder : result) : 0;\n}\n\nmodule.exports = toInteger;\n","var isObject = require('./isObject'),\n    isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = toNumber;\n","var baseToString = require('./_baseToString');\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\nmodule.exports = toString;\n","/* globals module: false, require: false */\r\nmodule.exports = function (options) {\r\n\t'use strict';\r\n\tlet _fi = require('lodash/findIndex')\r\n\t\t// , _iseq = require('lodash/isEqual')\r\n\t\t, _clone = require('lodash/clone')\r\n\t\t//utilities\r\n\t\t// const\r\n\r\n\t\t, _iseq = (x, y) => {\r\n\r\n\t\t\tif (!Array.isArray(x) || !Array.isArray(y)) {\r\n\t\t\t\treturn x == y// eslint-disable-line eqeqeq\r\n\t\t\t\t// return x === y\r\n\t\t\t}\r\n\t\t\tif (x.length !== y.length) return false\r\n\t\t\tfor (let index = 0; index < x.length; index++) {\r\n\t\t\t\tif (!_iseq(x[index], y[index])) {\r\n\t\t\t\t\treturn false\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn true\r\n\r\n\t\t}\r\n\t\t, myIndexOf = (a, b) => {\r\n\t\t\treturn _fi(a, function (x) { return _iseq(x, b) });\r\n\t\t}\r\n\t// this version, without the _fi dependency, doesn't work!todo\r\n\t//  , myIndexOf = (array, item) => {\r\n\t// \t\tfor (let index = 0; index < array.length; index++) {\r\n\t// \t\t\tif (_iseq(array[index], item)) {\r\n\t// \t\t\t\treturn index;\r\n\r\n\t// \t\t\t}\r\n\t// \t\t\treturn -1;\r\n\t// \t\t}\r\n\r\n\t// \t}\r\n\r\n\t// \t, _clone = require('lodash/clone')\r\n\r\n\r\n\toptions = options || {}\r\n\t// boardMode = options.boardMode || 't'/*t:toroid; c:classic */\r\n\t// , boardDimensions = options.boardDimensions || [11, 11]/*move later*/\r\n\t// , rules = options.rules || {\r\n\t// suicide: true,\r\n\t// superko: false\r\n\t// }\r\n\tlet $ = {}\r\n\t////problem with the object spread operator and the build so using Object.assign instead.\r\n\t// $.rules = {\r\n\t// \t\tsuicide: true,\r\n\t// \t\t// superko: false /*todo: enforce when true?*/,\r\n\t// \t\tkomi: 7.5,\r\n\t// \t\t... options.rules\r\n\t// \t}\r\n\t$.rules = Object.assign({}, {\r\n\t\tsuicide: true,\r\n\t\t// superko: false /*todo: enforce when true?*/,\r\n\t\tkomi: 7.5,\r\n\t}, options.rules)\r\n\r\n\t// $.moves = options.moves || []\r\n\t$.options = options\r\n\toptions.boardDimensions = options.boardDimensions || [11, 11]\r\n\toptions.boardMode = options.boardMode || 't'/*t:toroid; c:classic */\r\n\t$.board = {}\r\n\t$.board.blackStones = options.blackStones || []\r\n\t$.board.whiteStones = options.whiteStones || []\r\n\r\n\t$.board.nextPlayer = options.nextPlayer || \"b\"\r\n\t$.board.captured = options.captured || [0, 0]\r\n\r\n\t$.exportData = function () {\r\n\t\treturn {\r\n\t\t\tblackStones: $.board.blackStones.map(_clone),\r\n\r\n\t\t\twhiteStones: $.board.whiteStones.map(_clone),\r\n\t\t\tcaptured: _clone($.board.captured),\r\n\t\t\tnextPlayer: $.board.nextPlayer\r\n\t\t}\r\n\t}\r\n\r\n\t$.loadData = function (data) {\r\n\t\t$.board.blackStones = data.blackStones\r\n\t\t$.board.whiteStones = data.whiteStones\r\n\t\t$.board.captured = data.captured\r\n\t\t$.board.nextPlayer = data.nextPlayer\r\n\t}\r\n\r\n\t//toroid\r\n\tif (options.boardMode === 't') $.board.getNeighbours =\r\n\t\tfunction (point) {\r\n\t\t\tlet result = []\r\n\t\t\tfor (let i = 0; i < 4; i++) {\r\n\t\t\t\tlet newPoint\r\n\t\t\t\tswitch (i) {\r\n\t\t\t\t\tcase 0:\r\n\t\t\t\t\t\tnewPoint = [point[0] + 1, point[1]]\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\tcase 1:\r\n\t\t\t\t\t\tnewPoint = [point[0] - 1, point[1]]\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\tcase 2:\r\n\t\t\t\t\t\tnewPoint = [point[0], point[1] + 1]\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\tcase 3:\r\n\t\t\t\t\t\tnewPoint = [point[0], point[1] - 1]\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t}\r\n\t\t\t\tresult.push([(newPoint[0] + options.boardDimensions[0]) % options.boardDimensions[0], (newPoint[1] + options.boardDimensions[1]) % options.boardDimensions[1]])\r\n\t\t\t}\r\n\t\t\treturn result\r\n\t\t}\r\n\tif (options.boardMode === 'c') $.board.getNeighbours =\r\n\t\tfunction (point) {\r\n\t\t\tlet result = []\r\n\t\t\tfor (let i = 0; i < 4; i++) {\r\n\t\t\t\tlet newPoint\r\n\t\t\t\tswitch (i) {\r\n\t\t\t\t\tcase 0:\r\n\t\t\t\t\t\tnewPoint = [point[0] + 1, point[1]]\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\tcase 1:\r\n\t\t\t\t\t\tnewPoint = [point[0] - 1, point[1]]\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\tcase 2:\r\n\t\t\t\t\t\tnewPoint = [point[0], point[1] + 1]\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\tcase 3:\r\n\t\t\t\t\t\tnewPoint = [point[0], point[1] - 1]\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t}\r\n\t\t\t\tif (newPoint[0] >= 0 && newPoint[0] < options.boardDimensions[0]\r\n\t\t\t\t\t&& newPoint[1] >= 0 && newPoint[1] < options.boardDimensions[1]\r\n\t\t\t\t)\r\n\t\t\t\t\tresult.push(newPoint)\r\n\t\t\t}\r\n\t\t\treturn result\r\n\t\t}\r\n\t//todo: klein, projective plane, \r\n\r\n\t$.board.isEmpty = function (point) {\r\n\t\treturn myIndexOf($.board.blackStones, point) < 0\r\n\t\t\t&& myIndexOf($.board.whiteStones, point) < 0\r\n\t}\r\n\t$.board.getColour = function (point) {\r\n\t\tif (myIndexOf($.board.blackStones, point) >= 0) return 'b'\r\n\t\tif (myIndexOf($.board.whiteStones, point) >= 0) return 'w'\r\n\t\treturn 'e'\r\n\t}\r\n\t/**\r\n\t * Determines if a point is part of a chain with a liberty; if there are no liberties then it returns the chain of stones of the same colour that are connected to `startPoint`. Also used for counting to return connected components of same colour (black, white or empty).\r\n\t * @param {*} startPoint \r\n\t * @param {string|null} chainColour indicates the colour of the starting point.\r\n\t * @param {*} [stopColour='e'] stop working if the chain meets this colour\r\n\t * @param {Function} [getColour=$.board.getColour] Function used to determine the colour of a point.\r\n\t * @returns {bool|array} Returns `true` if the the component meets `stopColour`, and an array containing connected component of points linked to `startPoint` otherwise. \r\n\t */\t\r\n\tfunction chainHasLiberty (startPoint, chainColour, stopColour, getColour) {\r\n\t\tif (stopColour === undefined)\r\n\t\t\tstopColour = 'e'//by default, stop getting the chain when there is a liberty.\r\n\t\tif (getColour === undefined)\r\n\t\t\tgetColour = $.board.getColour//by default, use the usual board colour function\r\n\r\n\t\tif (chainColour === null)\r\n\t\t\tchainColour = getColour(startPoint)\r\n\t\tlet\r\n\t\t\tchain = [startPoint]\r\n\t\t\t, toExplore = []\r\n\t\t\t, point = startPoint //assumed to be of colour chainColour\r\n\r\n\t\twhile (point !== undefined) {\r\n\r\n\t\t\tlet neighbours = $.board.getNeighbours(point)\r\n\t\t\tfor (let i = 0; i < neighbours.length; i++) {\r\n\t\t\t\tlet newPoint = neighbours[i],\r\n\t\t\t\t\tnewColour = getColour(newPoint)\r\n\t\t\t\tif (newColour === stopColour) return true;\r\n\t\t\t\tif (newColour === chainColour) {\r\n\t\t\t\t\tif (myIndexOf(chain, newPoint) < 0) {\r\n\t\t\t\t\t\tchain.push(newPoint)\r\n\t\t\t\t\t\t// if (myIndexOf(toExplore, newPoint) < 0)\r\n\t\t\t\t\t\ttoExplore.push(newPoint)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tpoint = toExplore.pop()\r\n\t\t}\r\n\r\n\t\treturn chain;\r\n\t}\r\n\r\n\t$.board.chainHasLiberty = chainHasLiberty \r\n\r\n\t$.board.score = function (deadStones) {\r\n\t\t/*\r\n\t\tgo through the whole board \r\n\t\t*/\r\n\t\tif (deadStones === undefined) {\r\n\t\t\tdeadStones = []\r\n\t\t}\r\n\r\n\t\tlet result = {\r\n\t\t\tblackEmpty: []\r\n\t\t\t, whiteEmpty: []\r\n\t\t\t, dame: []\r\n\t\t\t, blackAlive: []\r\n\t\t\t, whiteAlive: []\r\n\t\t\t, blackDead: []\r\n\t\t\t, whiteDead: []\r\n\t\t\t, totalBlackCaptured: $.board.captured[0] //nb B stones removed by W during the game\r\n\t\t\t, totalWhiteCaptured: $.board.captured[1] //nb W stones removed by B during the game\r\n\t\t\t//todo:could replace by an class. data stored in a big array of pairs [point, status]\r\n\t\t}\r\n\r\n\t\tfor (let index = 0; index < deadStones.length; index++) {\r\n\t\t\tconst deadStone = deadStones[index];\r\n\t\t\tlet deadColour = $.board.getColour(deadStone)\r\n\t\t\tif (deadColour === 'e') throw new Error('invalid marked dead stone')\r\n\t\t\tlet\r\n\t\t\t\tdeadToFill = deadColour === 'b' ? result.blackDead : result.whiteDead\r\n\t\t\t\t, emptyToFill = deadColour === 'b' ? result.whiteEmpty : result.blackEmpty\r\n\t\t\t\t, aliveToFill = deadColour === 'b' ? result.whiteAlive : result.blackAlive\r\n\t\t\t\t, processPoint = (point, colour) => {\r\n\t\t\t\t\tif (colour === deadColour && myIndexOf(deadToFill, point) < 0) {\r\n\t\t\t\t\t\tdeadToFill.push(point)\r\n\t\t\t\t\t\temptyToFill.push(point)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ((colour === deadColour || colour === 'e') && myIndexOf(emptyToFill, point) < 0) {\r\n\t\t\t\t\t\temptyToFill.push(point)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (colour !== deadColour && colour !== 'e' && myIndexOf(aliveToFill, point) < 0) {\r\n\t\t\t\t\t\taliveToFill.push(point)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t, getColourForDeadComponent = (point) => {\r\n\t\t\t\t\tlet colour = $.board.getColour(point)\r\n\t\t\t\t\tprocessPoint(point, colour)\r\n\t\t\t\t\treturn colour === deadColour ? 'e' : colour\r\n\t\t\t\t}\r\n\t\t\tprocessPoint(deadStone, deadColour)\r\n\t\t\t$.board.chainHasLiberty(deadStone, 'e', '', getColourForDeadComponent)\r\n\t\t}\r\n\r\n\t\tfor (let i = 0,exitLoop = false; i < options.boardDimensions[0]; i++) {\r\n\t\t\tif (exitLoop) {\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t\tfor (let j = 0; j < options.boardDimensions[1]; j++) {\r\n\t\t\t\tif (result.blackEmpty.length\r\n\t\t\t\t\t+ result.whiteEmpty.length\r\n\t\t\t\t\t+ result.dame.length\r\n\t\t\t\t\t+ result.blackAlive.length\r\n\t\t\t\t\t+ result.whiteAlive.length\r\n\t\t\t\t\t// + result.blackDead.length\r\n\t\t\t\t\t// + result.whiteDead.length\r\n\t\t\t\t\t=== options.boardDimensions[0] * options.boardDimensions[1]\r\n\t\t\t\t) {\r\n\t\t\t\t\texitLoop = true\r\n\t\t\t\t\tbreak\r\n\t\t\t\t}\r\n\t\t\t\tconst point = [i, j], colour = $.board.getColour(point)\r\n\r\n\t\t\t\tif (colour === 'b'\r\n\t\t\t\t) {\r\n\t\t\t\t\tif (myIndexOf(result.blackAlive, point) < 0\r\n\t\t\t\t\t\t&& myIndexOf(result.blackDead, point) < 0) {\r\n\t\t\t\t\t\tresult.blackAlive.push(point)\r\n\t\t\t\t\t} else continue\r\n\t\t\t\t}\r\n\t\t\t\tif (colour === 'w') {\r\n\t\t\t\t\tif (myIndexOf(result.whiteAlive, point) < 0\r\n\t\t\t\t\t\t&& myIndexOf(result.whiteDead, point) < 0) {\r\n\t\t\t\t\t\tresult.whiteAlive.push(point)\r\n\t\t\t\t\t} else continue\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (colour === 'e') {\r\n\t\t\t\t\tif (myIndexOf(result.blackEmpty, point) >= 0\r\n\t\t\t\t\t\t|| myIndexOf(result.whiteEmpty, point) >= 0\r\n\t\t\t\t\t\t|| myIndexOf(result.dame, point) >= 0) {\r\n\t\t\t\t\t\tcontinue\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlet\r\n\t\t\t\t\t\tmeetsBlack = false\r\n\t\t\t\t\t\t, meetsWhite = false\r\n\t\t\t\t\t\t, isBlackTerritory = false\r\n\t\t\t\t\t\t, isWhiteTerritory = false\r\n\t\t\t\t\t\t, getColourForScoring = (point) => {\r\n\r\n\t\t\t\t\t\t\tlet colour = $.board.getColour(point)\r\n\t\t\t\t\t\t\tswitch (colour) {\r\n\t\t\t\t\t\t\t\tcase 'b':\r\n\t\t\t\t\t\t\t\t\tif (myIndexOf(result.blackDead, point) >= 0) {\r\n\t\t\t\t\t\t\t\t\t\tcolour = 'e'\r\n\t\t\t\t\t\t\t\t\t\tisWhiteTerritory = true\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\t\tmeetsBlack = true\r\n\t\t\t\t\t\t\t\t\t\tif (myIndexOf(result.blackAlive, point) < 0) {\r\n\t\t\t\t\t\t\t\t\t\t\tresult.blackAlive.push(point)\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\tcase 'w':\r\n\t\t\t\t\t\t\t\t\tif (myIndexOf(result.whiteDead, point) >= 0) {\r\n\t\t\t\t\t\t\t\t\t\tcolour = 'e'\r\n\t\t\t\t\t\t\t\t\t\tisBlackTerritory = true\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\t\tmeetsWhite = true\r\n\t\t\t\t\t\t\t\t\t\tif (myIndexOf(result.whiteAlive, point) < 0) {\r\n\t\t\t\t\t\t\t\t\t\t\tresult.whiteAlive.push(point)\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\tdefault://nothing needed for 'e'\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn colour\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\tlet emptyComponent = $.board.chainHasLiberty(point, 'e', '', getColourForScoring)\r\n\t\t\t\t\tif (!meetsBlack && !meetsWhite) {\r\n\t\t\t\t\t\tthrow new Error('counting an empty board!')\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (isBlackTerritory && isWhiteTerritory) {\r\n\t\t\t\t\t\tthrow new Error('too many stones marked as dead')\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//could store the different empty components: V2 \r\n\t\t\t\t\tif (meetsBlack && meetsWhite) {\r\n\t\t\t\t\t\tresult.dame = result.dame.concat(emptyComponent)\r\n\t\t\t\t\t\tcontinue\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (meetsBlack) {\r\n\t\t\t\t\t\tresult.blackEmpty = result.blackEmpty.concat(emptyComponent)\r\n\t\t\t\t\t\tcontinue\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (meetsWhite) {\r\n\t\t\t\t\t\tresult.whiteEmpty = result.whiteEmpty.concat(emptyComponent)\r\n\t\t\t\t\t\tcontinue\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t//totals\r\n\t\tresult.totalBlackDead = result.blackDead.length\r\n\t\tresult.totalWhiteDead = result.whiteDead.length\r\n\t\tresult.totalBlackTerritory = result.blackEmpty.length\r\n\t\tresult.totalWhiteTerritory = result.whiteEmpty.length\r\n\r\n\r\n\t\t//todo: implement other rulesets. For now, just do territory + prisoners (Japanese style counting)\r\n\t\tresult.blackScore =\r\n\t\t\tresult.totalWhiteDead\r\n\t\t\t+ result.totalWhiteCaptured\r\n\t\t\t+ result.totalBlackTerritory\r\n\t\tresult.whiteScore =\r\n\t\t\tresult.totalBlackDead\r\n\t\t\t+ result.totalBlackCaptured\r\n\t\t\t+ result.totalWhiteTerritory\r\n\t\t\t+ $.rules.komi\r\n\t\tlet r = result.blackScore - result.whiteScore\r\n\t\tif (r === 0) result.RE = '0'\r\n\t\telse if (r > 0) result.RE = 'B+' + r\r\n\t\telse result.RE = 'W+' + (-r)\r\n\t\treturn result\r\n\t}\r\n\r\n\t$.board.empty = function () {\r\n\t\t$.board.whiteStones = []\r\n\t\t$.board.blackStones = []\r\n\t\t$.board.captured = [0, 0]\r\n\r\n\t}\r\n\r\n\t$.removeChain = function (chain, colour) {\r\n\t\tlet toRemoveFrom = colour === 'w' ? $.board.whiteStones : $.board.blackStones\r\n\t\tfor (let j = 0; j < chain.length; j++) {\r\n\t\t\tlet index = myIndexOf(toRemoveFrom, chain[j])\r\n\t\t\ttoRemoveFrom.splice(index, 1)\r\n\t\t\tif (colour === 'w') $.board.captured[1] = $.board.captured[1] + 1\r\n\t\t\telse $.board.captured[0] = $.board.captured[0] + 1\r\n\t\t}\r\n\t}\r\n\t$.play = function (playerColour, point) {\r\n\r\n\r\n\r\n\t\t// let result = \"ok\"\r\n\t\tif (!$.board.isEmpty(point))\r\n\t\t\tthrow new Error('point is not empty')\r\n\t\t// console.log('point is not empty' + point)\r\n\r\n\t\tif (playerColour === 'b') $.board.blackStones.push(point)\r\n\t\telse $.board.whiteStones.push(point)\r\n\r\n\t\tlet neighbours = $.board.getNeighbours(point)\r\n\t\t\t, removed = []//chains removed\r\n\r\n\t\tfor (let i = 0; i < neighbours.length; i++) {\r\n\t\t\tlet neighbour = neighbours[i], colour = $.board.getColour(neighbour)\r\n\t\t\tif (colour === playerColour || colour === 'e') continue\r\n\t\t\tlet oppColour = $.getOppositeColour(playerColour),\r\n\t\t\t\tr = $.board.chainHasLiberty(neighbour, oppColour)\r\n\t\t\tif (r === true) continue\r\n\t\t\t////remove - no liberties\r\n\t\t\tremoved[removed.length] = r\r\n\r\n\t\t\t$.removeChain(r, oppColour)\r\n\r\n\t\t\t// let chainToRemove = r[1],\r\n\t\t\t// toRemoveFrom = playerColour === 'b' ? $.board.whiteStones : $.board.blackStones\r\n\t\t\t// for (let j = 0; j<chainToRemove.length; j++)\r\n\t\t\t// {\r\n\t\t\t// let index = myIndexOf(toRemoveFrom,chainToRemove[j])\r\n\t\t\t// toRemoveFrom.splice(index, 1)\r\n\t\t\t// if (playerColour === 'b') $.board.captured[1] = $.board.captured[1] + 1\r\n\t\t\t// else $.board.captured[0] = $.board.captured[0] + 1\r\n\t\t\t// }\r\n\t\t\t// removed = true\r\n\t\t}\r\n\t\tlet suicide = false\r\n\t\tif (removed.length === 0) {\r\n\t\t\tlet s = $.board.chainHasLiberty(point, playerColour)\r\n\t\t\tif (s !== true) {\r\n\t\t\t\tif ($.rules.suicide) {\r\n\t\t\t\t\t$.removeChain(s, playerColour)\r\n\t\t\t\t\tsuicide = s\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tthrow new Error('suicide')//isnt allowed\r\n\t\t\t\t\t//todo: remove point from whiteStones or blackStones\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\t\tstoring the situation in memory - would be useful when implementing going back a move, superko, \r\n\t\t\tnot needed for now\r\n\t\t*/\r\n\t\t//$.moves.push([playerColour,point,_.clone($.board.whiteStones),_.clone($.board.blackStones)])\r\n\t\t// $.moves.push([playerColour,point])\r\n\r\n\t\t// getNeighbours[i] = [getNeighbours[i], $.board.getColour[getNeighbours[i]]\r\n\t\t// //\r\n\r\n\r\n\t\treturn { removed, suicide }\r\n\t}\r\n\t$.getOppositeColour = function (colour) {\r\n\t\tswitch (colour) {\r\n\t\t\tcase 'b':\r\n\t\t\t\treturn 'w'\r\n\t\t\tcase 'w':\r\n\t\t\t\treturn 'b'\r\n\t\t}\r\n\t\treturn null\r\n\t}\r\n\treturn $\r\n\r\n}","var baseIndexOf = require('./_baseIndexOf');\n\n/**\n * A specialized version of `_.includes` for arrays without support for\n * specifying an index to search from.\n *\n * @private\n * @param {Array} [array] The array to inspect.\n * @param {*} target The value to search for.\n * @returns {boolean} Returns `true` if `target` is found, else `false`.\n */\nfunction arrayIncludes(array, value) {\n  var length = array == null ? 0 : array.length;\n  return !!length && baseIndexOf(array, value, 0) > -1;\n}\n\nmodule.exports = arrayIncludes;\n","/**\n * This function is like `arrayIncludes` except that it accepts a comparator.\n *\n * @private\n * @param {Array} [array] The array to inspect.\n * @param {*} target The value to search for.\n * @param {Function} comparator The comparator invoked per element.\n * @returns {boolean} Returns `true` if `target` is found, else `false`.\n */\nfunction arrayIncludesWith(array, value, comparator) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (comparator(value, array[index])) {\n      return true;\n    }\n  }\n  return false;\n}\n\nmodule.exports = arrayIncludesWith;\n","var arrayPush = require('./_arrayPush'),\n    isFlattenable = require('./_isFlattenable');\n\n/**\n * The base implementation of `_.flatten` with support for restricting flattening.\n *\n * @private\n * @param {Array} array The array to flatten.\n * @param {number} depth The maximum recursion depth.\n * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n * @param {Array} [result=[]] The initial result value.\n * @returns {Array} Returns the new flattened array.\n */\nfunction baseFlatten(array, depth, predicate, isStrict, result) {\n  var index = -1,\n      length = array.length;\n\n  predicate || (predicate = isFlattenable);\n  result || (result = []);\n\n  while (++index < length) {\n    var value = array[index];\n    if (depth > 0 && predicate(value)) {\n      if (depth > 1) {\n        // Recursively flatten arrays (susceptible to call stack limits).\n        baseFlatten(value, depth - 1, predicate, isStrict, result);\n      } else {\n        arrayPush(result, value);\n      }\n    } else if (!isStrict) {\n      result[result.length] = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseFlatten;\n","var baseFindIndex = require('./_baseFindIndex'),\n    baseIsNaN = require('./_baseIsNaN'),\n    strictIndexOf = require('./_strictIndexOf');\n\n/**\n * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseIndexOf(array, value, fromIndex) {\n  return value === value\n    ? strictIndexOf(array, value, fromIndex)\n    : baseFindIndex(array, baseIsNaN, fromIndex);\n}\n\nmodule.exports = baseIndexOf;\n","/**\n * The base implementation of `_.isNaN` without support for number objects.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n */\nfunction baseIsNaN(value) {\n  return value !== value;\n}\n\nmodule.exports = baseIsNaN;\n","var SetCache = require('./_SetCache'),\n    arrayIncludes = require('./_arrayIncludes'),\n    arrayIncludesWith = require('./_arrayIncludesWith'),\n    cacheHas = require('./_cacheHas'),\n    createSet = require('./_createSet'),\n    setToArray = require('./_setToArray');\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * The base implementation of `_.uniqBy` without support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} [iteratee] The iteratee invoked per element.\n * @param {Function} [comparator] The comparator invoked per element.\n * @returns {Array} Returns the new duplicate free array.\n */\nfunction baseUniq(array, iteratee, comparator) {\n  var index = -1,\n      includes = arrayIncludes,\n      length = array.length,\n      isCommon = true,\n      result = [],\n      seen = result;\n\n  if (comparator) {\n    isCommon = false;\n    includes = arrayIncludesWith;\n  }\n  else if (length >= LARGE_ARRAY_SIZE) {\n    var set = iteratee ? null : createSet(array);\n    if (set) {\n      return setToArray(set);\n    }\n    isCommon = false;\n    includes = cacheHas;\n    seen = new SetCache;\n  }\n  else {\n    seen = iteratee ? [] : result;\n  }\n  outer:\n  while (++index < length) {\n    var value = array[index],\n        computed = iteratee ? iteratee(value) : value;\n\n    value = (comparator || value !== 0) ? value : 0;\n    if (isCommon && computed === computed) {\n      var seenIndex = seen.length;\n      while (seenIndex--) {\n        if (seen[seenIndex] === computed) {\n          continue outer;\n        }\n      }\n      if (iteratee) {\n        seen.push(computed);\n      }\n      result.push(value);\n    }\n    else if (!includes(seen, computed, comparator)) {\n      if (seen !== result) {\n        seen.push(computed);\n      }\n      result.push(value);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseUniq;\n","var Set = require('./_Set'),\n    noop = require('./noop'),\n    setToArray = require('./_setToArray');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Creates a set object of `values`.\n *\n * @private\n * @param {Array} values The values to add to the set.\n * @returns {Object} Returns the new set.\n */\nvar createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {\n  return new Set(values);\n};\n\nmodule.exports = createSet;\n","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n","var Symbol = require('./_Symbol'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray');\n\n/** Built-in value references. */\nvar spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;\n\n/**\n * Checks if `value` is a flattenable `arguments` object or array.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n */\nfunction isFlattenable(value) {\n  return isArray(value) || isArguments(value) ||\n    !!(spreadableSymbol && value && value[spreadableSymbol]);\n}\n\nmodule.exports = isFlattenable;\n","/**\n * A specialized version of `_.indexOf` which performs strict equality\n * comparisons of values, i.e. `===`.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction strictIndexOf(array, value, fromIndex) {\n  var index = fromIndex - 1,\n      length = array.length;\n\n  while (++index < length) {\n    if (array[index] === value) {\n      return index;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = strictIndexOf;\n","var baseFlatten = require('./_baseFlatten');\n\n/**\n * Flattens `array` a single level deep.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to flatten.\n * @returns {Array} Returns the new flattened array.\n * @example\n *\n * _.flatten([1, [2, [3, [4]], 5]]);\n * // => [1, 2, [3, [4]], 5]\n */\nfunction flatten(array) {\n  var length = array == null ? 0 : array.length;\n  return length ? baseFlatten(array, 1) : [];\n}\n\nmodule.exports = flatten;\n","/**\n * This method returns `undefined`.\n *\n * @static\n * @memberOf _\n * @since 2.3.0\n * @category Util\n * @example\n *\n * _.times(2, _.noop);\n * // => [undefined, undefined]\n */\nfunction noop() {\n  // No operation performed.\n}\n\nmodule.exports = noop;\n","var baseIteratee = require('./_baseIteratee'),\n    baseUniq = require('./_baseUniq');\n\n/**\n * This method is like `_.uniq` except that it accepts `iteratee` which is\n * invoked for each element in `array` to generate the criterion by which\n * uniqueness is computed. The order of result values is determined by the\n * order they occur in the array. The iteratee is invoked with one argument:\n * (value).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n * @returns {Array} Returns the new duplicate free array.\n * @example\n *\n * _.uniqBy([2.1, 1.2, 2.3], Math.floor);\n * // => [2.1, 1.2]\n *\n * // The `_.property` iteratee shorthand.\n * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n * // => [{ 'x': 1 }, { 'x': 2 }]\n */\nfunction uniqBy(array, iteratee) {\n  return (array && array.length) ? baseUniq(array, baseIteratee(iteratee, 2)) : [];\n}\n\nmodule.exports = uniqBy;\n","/**\n * Convert SGF files to a JS object\n * @param {string} sgf A valid SGF file.\n * @see http://www.red-bean.com/sgf/sgf4.html\n * @return {object} The SGF file represented as a JS object\n */\nexports.parse = function (sgf) {\n\t'use strict';\n\n\tvar parse;\n\tvar parser;\n\tvar collection = {};\n\n\t// tracks the current sequence\n\tvar sequence;\n\n\t// tracks the current node\n\tvar node;\n\n\t// tracks the last PropIdent\n\tvar lastPropIdent;\n\n\t// A map of functions to parse the different components of an SGF file\n\tparser = {\n\n\t\tbeginSequence: function (sgf) {\n\t\t\tvar key = 'sequences';\n\n\t\t\t// Top-level sequences are gameTrees\n\t\t\tif (!sequence) {\n\t\t\t\tsequence = collection;\n\t\t\t\tkey = 'gameTrees';\n\t\t\t}\n\n\t\t\tif (sequence.gameTrees) {\n\t\t\t\tkey = 'gameTrees';\n\t\t\t}\n\n\t\t\tvar newSequence = {\n\t\t\t\tparent: sequence\n\t\t\t};\n\n\t\t\tsequence[key] = sequence[key] || [];\n\t\t\tsequence[key].push(newSequence);\n\t\t\tsequence = newSequence;\n\n\t\t\treturn sgf.substring(1);\n\t\t},\n\n\t\tendSequence: function (sgf) {\n\t\t\tif (sequence.parent) {\n\t\t\t\tsequence = sequence.parent;\n\t\t\t} else {\n\t\t\t\tsequence = null;\n\t\t\t}\n\t\t\treturn sgf.substring(1);\n\t\t},\n\n\t\tnode: function (sgf) {\n\t\t\tnode = {};\n\t\t\tsequence.nodes = sequence.nodes || [];\n\t\t\tsequence.nodes.push(node);\n\t\t\treturn sgf.substring(1);\n\t\t},\n\n\t\tproperty: function (sgf) {\n\t\t\tvar propValue;\n\n\t\t\t// Search for the first unescaped ]\n\t\t\tvar firstPropEnd = sgf.match(/([^\\\\\\]]|\\\\(.|\\n|\\r))*\\]/);\n\n\t\t\tif (!firstPropEnd.length) {\n\t\t\t\tthrow new Error('malformed sgf');\n\t\t\t}\n\n\t\t\tfirstPropEnd = firstPropEnd[0].length;\n\n\t\t\tvar property = sgf.substring(0, firstPropEnd);\n\t\t\tvar propValueBegin = property.indexOf('[');\n\t\t\tvar propIdent = property.substring(0, propValueBegin);\n\n\t\t\t// Point lists don't declare a PropIdent for each PropValue\n\t\t\t// Instead, they should use the last declared property\n\t\t\t// See: http://www.red-bean.com/sgf/sgf4.html#move/pos\n\t\t\tif (!propIdent) {\n\t\t\t\tpropIdent = lastPropIdent;\n\n\t\t\t\t// If this is the first property in a list of multiple\n\t\t\t\t// properties, we need to wrap the PropValue in an array\n\t\t\t\tif (!Array.isArray(node[propIdent])) {\n\t\t\t\t\tnode[propIdent] = [node[propIdent]];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlastPropIdent = propIdent;\n\n\t\t\tpropValue = property.substring(propValueBegin + 1, property.length - 1);\n\n\t\t\t// We have no problem parsing PropIdents of any length, but the spec\n\t\t\t// says they should be no longer than two characters.\n\t\t\t//\n\t\t\t// http://www.red-bean.com/sgf/sgf4.html#2.2\n\t\t\tif (propIdent.length > 2) {\n\t\t\t\t// TODO: What's the best way to issue a warning?\n\t\t\t\tconsole.warn(\n\t\t\t\t\t'SGF PropIdents should be no longer than two characters:', propIdent\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (Array.isArray(node[propIdent])) {\n\t\t\t\tnode[propIdent].push(propValue);\n\t\t\t} else {\n\t\t\t\tnode[propIdent] = propValue;\n\t\t\t}\n\n\t\t\treturn sgf.substring(firstPropEnd);\n\t\t},\n\n\t\t// Whitespace, tabs, or anything else we don't recognize\n\t\tunrecognized: function (sgf) {\n\n\t\t\t// March ahead to the next character\n\t\t\treturn sgf.substring(1);\n\t\t}\n\t};\n\n\t// Processes an SGF file character by character\n\tparse = function (sgf) {\n\t\twhile (sgf) {\n\t\t\tvar initial = sgf.substring(0, 1);\n\t\t\tvar type;\n\n\t\t\t// Use the initial (the first character in the remaining sgf file) to\n\t\t\t// decide which parser function to use\n\t\t\tif (initial === '(') {\n\t\t\t\ttype = 'beginSequence';\n\t\t\t} else if (initial === ')') {\n\t\t\t\ttype = 'endSequence';\n\t\t\t} else if (initial === ';') {\n\t\t\t\ttype = 'node';\n\t\t\t} else if (initial.search(/[A-Z\\[]/) !== -1) {\n\t\t\t\ttype = 'property';\n\t\t\t} else {\n\t\t\t\ttype = 'unrecognized';\n\t\t\t}\n\n\t\t\tsgf = parser[type](sgf);\n\t\t}\n\n\t\treturn collection;\n\t};\n\n\t// Begin parsing the SGF file\n\treturn parse(sgf);\n};\n\n/**\n * Generate an SGF file from a SmartGame Record JavaScript Object\n * @param {object} record A record object.\n * @return {string} The record as a string suitable for saving as an SGF file\n */\nexports.generate = function (record) {\n\t'use strict';\n\n\tfunction stringifySequences(sequences) {\n\t\tvar contents = '';\n\n\t\tsequences.forEach(function (sequence) {\n\t\t\tcontents += '(';\n\n\t\t\t// Parse all nodes in this sequence\n\t\t\tif (sequence.nodes) {\n\t\t\t\tsequence.nodes.forEach(function (node) {\n\t\t\t\t\tvar nodeString = ';';\n\t\t\t\t\tfor (var property in node) {\n\t\t\t\t\t\tif (node.hasOwnProperty(property)) {\n\t\t\t\t\t\t\tvar prop = node[property];\n\t\t\t\t\t\t\tif (Array.isArray(prop)) {\n\t\t\t\t\t\t\t\tprop = prop.join('][');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnodeString += property + '[' + prop + ']';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcontents += nodeString;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Call the function we're in recursively for any child sequences\n\t\t\tif (sequence.sequences) {\n\t\t\t\tcontents += stringifySequences(sequence.sequences);\n\t\t\t}\n\n\t\t\tcontents += ')';\n\t\t});\n\n\t\treturn contents;\n\t}\n\n\treturn stringifySequences(record.gameTrees);\n};\n\n","/**\n * Interact with smartgame objects.\n * @param {object} smartgame A JS Object representing a smartgame\n * @see http://www.red-bean.com/sgf/sgf4.html\n * @return {object} An object with methods for navigating and manipulating a\n * smartgame\n */\nmodule.exports = function (smartgame) {\n\t'use strict';\n\n\tvar sequence;\n\tvar node;\n\n\tvar Smartgamer = function () {\n\t\tthis.init();\n\t};\n\n\tSmartgamer.prototype = {\n\t\tinit: function () {\n\t\t\tif (smartgame) {\n\t\t\t\tthis.game = smartgame.gameTrees[0];\n\t\t\t\tthis.reset();\n\t\t\t}\n\t\t},\n\n\t\t// Load a smartgame to make it possible to load new games or add one after\n\t\t// initialization, if desired\n\t\tload: function (newSmartgame) {\n\t\t\tsmartgame = newSmartgame;\n\t\t\tthis.init();\n\t\t},\n\n\t\t// Having multiple games in a collection is not common, but it's part of\n\t\t// the spec\n\t\tgames: function () {\n\t\t\treturn smartgame.gameTrees;\n\t\t},\n\n\t\tselectGame: function (i) {\n\t\t\tif (i < smartgame.gameTrees.length) {\n\t\t\t\tthis.game = smartgame.gameTrees[i];\n\t\t\t\tthis.reset();\n\t\t\t} else {\n\t\t\t\tthrow new Error('the collection doesn\\'t contain that many games');\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\treset: function () {\n\t\t\tsequence = this.game;\n\t\t\tnode = sequence.nodes[0];\n\t\t\tthis.path = { m: 0 };\n\n\t\t\treturn this;\n\t\t},\n\n\t\tgetSmartgame: function () {\n\t\t\treturn smartgame;\n\t\t},\n\n\t\t/**\n\t\t * Return any variations available at the current move\n\t\t **/\n\t\tvariations: function () {\n\t\t\tif (sequence) {\n\t\t\t\tvar localNodes = sequence.nodes;\n\t\t\t\tvar localIndex = (localNodes) ? localNodes.indexOf(node) : null;\n\n\t\t\t\tif (localNodes) {\n\t\t\t\t\tif (localIndex === (localNodes.length - 1)) {\n\t\t\t\t\t\treturn sequence.sequences || [];\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn [];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Go to the next move\n\t\t **/\n\t\tnext: function (variation) {\n\t\t\tvariation = variation || 0;\n\n\t\t\tvar localNodes = sequence.nodes;\n\t\t\tvar localIndex = (localNodes) ? localNodes.indexOf(node) : null;\n\n\t\t\t// If there are no additional nodes in this sequence,\n\t\t\t// advance to the next one\n\t\t\tif (localIndex === null || localIndex >= (localNodes.length - 1)) {\n\t\t\t\tif (sequence.sequences) {\n\t\t\t\t\tif (sequence.sequences[variation]) {\n\t\t\t\t\t\tsequence = sequence.sequences[variation];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsequence = sequence.sequences[0];\n\t\t\t\t\t}\n\n\t\t\t\t\tnode = sequence.nodes[0];\n\n\t\t\t\t\t// Note the fork chosen for this variation in the path\n\t\t\t\t\tthis.path[this.path.m] = variation;\n\t\t\t\t\tthis.path.m += 1;\n\t\t\t\t} else {\n\t\t\t\t\t// End of sequence / game\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnode = localNodes[localIndex + 1];\n\t\t\t\tthis.path.m += 1;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\t/**\n\t\t * Go to the previous move\n\t\t **/\n\t\tprevious: function () {\n\t\t\tvar localNodes = sequence.nodes;\n\t\t\tvar localIndex = (localNodes) ? localNodes.indexOf(node) : null;\n\n\t\t\t// Delete any variation forks at this point\n\t\t\t// TODO: Make this configurable... we should keep this if we're\n\t\t\t// remembering chosen paths\n\t\t\tdelete this.path[this.path.m];\n\n\t\t\tif (!localIndex || localIndex === 0) {\n\t\t\t\tif (sequence.parent && !sequence.parent.gameTrees) {\n\t\t\t\t\tsequence = sequence.parent;\n\t\t\t\t\tif (sequence.nodes) {\n\t\t\t\t\t\tnode = sequence.nodes[sequence.nodes.length - 1];\n\t\t\t\t\t\tthis.path.m -= 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnode = null;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Already at the beginning\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnode = localNodes[localIndex - 1];\n\t\t\t\tthis.path.m -= 1;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\t// Go to the last move of the game\n\t\tlast: function () {\n\t\t\tvar totalMoves = this.totalMoves();\n\n\t\t\twhile(this.path.m < totalMoves) {\n\t\t\t\tthis.next();\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\t// Go to the first move of the game\n\t\tfirst: function () {\n\t\t\tthis.reset();\n\t\t\treturn this;\n\t\t},\n\n\t\t/**\n\t\t * Go to a particular move, specified as a\n\t\t * a) number\n\t\t * b) path string\n\t\t * c) path object\n\t\t **/\n\t\tgoTo: function (path) {\n\t\t\tif (typeof path === 'string') {\n\t\t\t\tpath = this.pathTransform(path, 'object');\n\t\t\t} else if (typeof path === 'number') {\n\t\t\t\tpath = { m: path };\n\t\t\t}\n\n\t\t\tthis.reset();\n\n\t\t\tvar n = node;\n\n\t\t\tfor (var i = 0; i < path.m && n; i += 1) {\n\t\t\t\t// Check for a variation in the path for the upcoming move\n\t\t\t\tvar variation = path[i + 1] || 0;\n\t\t\t\tn = this.next(variation);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\tgetGameInfo: function () {\n\t\t\treturn this.game.nodes[0];\n\t\t},\n\n\t\t// Provide the current node\n\t\tnode: function () {\n\t\t\treturn node;\n\t\t},\n\n\t\t// Get the total number of moves in a game\n\t\ttotalMoves: function () {\n\t\t\tvar localSequence = this.game;\n\t\t\tvar moves = 0;\n\t\t\twhile(localSequence) {\n\t\t\t\tmoves += localSequence.nodes.length;\n\n\t\t\t\tif (localSequence.sequences) {\n\t\t\t\t\tlocalSequence = localSequence.sequences[0];\n\t\t\t\t} else {\n\t\t\t\t\tlocalSequence = null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// TODO: Right now we're *assuming* that the root node doesn't have a\n\t\t\t// move in it, which is *recommended* but not required practice.\n\t\t\t// @see http://www.red-bean.com/sgf/sgf4.html\n\t\t\t// \"Note: it's bad style to have move properties in root nodes.\n\t\t\t// (it isn't forbidden though)\"\n\t\t\treturn moves - 1;\n\t\t},\n\n\t\t// Get or set a comment on the current node\n\t\t// @see http://www.red-bean.com/sgf/sgf4.html#text\n\t\tcomment: function (text) {\n\t\t\tif (typeof text === 'undefined') {\n\t\t\t\t// Unescape characters\n\t\t\t\tif (node.C) {\n\t\t\t\t\treturn node.C.replace(/\\\\([\\\\:\\]])/g, '$1');\n\t\t\t\t} else {\n\t\t\t\t\treturn '';\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Escape characters\n\t\t\t\tnode.C = text.replace(/[\\\\:\\]]/g, '\\\\$&');\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Translate alpha coordinates into an array\n\t\t * @param string alphaCoordinates\n\t\t * @return array [x, y]\n\t\t **/\n\t\ttranslateCoordinates: function (alphaCoordinates) {\n\t\t\tvar coordinateLabels = 'abcdefghijklmnopqrst';\n\t\t\tvar intersection = [];\n\n\t\t\tintersection[0] = coordinateLabels.indexOf(alphaCoordinates.substring(0, 1));\n\t\t\tintersection[1] = coordinateLabels.indexOf(alphaCoordinates.substring(1, 2));\n\n\t\t\treturn intersection;\n\t\t},\n\n\t\t/**\n\t\t * Convert path objects to strings and path strings to objects\n\t\t **/\n\t\tpathTransform: function (input, outputType, verbose) {\n\t\t\tvar output;\n\n\t\t\t// If no output type has been specified, try to set it to the\n\t\t\t// opposite of the input\n\t\t\tif (typeof outputType === 'undefined') {\n\t\t\t\toutputType = (typeof input === 'string') ? 'object' : 'string';\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Turn a path object into a string.\n\t\t\t */\n\t\t\tfunction stringify(input) {\n\t\t\t\tif (typeof input === 'string') {\n\t\t\t\t\treturn input;\n\t\t\t\t}\n\n\t\t\t\tif (!input) {\n\t\t\t\t\treturn '';\n\t\t\t\t}\n\n\t\t\t\toutput = input.m;\n\n\t\t\t\tvar variations = [];\n\t\t\t\tfor (var key in input) {\n\t\t\t\t\tif (input.hasOwnProperty(key) && key !== 'm') {\n\t\t\t\t\t\t// Only show variations that are not the primary one, since\n\t\t\t\t\t\t// primary variations are chosen by default\n\t\t\t\t\t\tif (input[key] > 0) {\n\t\t\t\t\t\t\tif (verbose) {\n\t\t\t\t\t\t\t\tvariations.push(', variation ' + input[key] + ' at move ' + key);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tvariations.push('-' + key + ':' + input[key]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\toutput += variations.join('');\n\t\t\t\treturn output;\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Turn a path string into an object.\n\t\t\t */\n\t\t\tfunction parse(input) {\n\t\t\t\tif (typeof input === 'object') {\n\t\t\t\t\tinput = stringify(input);\n\t\t\t\t}\n\n\t\t\t\tif (!input) {\n\t\t\t\t\treturn { m: 0 };\n\t\t\t\t}\n\n\t\t\t\tvar path = input.split('-');\n\t\t\t\toutput = {\n\t\t\t\t\tm: Number(path.shift())\n\t\t\t\t};\n\n\t\t\t\tif (path.length) {\n\t\t\t\t\tpath.forEach(function (variation, i) {\n\t\t\t\t\t\tvariation = variation.split(':');\n\t\t\t\t\t\toutput[Number(variation[0])] = parseInt(variation[1], 10);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\treturn output;\n\t\t\t}\n\n\t\t\tif (outputType === 'string') {\n\t\t\t\toutput = stringify(input);\n\t\t\t} else if (outputType === 'object') {\n\t\t\t\toutput = parse(input);\n\t\t\t} else {\n\t\t\t\toutput = undefined;\n\t\t\t}\n\n\t\t\treturn output;\n\t\t}\n\t};\n\n\treturn new Smartgamer();\n};\n","/* globals module: false, require: false\r\n\r\n*/\r\n\r\n\r\nmodule.exports = (variantSgf, options) => {\r\n  'use strict' \r\n  let transformer = require('./transformer')\r\n\t,  smartgame = require('smartgame')\r\n\t,  smartgamer = require('smartgamer')\r\n\t,  tGo = require('go-variants-engine')()\r\n    return (transformer(options)).transform(\r\n  \r\n    variantSgf\r\n    , tGo\r\n    , smartgame\r\n    , smartgamer\r\n    )\r\n  }","/* globals module: false, require: false\r\n\r\n*/\r\n/**\r\n * Provides a function for transforming SGF for a Go variant to SGF for a standard Go viewer; also provides a function for the inverse transformation.\r\n * @param {object} [options=] Defines various options for the output SGF. May be omitted, in which case the default options (see below) are used.\r\n * @param {boolean} [options.addComments = false] When flagged, comments are added to each node giving the move number and the number of stones captured by Black and White.\r\n * @param {boolean} [options.addMoveNumber = false] When flagged, MN information is added to each node.\r\n * @param {number} [options.moveType = 2] Controls how moves are represented in the transformed SGF. Examples given for black moves, so with option 2 a white move is represented by `W[point]AW[otherPoints]`. Options: \r\n * 0: `AB[points]`;\r\n * 1: `AB[points]B[]` (same as for `moveType===0` but with the pass (B[]);\r\n * 2: `B[point]AB[otherPoints]` where `point` is the coordinates of the move in the main board (a single point), and `otherPoints` is an array of the coordinates of the move in the wraparound area.;\r\n * 3: `B[points]`;\r\n * @param {string} [options.markLastMove = null] Gives the SGF node to be created to mark each move. May be left empty/null/undefined. Or else a value like `\"CR\"`.\r\n * @param {array} [options.boardDimensions = [11, 11]] May be used for rectangular t-Go. Should be ommitted for [n, n] t-Go, where n is specified in the input SGF (@param variantSgf).\r\n * @param {number} [options.coordinatesType = 0] 0: none;\r\n * 1: (;A|1-K|11): Western;\r\n * 2: (;A|1-L|11): Western, no I;\r\n * 3: (;1|1-11|11): Latin/Latin, top to bottom;\r\n * 4: (;1|1-11|): Latin/Chinese, top to bottom;\r\n * @param {number} [options.wraparoundMarkersType = 1] 0: none;\r\n * 1: Full outline, using unicode Box Drawing symbols;\r\n * 2: corners and middles, using unicode Box Drawing symbols;\r\n * 3: just corners, using unicode Box Drawing symbols;\r\n * 4: just middles, using unicode Box Drawing symbols;\r\n * @param {object} [options.projectionSettings=] Further optional settings for how the (toroidal, or other sort of) board is projected to a flat grid.\r\n * @param {number} [options.projectionSettings.wraparound = 4]  Number of lines to add for the wraparound.\r\n * @param {array} [options.projectionSettings.offset = [0,0]]  Translation to apply to all moves.\r\n * @param {boolean} [options.transformToString=true] When set to false, the output is an object (an instance of a Smartgame).\r\n * @public\r\n * @return {object} An object exposing functions for going back and forth between SGF for a standard viewer, and SGF for a game of toroidal Go\r\n *//*todos:\r\nopions.placesToCount Default: undefined. May be: 'last'|[countInfo1, .. countInfo1]. countInfo is a path plus an array with a point for each chain to be considered as dead. {path, deadChains: [...]}\r\noptions.projectionSettings.rotation {integer} Default value: 0. Allowed values: 0 .. 3\r\noptions.projectionSettings.normalizePlace array, or one of: C, TL TR BL BR (centre, top left, top right, bottom left, bottom right)\r\noptions.projectionSettings.normalize {boolean} \r\n\r\n*/\r\nfunction transformer(options\r\n) {\r\n\t'use strict';\r\n\tconst\r\n\t\t_flatten = require('lodash/flatten')\r\n\t\t, _uniqBy = require('lodash/uniqBy')\r\n\t\t, _fi = require('lodash/findIndex')\r\n\t\t, modulo = (x, y) => (x % y + y) % y\r\n\t\t, sourceSgfMessage = 'source sgf for toroidal Go has been adapted by go-variants-transformer so as to be rendered by any standard Go application'\r\n\toptions = {\r\n\t\tboardDimensions: [11, 11]\r\n\t\t, transformToString: true\r\n\t\t, addComments: true\r\n\t\t, coordinatesType: 0\r\n\t\t, wraparoundMarkersType: 1\r\n\t\t, moveType: 2\r\n\t\t, markLastMove: null\r\n\t\t//above are the defaults\r\n\t\t, ...options\r\n\t}\r\n\toptions.projectionSettings =\r\n\t\t{\r\n\t\t\twraparound: 4,\r\n\t\t\toffset: [0, 0],\r\n\t\t\t...options.projectionSettings\r\n\t\t}\r\n\r\n\tif (options.addPasses === undefined)\r\n\t\toptions.addPasses = true;\r\n\r\n\toptions.boardDimensions = options.boardDimensions || [11, 11]\r\n\r\n\tif (options.transformToString === undefined)\r\n\t\toptions.transformToString = true;\r\n\r\n\tif (options.addComments === undefined)\r\n\t\toptions.addComments = true;\r\n\t// options.projectionSettings = \r\n\r\n\tlet wraparound = options.projectionSettings.wraparound\r\n\r\n\tlet $ = {}\r\n\t\t// , _markersForWraparound = null\r\n\t\t, coordinateLabels = function (i) {\r\n\t\t\t// 97..122 and 65..90\r\n\t\t\treturn String.fromCharCode(i < 26 ? i + 97 : i + 39)\r\n\t\t\t//65 - 26 =\r\n\t\t}\r\n\t\t,\r\n\t\ttranslateCoordinate = (c) => {\r\n\t\t\tlet r = c.charCodeAt(0)\r\n\t\t\treturn r >= 97 ? r - 97 : r - 26\r\n\t\t},\r\n\t\t/**\r\n\t\t * Translate alpha coordinates into an array\r\n\t\t * @param string alphaCoordinates\r\n\t\t * @return array [x, y]\r\n\t\t **/\r\n\t\ttranslateCoordinates = (alphaCoordinates) => {\r\n\t\t\treturn [translateCoordinate(alphaCoordinates.substring(0, 1))\r\n\t\t\t\t, translateCoordinate(alphaCoordinates.substring(1, 2))]\r\n\r\n\t\t}\r\n\r\n\r\n\t$.coordinateLabels = coordinateLabels\r\n\t$.translateCoordinates = translateCoordinates\r\n\t/**\r\n\t * @public\r\n\t */\r\n\t$.options = options\r\n\r\n\t$.projectOnLine = function (a, isVertical) {\r\n\t\t/*\r\n\t\tm: boardDimensions[0] : 11\r\n\t\tn: wraparound : 4\r\n\t\tline: 0,...,(m-1)\r\n\t\t=>\r\n\t\t0,...,(n-1), (start line) n, ... , (n + m - 1) end line,  (n+m), ... , (2n + m - 1)\r\n\r\n\t\tcoordinate a  {0 .. m-1} projects to n + a in main area\r\n\t\tall projections are of the form n + a + xm, x   s.t. 0  n + a + xm  2n + m -1\r\n\t\t-xm  n + a\r\n\t\t\tsmallest such x < 0 is ceil(-(n+a)/m)\r\n\t\t xm  n + m - 1 -a\r\n\t\t\tlargest such x is floor((n + m - 1 -a) / m)\r\n\r\n\r\n\t\t*/\r\n\r\n\t\tconst m //= options.boardDimensions[0]\r\n\t\t\t= options.boardDimensions[isVertical ? 1 : 0]\r\n\r\n\t\t\t, r = []\r\n\r\n\t\tfor (let i = Math.ceil(-(wraparound + a) / m); i <= (wraparound + m - 1 - a) / m; i++)\r\n\t\t\tr.push(wraparound + a + i * m)\r\n\r\n\t\tif (options.moveType === 2) {//ensure the last item in the result is the one inside the main board area\r\n\t\t\tr.sort((x, y) => {\r\n\t\t\t\tif (x >= wraparound && x < wraparound + m) return 1\r\n\t\t\t\tif (y >= wraparound && y < wraparound + m) return -1\r\n\t\t\t\treturn 0\r\n\t\t\t})\r\n\t\t}\r\n\t\treturn r\r\n\t}\r\n\r\n\t/**\r\n\t * This is the inverse function to the function projectOnFlat  at least it is when multiple is false.\r\n\t * @param {Array} points The point or array of points projected onto the grid.\r\n\t * @param {Boolean=false} multiple Whether the argument points is the image of a single point (multiple=false) or of multiple points.\r\n\t * @returns {Array} When the flag multiple is flagged, returns an array of points; otherwise returns a single point (i.e. an array of two integers).\r\n\t */\r\n\tfunction inverseProjectOnFlat(points, multiple) {\r\n\t\tif (!Array.isArray(points[0])) points = [points]\r\n\t\tif (!multiple)\r\n\t\t\treturn [modulo(points[0][0] - options.projectionSettings.offset[0] - wraparound, options.boardDimensions[0])\r\n\t\t\t\t, modulo(points[0][1] - options.projectionSettings.offset[1] - wraparound, options.boardDimensions[1])]\r\n\t\treturn _uniqBy(points.map(x => inverseProjectOnFlat([x])), (x) => `${x[0]}_${x[1]}`)\r\n\t}\r\n\t$.inverseProjectOnFlat = inverseProjectOnFlat\r\n\r\n\t/**\r\n\t * Projects a point on the t-Go board to the array of points on the standard grid/board.\r\n\t * @param {Array} p The point in the t-Go board to be projected on to the grid.\r\n\t * @returns {Array}\r\n\t */\r\n\tfunction projectOnFlat(p) {\r\n\t\tconst a = $.projectOnLine(p[0] + options.projectionSettings.offset[0])\r\n\t\t\t, b = $.projectOnLine(p[1] + options.projectionSettings.offset[1], true)\r\n\t\t\t, r = []\r\n\t\tfor (let i = 0; i < a.length; i++)\r\n\t\t\tfor (let j = 0; j < b.length; j++)\r\n\t\t\t\tr.push([a[i], b[j]])\r\n\t\treturn r\r\n\t}\r\n\t$.projectOnFlat = projectOnFlat\r\n\r\n\t$.modX = (x) => modulo(x, options.boardDimensions[0])\r\n\t$.modY = (y) => modulo(y, options.boardDimensions[1])\r\n\r\n\tlet setUpMarkers = () => {\r\n\t\t$.wraparoundAndCoords = []\r\n\r\n\t\t// $.getMarkersForWraparound = function (){\r\n\t\tif (options.projectionSettings.wraparound > 0) {\r\n\t\t\tconst m = options.boardDimensions[0],\r\n\t\t\t\tn = options.boardDimensions[1]\r\n\r\n\t\t\t/*\r\n\t\t\tm: boardDimensions[0] : 11\r\n\t\t\tw: wraparound : 4\r\n\t\t\tline: 0,...,(m-1)\r\n\t\t\t=>\r\n\t\t\t0,...,(w-1), (start line) w, ... , (w + m - 1) end line, (w+m), ... , (2w + m - 1)\r\n\t\t\t*/\r\n\r\n\t\t\tlet board = []\r\n\t\t\tif ([1, 2, 4].indexOf(options.wraparoundMarkersType) > -1) {\r\n\t\t\t\tlet middles = options.wraparoundMarkersType > 1 ?\r\n\t\t\t\t\t[Math.floor((m - 1) / 2) + 1, Math.ceil((m - 1) / 2) + 1,\r\n\t\t\t\t\tMath.floor((n - 1) / 2) + 1, Math.ceil((n - 1) / 2) + 1]\r\n\t\t\t\t\t: [-1, 99, -1, 99]\r\n\t\t\t\tfor (let i = 1; i <= m; i++) {\r\n\t\t\t\t\tif (i < middles[0] || i > middles[1]) {\r\n\t\t\t\t\t\tcontinue\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlet label = ''//U+2500 Box Drawings Light Horizontal\r\n\r\n\t\t\t\t\tboard.push(coordinateLabels(wraparound - 1 + i) + coordinateLabels(wraparound - 1) + \":\" + label)\r\n\t\t\t\t\tboard.push(coordinateLabels(wraparound - 1 + i) + coordinateLabels(wraparound + m) + \":\" + label)\r\n\t\t\t\t}\r\n\t\t\t\tfor (let i = 1; i <= n; i++) {\r\n\t\t\t\t\tif (i < middles[2] || i > middles[3]) {\r\n\t\t\t\t\t\tcontinue\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlet label = ''//unicode too\r\n\t\t\t\t\tboard.push(coordinateLabels(wraparound - 1) + coordinateLabels(wraparound - 1 + i) + \":\" + label)\r\n\t\t\t\t\tboard.push(coordinateLabels(wraparound + n) + coordinateLabels(wraparound - 1 + i) + \":\" + label)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif ([1, 2, 3].indexOf(options.wraparoundMarkersType) > -1) {\r\n\t\t\t\t//     \r\n\t\t\t\tboard.push(coordinateLabels(wraparound - 1) + coordinateLabels(wraparound + n) + \":\")\r\n\t\t\t\tboard.push(coordinateLabels(wraparound + m) + coordinateLabels(wraparound + n) + \":\")\r\n\t\t\t\tboard.push(coordinateLabels(wraparound - 1) + coordinateLabels(wraparound - 1) + \":\")\r\n\t\t\t\tboard.push(coordinateLabels(wraparound + m) + coordinateLabels(wraparound - 1) + \":\")\r\n\t\t\t}\r\n\r\n\t\t\tif (options.coordinatesType > 0 && wraparound > 1) {\r\n\t\t\t\tfor (let i = 1; i < 2 * wraparound + m - 1; i++) {\r\n\r\n\t\t\t\t\tlet coordIndex = $.modX(-options.projectionSettings.offset[0] - wraparound + i)\r\n\r\n\t\t\t\t\tif (options.coordinatesType === 2 && coordIndex >= 8) {\r\n\t\t\t\t\t\t//omit the I - historical coordinates for Go...\r\n\t\t\t\t\t\t//I: 9th letter\r\n\t\t\t\t\t\tcoordIndex++\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlet label =\r\n\t\t\t\t\t\toptions.coordinatesType < 3\r\n\t\t\t\t\t\t\t? coordinateLabels(coordIndex).toUpperCase()\r\n\t\t\t\t\t\t\t: '' + (coordIndex + 1)\r\n\t\t\t\t\tboard.push(coordinateLabels(i) + coordinateLabels(0) + \":\" + label)\r\n\t\t\t\t\tboard.push(coordinateLabels(i) + coordinateLabels(2 * wraparound + n - 1) + \":\" + label)\r\n\t\t\t\t}\r\n\t\t\t\tlet cjkNumbers = ''\r\n\t\t\t\tfor (let i = 1; i < 2 * wraparound + n - 1; i++) {\r\n\t\t\t\t\t/*\r\n\t\t\t\t\t0\t\t-w\r\n\t\t\t\t\t...\r\n\t\t\t\t\tw-1\t-1\r\n\t\t\t\t\tw\t\t0\r\n\t\t\t\t\t...\r\n\t\t\t\t\tw + n -1\r\n\t\t\t\t\t\r\n\t\t\t\t\t*/\r\n\t\t\t\t\tlet coordIndex =\r\n\t\t\t\t\t\toptions.coordinatesType < 3\r\n\t\t\t\t\t\t\t? $.modY(n + options.projectionSettings.offset[1] + wraparound - i - 1)\r\n\t\t\t\t\t\t\t: $.modY(i - wraparound - options.projectionSettings.offset[1])\r\n\t\t\t\t\tlet label = ''\r\n\t\t\t\t\tswitch (options.coordinatesType) {\r\n\t\t\t\t\t\tcase 1:\r\n\t\t\t\t\t\tcase 2:\r\n\t\t\t\t\t\tcase 3:\r\n\t\t\t\t\t\t\tlabel = '' + (coordIndex + 1)\r\n\t\t\t\t\t\t\tbreak\r\n\t\t\t\t\t\tcase 4:\r\n\t\t\t\t\t\t\tlabel = modulo(coordIndex, 10) === 9 ? '' : cjkNumbers[modulo(coordIndex, 10)]\r\n\r\n\t\t\t\t\t\t\tif (coordIndex > 8) {\r\n\t\t\t\t\t\t\t\tlabel = (coordIndex > 18 ? cjkNumbers[Math.floor((coordIndex + 1) / 10) - 1] : '') + '' + label\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tbreak\r\n\t\t\t\t\t}\r\n\t\t\t\t\tboard.push(coordinateLabels(0) + coordinateLabels(i) + \":\" + label)\r\n\t\t\t\t\tboard.push(coordinateLabels(2 * wraparound + m - 1) + coordinateLabels(i) + \":\" + label)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t$.wraparoundAndCoords = board\r\n\t\t}\r\n\t}\r\n\tsetUpMarkers()\r\n\r\n\r\n\t$.coords2String =\r\n\t\t/**\r\n\t\t * converts coordinates to a string\r\n\t\t */\r\n\t\tfunction coords2String(coords) {\r\n\t\t\treturn coordinateLabels(coords[0]) + coordinateLabels(coords[1])\r\n\t\t}\r\n\r\n\tfunction goThroughTree(state) {\r\n\t\tlet { wrappedGame, node, pending, currentPath, tGo } = state\r\n\t\t\t, nbVariations = wrappedGame.variations().length\r\n\t\tif (currentPath.m > 1000) throw new Error('seem to be stuck!');\r\n\t\tstate.hasSiblings = nbVariations > 0\r\n\t\tif (state.hasSiblings) {\r\n\t\t\t// if(currentPath[m] === undefined)\r\n\t\t\t// currentPath[m] = 0\r\n\t\t\t// else\r\n\t\t\t// currentPath[m] += 1\r\n\t\t\t// currentPath.m += 1\r\n\t\t\tfor (let i = nbVariations - 1; i > 0; i--)\r\n\t\t\t//pile up in this order, as it's FILO and we want the last variation, which may contain a mode added by CGoboard to go last\r\n\t\t\t{\r\n\t\t\t\tlet pathForLater = { ...currentPath }//Object.assign({}, currentPath)\r\n\t\t\t\tpathForLater[currentPath.m + 1] = i\r\n\t\t\t\tpathForLater.m += 1\r\n\r\n\t\t\t\tif (tGo !== undefined)\r\n\t\t\t\t\tpending.push({ path: pathForLater, tGoData: tGo.exportData() })\r\n\t\t\t\telse\r\n\t\t\t\t\tpending.push({ path: pathForLater })\r\n\r\n\t\t\t}\r\n\t\t\tstate.node = wrappedGame.next().node()\r\n\t\t\tcurrentPath[currentPath.m + 1] = 0\r\n\t\t\tcurrentPath.m += 1\r\n\t\t\treturn state.node\r\n\t\t}\r\n\r\n\t\tlet nextNode = wrappedGame.next().node()\r\n\t\tif (node === nextNode) {//at a leaf:\r\n\t\t\tif (pending.length === 0) {\r\n\t\t\t\tstate.node = null\r\n\t\t\t\treturn state.node//finished\r\n\t\t\t}\r\n\t\t\tlet fromStack = pending.pop()\r\n\t\t\tstate.hasSiblings = true\r\n\t\t\t// if (fromStack === null) {\r\n\t\t\t// \tnode = null\r\n\t\t\t// \treturn//finished!\r\n\t\t\t// }\r\n\t\t\tif (tGo !== undefined) tGo.loadData(fromStack.tGoData)\r\n\t\t\tstate.node = wrappedGame.goTo(fromStack.path).node()\r\n\t\t\tstate.currentPath = fromStack.path\r\n\t\t\treturn state.node\r\n\t\t}\r\n\t\telse {\r\n\t\t\tcurrentPath.m += 1\r\n\t\t\tstate.node = nextNode\r\n\t\t\treturn state.node\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Apart from a few details, this is an inverse of the transform function.\r\n\t * @param {smartgame|string} wrappedGame\r\n\t * @param {smartgame} smartgame\r\n\t * @public\r\n\t */\r\n\tfunction inverseTransform(\r\n\t\twrappedGame, smartgame) {\r\n\r\n\t\tif (smartgame === undefined) {\r\n\t\t\tsmartgame = require('smartgame')\r\n\t\t}\r\n\r\n\t\tif (typeof wrappedGame === 'string') {\r\n\t\t\tvar smartgamer = require('smartgamer')\r\n\t\t\twrappedGame = smartgamer(smartgame.parse(wrappedGame))\r\n\t\t}\r\n\r\n\t\tlet node = wrappedGame.first().node()\r\n\t\t\t, pending = []\r\n\t\t\t, currentPath = { m: 0 }\r\n\t\t\t, cleanerRegEx = /^[a-zA-Z :0-9\\-(\\r\\n]+GoVariantsTransformer\\)--[\\r\\n]*/\r\n\t\t\t, cleanComments = () => {\r\n\t\t\t\tif (node.C !== undefined) {\r\n\t\t\t\t\tnode.C = node.C.replace(cleanerRegEx, '')\r\n\t\t\t\t}\r\n\t\t\t\tif (node.C === '')\r\n\t\t\t\t\tdelete node.C\r\n\t\t\t}\r\n\t\t\t,\r\n\t\t\t/**\r\n\t\t\t * Function to:\r\n\t\t\t * \t- remove the border (unicode symbols added by the transform to indicate where the wraparound area meets the main grid).\r\n\t\t\t * \t- remove CM (colour map) and CT (colour table) which are nonstandard SGF added by CGoboard for background colour (could be interesting to use this feature later on).\r\n\t\t\t */\r\n\t\t\tcleanLabels = () => {\r\n\r\n\t\t\t\tlet labels = []\r\n\t\t\t\tif (node.LB !== undefined) {\r\n\t\t\t\t\tlabels = node.LB\r\n\t\t\t\t\tif (!Array.isArray(labels))\r\n\t\t\t\t\t\tlabels = [labels]\r\n\t\t\t\t\tlabels = labels.filter(i => !$.wraparoundAndCoords.includes(i))\r\n\t\t\t\t\t/* jshint loopfunc: true */\r\n\t\t\t\t\tlabels =\r\n\t\t\t\t\t\t_uniqBy(\r\n\t\t\t\t\t\t\tlabels\r\n\t\t\t\t\t\t\t\t.map(function (x) { return x.split(':', 2) })//assume the label doesnt contain :\r\n\t\t\t\t\t\t\t\t.map((x) => [$.coords2String($.inverseProjectOnFlat(translateCoordinates(x[0]))), x[1]])\r\n\t\t\t\t\t\t\t, (x) => x[0])\r\n\t\t\t\t\t\t\t.map((x) => `${x[0]}:${x[1]}`)\r\n\r\n\r\n\t\t\t\t\t// labels = []\r\n\t\t\t\t\t// for (let i = 0; i < labels2.length; i++)\r\n\t\t\t\t\t// \tlabels = labels.concat(labels2)\r\n\t\t\t\t}\r\n\r\n\t\t\t\tnode.LB = labels\r\n\t\t\t\tif (node.LB.length === 0)\r\n\t\t\t\t\tdelete node.LB\r\n\r\n\t\t\t\tif (node.CM)\r\n\t\t\t\t\tdelete node.CM\r\n\t\t\t\tif (node.CT)\r\n\t\t\t\t\tdelete node.CT\r\n\t\t\t}\r\n\r\n\t\tcleanLabels()\r\n\t\tnode.SZ = options.boardDimensions[0]\r\n\t\tnode.AP = \"go-variants-transformer\"\r\n\r\n\t\tif (node.SO !== undefined) {\r\n\t\t\tlet cleanSourceRegex = new RegExp(` \\\\(${sourceSgfMessage}\\\\)`)\r\n\t\t\tnode.SO = node.SO.replace(cleanSourceRegex, '')\r\n\t\t\t// if (node.SO === '')\r\n\t\t\t// \tdelete node.SO\r\n\t\t}\r\n\r\n\t\tlet state = {\r\n\t\t\twrappedGame, node, pending, currentPath, siblingMoves: {}//, parentsWithChildToDelete: [] \r\n\t\t}\r\n\r\n\t\tnode = goThroughTree(state)\r\n\t\twhile (node !== null) {\r\n\t\t\tcleanLabels()\r\n\t\t\tcleanComments()\r\n\r\n\t\t\tconst\r\n\t\t\t\tisBlack = node.AB !== undefined || node.B !== undefined\r\n\t\t\t\t, addedStones = isBlack ? node.AB : node.AW\r\n\t\t\t\t, playedStone = isBlack ? node.B : node.W\r\n\t\t\t\t, move = addedStones ? addedStones : playedStone\r\n\t\t\t\t, moveAsArray = Array.isArray(move) ? move : [move]\r\n\t\t\t\t, isAPass = isBlack ? node.B === '' : node.W === ''\r\n\t\t\t\t, moveHasCoords = move !== undefined && move !== ''\r\n\t\t\t\t, coords = !moveHasCoords ? undefined : $.coords2String($.inverseProjectOnFlat(moveAsArray.map(translateCoordinates)))\r\n\r\n\t\t\t//alter the node\r\n\r\n\t\t\t/*\r\n\t\t\tlogic removing a node added by CGoboard, if there already is the same move as AB or AW in a prior variation; assuming \r\n\t\t\tthe variation to be removed is the last of the siblings - which does seem to be the way CGoboard behaves when a click \r\n\t\t\tis made on a point where the next node is AB or AW.  \r\n\t\t\t*/\r\n\t\t\tif (state.hasSiblings) {\r\n\t\t\t\tlet pathForParent = { ...wrappedGame.path } //Object.assign({}, wrappedGame.path)\r\n\t\t\t\tpathForParent.m--\r\n\t\t\t\tdelete pathForParent[pathForParent.m]\r\n\t\t\t\tpathForParent = wrappedGame.pathTransform(pathForParent)\r\n\t\t\t\t// wrappedGame.previous()\r\n\t\t\t\tif (state.siblingMoves[pathForParent] === undefined) {\r\n\t\t\t\t\tstate.siblingMoves[pathForParent] = []\r\n\t\t\t\t}\r\n\t\t\t\tif (addedStones) {\r\n\t\t\t\t\tstate.siblingMoves[pathForParent].push(coords)\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t\tif (playedStone && state.siblingMoves[pathForParent].indexOf(coords) > -1) {\r\n\r\n\t\t\t\t\t\t// state.parentsWithChildToDelete.push(pathForParent)\r\n\t\t\t\t\t\tnode.XX = \"inverseTransformToDelete\"\r\n\t\t\t\t\t}\r\n\t\t\t\t// wrappedGame.goTo(currentPath)\r\n\t\t\t}\r\n\r\n\t\t\tdelete node[isBlack ? 'AB' : 'AW']\r\n\t\t\tdelete node[isBlack ? 'B' : 'W']\r\n\t\t\tdelete node.CR\r\n\t\t\tdelete node.AE\r\n\r\n\t\t\tif (isAPass) {\r\n\t\t\t\tnode[isBlack ? 'B' : 'W'] = ''\r\n\t\t\t}\r\n\r\n\t\t\tif (moveHasCoords) {\r\n\t\t\t\tnode[isBlack ? 'B' : 'W'] = coords\r\n\t\t\t}\r\n\r\n\t\t\t;/*note: this next semicolon is needed! */[// eslint-disable-line no-extra-semi\r\n\t\t\t\t//'CR',todo: add if not marking the move\r\n\t\t\t\t'DD', 'MA', 'SL', 'SQ', 'TR'].forEach(function (sgfProperty) {\r\n\t\t\t\t\t// _.map(['DD','MA','SL','SQ','TR'], function(sgfProperty){\r\n\t\t\t\t\tif (node[sgfProperty] === undefined) return\r\n\t\t\t\t\tlet points = []\r\n\t\t\t\t\tif (Array.isArray(node[sgfProperty])) {\r\n\t\t\t\t\t\tpoints = node[sgfProperty]\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tpoints = [node[sgfProperty]]\r\n\t\t\t\t\t}\r\n\t\t\t\t\tpoints =\r\n\t\t\t\t\t\t$.inverseProjectOnFlat(\r\n\t\t\t\t\t\t\tpoints.map(translateCoordinates), true\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t.map($.coords2String)\r\n\t\t\t\t\tnode[sgfProperty] = points\r\n\t\t\t\t})\r\n\t\t\t// move to next node\r\n\t\t\tnode = goThroughTree(state)\r\n\t\t}\r\n\r\n\t\t// state.parentsWithChildToDelete.forEach((path) => {\r\n\t\t// \t//remove the sgf node\r\n\t\t// \twrappedGame.goTo(path)\r\n\t\t// \tlet sequences = wrappedGame.game.sequences\r\n\t\t// \tlet index = _fi(sequences, (seq) => seq.nodes[0].inverseTransformToDelete)\r\n\t\t// \t\t, tmpI = 0\r\n\t\t// \twhile (index > -1) {\r\n\t\t// \t\tsequences.splice(index, 1)\r\n\t\t// \t\tindex = _fi(sequences, (seq) => seq.nodes[0].inverseTransformToDelete)\r\n\t\t// \t\ttmpI++\r\n\t\t// \t\tif (tmpI > 100) throw new Error('seem to be stuck!');\r\n\t\t// \t}\r\n\r\n\t\t// \t// console.log(path)\r\n\t\t// })\r\n\r\n\t\tlet deleteNodes = (sequence) => {\r\n\t\t\tif (sequence.sequences) {\r\n\r\n\t\t\t\tlet\r\n\t\t\t\t\tsequences = sequence.sequences\r\n\t\t\t\t\t, index = _fi(sequences, (seq) => seq.nodes[0].XX === 'inverseTransformToDelete')\r\n\t\t\t\t\t, tmpI = 0, max = sequences.length\r\n\t\t\t\twhile (index > -1) {\r\n\t\t\t\t\tsequences.splice(index, 1)\r\n\t\t\t\t\tindex = _fi(sequences, (seq) => seq.nodes[0].XX === 'inverseTransformToDelete')\r\n\t\t\t\t\ttmpI++\r\n\t\t\t\t\tif (tmpI > max) throw new Error('seem to be stuck!');\r\n\t\t\t\t}\r\n\t\t\t\tfor (let index2 = 0; index2 < sequences.length; index2++) {\r\n\t\t\t\t\t// deleteNodes(sequences[index2].nodes[sequences[index2].nodes.length - 1]);\r\n\t\t\t\t\tdeleteNodes(sequences[index2]);\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (sequence.nodes)\r\n\t\t\t\tdeleteNodes(sequence.nodes[sequence.nodes.length - 1])\r\n\t\t}\r\n\t\tdeleteNodes(wrappedGame.game)\r\n\r\n\t\tif (options.transformToString)\r\n\t\t\treturn smartgame.generate({ gameTrees: [wrappedGame.game] });\r\n\t\telse return wrappedGame\r\n\r\n\t}\r\n\t$.inverseTransform = inverseTransform\r\n\r\n\t/**\r\n\t * Main function; converts SGF for a Go variant (so far, just toroidal Go or t-Go).\r\n\t * @param {string} tSgf\r\n\t * @param {object} tGo Engine for counting liberties in t-Go. An instance of go-variants-engine.\r\n\t * @param {*} smartgame\r\n\t * @param {*} smartgamer\r\n\t * @returns {string|object} SGF that can be viewed in a standard SGF viewer. (See `options.transformToString` for the data type of the value returned.)\r\n\t * @public\r\n\t */\r\n\tfunction transform(\r\n\t\ttSgf //eg 11x11 sgf from LittleGolem\r\n\t\t, tGo //app implementing t-Go\r\n\t\t, smartgame\r\n\t\t, smartgamer) {\r\n\r\n\t\tif (tGo === undefined) {\r\n\t\t\t//  tGo = require('../dist/node_modules/go-variants-engine/src/engine.min.js')({\r\n\t\t\t//  tGo = require('../../engine/dist/engine.min.js')({\r\n\t\t\ttGo = require('go-variants-engine')({\r\n\t\t\t\t// tGo = require('../node_modules/go-variants-engine/src/engine')({\r\n\t\t\t\t// boardMode:'t',\r\n\t\t\t\tboardDimensions: options.boardDimensions\r\n\t\t\t})\r\n\t\t\t// tGo = require('../node_modules/go-variants-engine')({boardMode:'t', boardDimensions:options.boardDimensions})\r\n\t\t\t// tGo = require('../node_modules/go-variants-engine/src/engine')({boardMode:'t', boardDimensions:options.boardDimensions})\r\n\t\t}\r\n\t\t// else {\r\n\t\t// \ttGo.options.boardDimensions = options.boardDimensions\r\n\t\t// }\r\n\r\n\t\tif (smartgame === undefined) {\r\n\t\t\tsmartgame = require('smartgame')\r\n\t\t}\r\n\t\tif (smartgamer === undefined) {\r\n\t\t\tsmartgamer = require('smartgamer')\r\n\t\t}\r\n\t\t// console.log(tGo)\r\n\t\tlet parsed = smartgame.parse(tSgf)\r\n\t\t\t, wrappedGame = smartgamer(parsed)\r\n\t\t\t, node = wrappedGame.node()\r\n\t\t\t, passes = 0\r\n\t\t\t, pending = []\r\n\t\t\t, currentPath = { m: 0 }\r\n\t\tif (node.SZ !== undefined) {\r\n\t\t\tlet sz = Number(node.SZ)\r\n\t\t\t// sz+= 2*options.projectionSettings.wraparound\r\n\t\t\toptions.boardDimensions = [sz, sz]\r\n\t\t\ttGo.options.boardDimensions = options.boardDimensions\r\n\t\t\tsetUpMarkers()\r\n\t\t}\r\n\t\tif (node.KM !== undefined) {\r\n\t\t\toptions.rules = { komi: parseFloat(node.KM), ...options.rules }\r\n\t\t}\r\n\t\tnode.SZ = \"\" + (options.boardDimensions[0] + 2 * options.projectionSettings.wraparound)//not sure how to make a rectangular goban!\r\n\t\t//offset modulo\r\n\t\toptions.projectionSettings.offset[0] = modulo(options.projectionSettings.offset[0], options.boardDimensions[0])\r\n\t\toptions.projectionSettings.offset[1] = modulo(options.projectionSettings.offset[1], options.boardDimensions[1])\r\n\t\tlet setLabels = () => {\r\n\t\t\t//node.LB = $.wraparoundAndCoords\r\n\t\t\tlet labels = []\r\n\t\t\tif (node.LB !== undefined) {\r\n\t\t\t\tlabels = node.LB\r\n\t\t\t\tif (!Array.isArray(labels))\r\n\t\t\t\t\tlabels = [labels]\r\n\r\n\t\t\t\t/* jshint loopfunc: true */\r\n\t\t\t\tlet labels2 = labels//_.chain(labels)\r\n\t\t\t\t\t.map(function (x) { return x.split(':', 2) })//assume the label doesnt contain :\r\n\t\t\t\t\t.map(function (x) { return [translateCoordinates(x[0]), x[1]] })\r\n\t\t\t\t\t.map(function (x) { return [$.projectOnFlat(x[0]), x[1]] })\r\n\t\t\t\t// .value()\r\n\t\t\t\tlabels = []\r\n\t\t\t\tfor (let i = 0; i < labels2.length; i++)\r\n\t\t\t\t\tlabels = labels.concat(\r\n\t\t\t\t\t\tlabels2[i][0].map(function (x) {\r\n\t\t\t\t\t\t\treturn $.coords2String(x) + \":\" + labels2[i][1]\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t)\r\n\t\t\t}\r\n\r\n\t\t\tnode.LB = $.wraparoundAndCoords.concat(labels)\r\n\t\t\tif (node.LB.length === 0)\r\n\t\t\t\t// delete node['LB']\r\n\t\t\t\tdelete node.LB\r\n\t\t}\r\n\r\n\t\tsetLabels()\r\n\r\n\t\tif (node.SO !== undefined)\r\n\t\t\tnode.SO = wrappedGame.game.nodes[0].SO + ` (${sourceSgfMessage})`\r\n\t\t//else node.SO = sourceSgfMessage//prefer not to add the message when original Sgf has no SO info.\r\n\r\n\t\tnode.AP = \"go-variants-transformer\"\r\n\r\n\r\n\t\tlet state = { wrappedGame, node, pending, currentPath, tGo }\r\n\r\n\t\tfunction comment(isPass, isBlack, score) {\r\n\t\t\tif (!options.addComments && !score)\r\n\t\t\t\treturn\r\n\r\n\t\t\tlet r = !options.addComments ?\r\n\t\t\t\t''\r\n\t\t\t\t: 'move ' + state.currentPath.m + '\\n' + 'White stones captured by Black: ' + tGo.board.captured[1] + '\\nBlack stones captured by White: ' + tGo.board.captured[0]\r\n\t\t\t\t//let r =  'Black captures: ' + tGo.board.captured[1] + '\\r\\nWhite captures: ' + tGo.board.captured[0]\r\n\t\t\t\t+ (!isPass ? '' : '\\n' + (isBlack ? 'Black passes' : 'White passes'))\r\n\t\t\t\t+ (!score ? '' : '\\n' + `result: ${score.displayResult}`)\r\n\r\n\t\t\tr += '\\n--(the content above was generated automatically by GoVariantsTransformer)--'\r\n\t\t\tr += (node.C === undefined ? '' : '\\n' + node.C)\r\n\t\t\tnode.C = r\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tnode = goThroughTree(state)\r\n\t\twhile (node !== null) {\r\n\r\n\r\n\t\t\tlet\r\n\t\t\t\tisBlack = node.B !== undefined\r\n\t\t\t\t, move = isBlack ? node.B : node.W\r\n\t\t\t\t, isAPass = move === \"\" || (options.boardDimensions[0] === options.boardDimensions[1]\r\n\t\t\t\t\t&& options.boardDimensions[0] <= 19\r\n\t\t\t\t\t&& move === \"tt\" //weird SGF[3] way to show a pass move!\r\n\t\t\t\t)\r\n\t\t\t\t, stonesMarkedForScoring = []\r\n\r\n\t\t\tif (move === undefined && !isAPass) {\r\n\t\t\t\tnode = goThroughTree(state)\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\tsetLabels()\r\n\r\n\t\t\tif (isAPass) {\r\n\t\t\t\tdelete node[isBlack ? 'B' : 'W']\r\n\t\t\t\tcomment(isAPass, isBlack)\r\n\t\t\t\tnode[isBlack ? 'AB' : 'AW'] = []\r\n\t\t\t\t// if (passes === 2) {\r\n\t\t\t\t// \t//wrappedGame.game.nodes.splice(i+1)//get rid of nodes afterwards -- may not work with variations! todo\r\n\t\t\t\t// \tbreak;//stop after 3 successive passes for now\r\n\t\t\t\t// }\r\n\t\t\t\tpasses++\r\n\t\t\t\tif (passes >= 1000)\r\n\t\t\t\t\tbreak//just in case!\r\n\t\t\t\tnode = goThroughTree(state)\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tconst coords = translateCoordinates(move)\r\n\t\t\t\tlet playResult = null\r\n\t\t\t\t// run move through tGo and update game accordingly\r\n\t\t\t\ttry {\r\n\t\t\t\t\tplayResult = tGo.play(isBlack ? 'b' : 'w', coords)\r\n\r\n\t\t\t\t} catch (error) {\r\n\t\t\t\t\tif (error.message !== 'point is not empty' /*ignore this - it happens with some sgf from littleGolem. Todo: look into scoring the position here. */)\r\n\t\t\t\t\t\tthrow (error)\r\n\t\t\t\t}\r\n\t\t\t\tconst projectedCoords = $.projectOnFlat(coords)\r\n\t\t\t\tlet toAdd = playResult === null ? [] : projectedCoords.map($.coords2String)\r\n\t\t\t\t\t, toRemove = playResult === null ? [] :\r\n\t\t\t\t\t\t// _.chain(playResult.removed)\r\n\t\t\t\t\t\t// \t.flatten(true)\r\n\t\t\t\t\t\t// \t.map($.projectOnFlat)\r\n\t\t\t\t\t\t// \t.flatten(true)\r\n\t\t\t\t\t\t// \t.map($.coords2String)\r\n\t\t\t\t\t\t// \t.value()\r\n\t\t\t\t\t\t_flatten(\r\n\t\t\t\t\t\t\t_flatten(playResult.removed)\r\n\t\t\t\t\t\t\t\t.map($.projectOnFlat))\r\n\t\t\t\t\t\t\t.map($.coords2String)\r\n\r\n\t\t\t\t//alter the node\r\n\t\t\t\tif (options.moveType === 2) {\r\n\t\t\t\t\tlet moveMarker = `${isBlack ? 'B' : 'W'}`\r\n\t\t\t\t\tnode[moveMarker] = toAdd.pop()\r\n\t\t\t\t\tif (toAdd.length > 0) {\r\n\t\t\t\t\t\tnode['A' + moveMarker] = toAdd\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\tlet moveMarker = `${options.moveType < 3 ? 'A' : ''}${isBlack ? 'B' : 'W'}`\r\n\r\n\t\t\t\t\tnode[moveMarker] = toAdd\r\n\t\t\t\t\tif (options.markLastMove) {\r\n\t\t\t\t\t\tnode[options.markLastMove] = toAdd\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (options.moveType === 1)\r\n\t\t\t\t\tnode[isBlack ? 'B' : 'W'] = ''\r\n\r\n\r\n\t\t\t\tif (toRemove.length > 0)\r\n\t\t\t\t\tnode.AE = toRemove\r\n\r\n\t\t\t\t\t\t/*\r\n\t\t\t\t\t\ttodo: other properties with board coordinates\r\n\t\t\t\t\t\tLeave for now:\r\n\t\t\t\t\t\tAR\r\n\t\t\t\t\t\tLN\r\n\t\t\t\t\t\t*/\r\n\r\n\t\t\t\t\t\t;/*note this semicolon is needed! */\r\n\t\t\t\t[\r\n\t\t\t\t\t//'CR',todo: add if not marking the move\r\n\t\t\t\t\t'DD', 'MA', 'SL', 'SQ', 'TR'].forEach(function (sgfProperty) {\r\n\t\t\t\t\t\t// _.map(['DD','MA','SL','SQ','TR'], function(sgfProperty){\r\n\t\t\t\t\t\tif (node[sgfProperty] === undefined) return\r\n\t\t\t\t\t\tlet points = []\r\n\t\t\t\t\t\tif (Array.isArray(node[sgfProperty])) {\r\n\t\t\t\t\t\t\tpoints = node[sgfProperty]\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tpoints = [node[sgfProperty]]\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (node.SC && sgfProperty === 'MA') {\r\n\t\t\t\t\t\t\tstonesMarkedForScoring = { ...points }\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tpoints =\r\n\t\t\t\t\t\t\t// _.chain(points)\r\n\t\t\t\t\t\t\t// \t.map(translateCoordinates)\r\n\t\t\t\t\t\t\t// \t.map($.projectOnFlat)\r\n\t\t\t\t\t\t\t// \t.flatten(true)\r\n\t\t\t\t\t\t\t// \t.map($.coords2String)\r\n\t\t\t\t\t\t\t// \t.value()\r\n\t\t\t\t\t\t\t_flatten(\r\n\t\t\t\t\t\t\t\tpoints\r\n\t\t\t\t\t\t\t\t\t.map(translateCoordinates)\r\n\t\t\t\t\t\t\t\t\t.map($.projectOnFlat)\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t.map($.coords2String)\r\n\t\t\t\t\t\tnode[sgfProperty] = points\r\n\t\t\t\t\t})\r\n\t\t\t\tif (options.addMoveNumber) \r\n\t\t\t\t\tnode.MN = currentPath.m\r\n\t\t\t\t\t\r\n\t\t\t\t/*\r\n\t\t\t\tUse a custom, new SGF property, SC, in order to see if the current position should be scored, and if so, what to do with the score.\r\n\t\t\t\tIts a bit flag.  \r\n\t\t\t\t1\t update the comments for the node (succint). When flagged, the next option is not available.\r\n\t\t\t\t2\t update the comments for the node (verbose)\r\n\t\t\t\t4\t update the game result (RE) for the root node\r\n\t\t\t\tTypical usage: add SC[6] to the last node, and SC[2] to score a variation.\r\n\t\t\t\t*/\r\n\t\t\t\tlet updatedComment = false\r\n\t\t\t\tif (node.SC) {\r\n\t\t\t\t\tlet score = engine.score(stonesMarkedForScoring)\r\n\t\t\t\t\tif (node.SC & 1 === 1) {\r\n\t\t\t\t\t\tupdatedComment = true\r\n\t\t\t\t\t\tcomment(isAPass, isBlack, score.RE)\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse /*don't want to treat succint and verbose at the same time*/ if (node.SC & 2 === 2) {\r\n\t\t\t\t\t\tupdatedComment = true\r\n\t\t\t\t\t\tcomment(isAPass, isBlack,\r\n\t\t\t\t\t\t\t`Black: ${score.totalWhiteDead\r\n\t\t\t\t\t\t\t+ score.totalWhiteCaptured\r\n\t\t\t\t\t\t\t+ score.totalBlackTerritory} = ${score.totalBlackTerritory} territory + ${score.totalWhiteDead + score.totalWhiteCaptured} prisoners\r\nWhite: ${score.totalBlackDead\r\n\t\t\t\t\t\t\t+ score.totalBlackCaptured\r\n\t\t\t\t\t\t\t+ score.totalWhiteTerritory} = ${score.totalWhiteTerritory} territory + ${score.totalBlackDead + score.totalBlackCaptured} prisoners +${engine.rules.komi} komi`)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (node.SC & 4 === 4) {\r\n\t\t\t\t\t\twrappedGame.game.nodes[0].RE = score.RE\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (!updatedComment)\r\n\t\t\t\t\tcomment(isAPass, isBlack)\r\n\r\n\t\t\t\t// move to next node\r\n\t\t\t\tnode = goThroughTree(state)\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (options.transformToString)\r\n\t\t\treturn smartgame.generate({ gameTrees: [wrappedGame.game] });\r\n\t\telse return wrappedGame\r\n\t}\r\n\t$.transform = transform\r\n\treturn $\r\n\r\n}\r\nmodule.exports = transformer"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0RhdGFWaWV3LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19IYXNoLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19MaXN0Q2FjaGUuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX01hcC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fTWFwQ2FjaGUuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1Byb21pc2UuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1NldC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fU2V0Q2FjaGUuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1N0YWNrLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19TeW1ib2wuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1VpbnQ4QXJyYXkuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1dlYWtNYXAuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FkZE1hcEVudHJ5LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19hZGRTZXRFbnRyeS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlFYWNoLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUZpbHRlci5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlMaWtlS2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlNYXAuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5UHVzaC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlSZWR1Y2UuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5U29tZS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXNzaWduVmFsdWUuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Fzc29jSW5kZXhPZi5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUFzc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUFzc2lnbkluLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQXNzaWduVmFsdWUuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VDbG9uZS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZpbmRJbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldEFsbEtleXMuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXRUYWcuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VIYXNJbi5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzQXJndW1lbnRzLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNFcXVhbC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzRXF1YWxEZWVwLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNNYXRjaC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzTmF0aXZlLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNUeXBlZEFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXRlcmF0ZWUuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VLZXlzLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlS2V5c0luLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWF0Y2hlcy5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZU1hdGNoZXNQcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUHJvcGVydHlEZWVwLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVGltZXMuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VUb1N0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVVuYXJ5LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19jYWNoZUhhcy5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2FzdFBhdGguanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lQXJyYXlCdWZmZXIuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lQnVmZmVyLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZURhdGFWaWV3LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZU1hcC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVSZWdFeHAuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lU2V0LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZVN5bWJvbC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVUeXBlZEFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5QXJyYXkuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlPYmplY3QuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlTeW1ib2xzLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5U3ltYm9sc0luLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3JlSnNEYXRhLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19kZWZpbmVQcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZXF1YWxBcnJheXMuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2VxdWFsQnlUYWcuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2VxdWFsT2JqZWN0cy5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZnJlZUdsb2JhbC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0QWxsS2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0QWxsS2V5c0luLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRNYXBEYXRhLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRNYXRjaERhdGEuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldE5hdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0UHJvdG90eXBlLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRSYXdUYWcuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFN5bWJvbHMuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFN5bWJvbHNJbi5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0VGFnLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRWYWx1ZS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzUGF0aC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaENsZWFyLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoRGVsZXRlLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoR2V0LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoSGFzLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoU2V0LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19pbml0Q2xvbmVBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9faW5pdENsb25lQnlUYWcuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2luaXRDbG9uZU9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNJbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNLZXkuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzS2V5YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNNYXNrZWQuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzUHJvdG90eXBlLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19pc1N0cmljdENvbXBhcmFibGUuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUNsZWFyLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVEZWxldGUuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUdldC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlSGFzLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVTZXQuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlQ2xlYXIuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlRGVsZXRlLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUdldC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVIYXMuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlU2V0LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBUb0FycmF5LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWVtb2l6ZUNhcHBlZC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlQ3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVLZXlzLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVLZXlzSW4uanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25vZGVVdGlsLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19vYmplY3RUb1N0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fb3ZlckFyZy5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fcm9vdC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2V0Q2FjaGVBZGQuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldENhY2hlSGFzLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRUb0FycmF5LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0NsZWFyLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0RlbGV0ZS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tHZXQuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrSGFzLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja1NldC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RyaW5nVG9QYXRoLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL190b0tleS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fdG9Tb3VyY2UuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvY2xvbmUuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvZXEuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvZmluZEluZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL2dldC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9oYXNJbi5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9pZGVudGl0eS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FyZ3VtZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXlMaWtlLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQnVmZmVyLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL2lzRnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNMZW5ndGguanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3QuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3RMaWtlLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL2lzU3ltYm9sLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL2lzVHlwZWRBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL2tleXNJbi5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9tZW1vaXplLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL3Byb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL3N0dWJBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9zdHViRmFsc2UuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvdG9GaW5pdGUuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvdG9JbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL3RvTnVtYmVyLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL3RvU3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9zcmMvZW5naW5lLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlJbmNsdWRlcy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5SW5jbHVkZXNXaXRoLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZsYXR0ZW4uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSW5kZXhPZi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc05hTi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VVbmlxLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlU2V0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZnJlZUdsb2JhbC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzRmxhdHRlbmFibGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19zdHJpY3RJbmRleE9mLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9mbGF0dGVuLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9ub29wLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC91bmlxQnkuanMiLCJub2RlX21vZHVsZXMvc21hcnRnYW1lL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NtYXJ0Z2FtZXIvaW5kZXguanMiLCJzcmMvdHJhbnNmb3JtLmpzIiwic3JjL3RyYW5zZm9ybWVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDek1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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MEIsTUFBTSxFQUFoQztBQUNBLE1BSEQsTUFJSyw0REFBNkQsSUFBSSxLQUFLLEVBQUwsR0FBVSxNQUFNLENBQXBCLEVBQXVCO0FBQ3hGLHdCQUFpQixJQUFqQjtBQUNBLGVBQVEsT0FBUixFQUFpQixPQUFqQixlQUNXLE1BQU0sY0FBTixHQUNSLE1BQU0sa0JBREUsR0FFUixNQUFNLG1CQUhULFlBR2tDLE1BQU0sbUJBSHhDLHNCQUcyRSxNQUFNLGNBQU4sR0FBdUIsTUFBTSxrQkFIeEcsNkJBSUcsTUFBTSxjQUFOLEdBQ0EsTUFBTSxrQkFETixHQUVBLE1BQU0sbUJBTlQsWUFNa0MsTUFBTSxtQkFOeEMsc0JBTTJFLE1BQU0sY0FBTixHQUF1QixNQUFNLGtCQU54RyxxQkFNeUksT0FBTyxLQUFQLENBQWEsSUFOdEo7QUFPQTtBQUNELFNBQUksS0FBSyxFQUFMLEdBQVUsTUFBTSxDQUFwQixFQUF1QjtBQUN0QixrQkFBWSxJQUFaLENBQWlCLEtBQWpCLENBQXVCLENBQXZCLEVBQTBCLEVBQTFCLEdBQStCLE1BQU0sRUFBckM7QUFDQTtBQUNEO0FBQ0QsUUFBSSxDQUFDLGNBQUwsRUFDQyxRQUFRLE9BQVIsRUFBaUIsT0FBakI7O0FBRUQ7QUFDQSxXQUFPLGNBQWMsS0FBZCxDQUFQO0FBQ0E7QUFDRDtBQUNELE1BQUksUUFBUSxpQkFBWixFQUNDLE9BQU8sVUFBVSxRQUFWLENBQW1CLEVBQUUsV0FBVyxDQUFDLFlBQVksSUFBYixDQUFiLEVBQW5CLENBQVAsQ0FERCxLQUVLLE9BQU8sV0FBUDtBQUNMO0FBQ0QsR0FBRSxTQUFGLEdBQWMsU0FBZDtBQUNBLFFBQU8sQ0FBUDtBQUVBO0FBQ0QsT0FBTyxPQUFQLEdBQWlCLFdBQWpCIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgRGF0YVZpZXcgPSBnZXROYXRpdmUocm9vdCwgJ0RhdGFWaWV3Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YVZpZXc7XG4iLCJ2YXIgaGFzaENsZWFyID0gcmVxdWlyZSgnLi9faGFzaENsZWFyJyksXG4gICAgaGFzaERlbGV0ZSA9IHJlcXVpcmUoJy4vX2hhc2hEZWxldGUnKSxcbiAgICBoYXNoR2V0ID0gcmVxdWlyZSgnLi9faGFzaEdldCcpLFxuICAgIGhhc2hIYXMgPSByZXF1aXJlKCcuL19oYXNoSGFzJyksXG4gICAgaGFzaFNldCA9IHJlcXVpcmUoJy4vX2hhc2hTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG5IYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbkhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG5IYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbkhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gSGFzaDtcbiIsInZhciBsaXN0Q2FjaGVDbGVhciA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUNsZWFyJyksXG4gICAgbGlzdENhY2hlRGVsZXRlID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlRGVsZXRlJyksXG4gICAgbGlzdENhY2hlR2V0ID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlR2V0JyksXG4gICAgbGlzdENhY2hlSGFzID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlSGFzJyksXG4gICAgbGlzdENhY2hlU2V0ID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBMaXN0Q2FjaGU7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIE1hcCA9IGdldE5hdGl2ZShyb290LCAnTWFwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwO1xuIiwidmFyIG1hcENhY2hlQ2xlYXIgPSByZXF1aXJlKCcuL19tYXBDYWNoZUNsZWFyJyksXG4gICAgbWFwQ2FjaGVEZWxldGUgPSByZXF1aXJlKCcuL19tYXBDYWNoZURlbGV0ZScpLFxuICAgIG1hcENhY2hlR2V0ID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVHZXQnKSxcbiAgICBtYXBDYWNoZUhhcyA9IHJlcXVpcmUoJy4vX21hcENhY2hlSGFzJyksXG4gICAgbWFwQ2FjaGVTZXQgPSByZXF1aXJlKCcuL19tYXBDYWNoZVNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbk1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbk1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcbk1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbk1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXBDYWNoZTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgUHJvbWlzZSA9IGdldE5hdGl2ZShyb290LCAnUHJvbWlzZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb21pc2U7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFNldCA9IGdldE5hdGl2ZShyb290LCAnU2V0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2V0O1xuIiwidmFyIE1hcENhY2hlID0gcmVxdWlyZSgnLi9fTWFwQ2FjaGUnKSxcbiAgICBzZXRDYWNoZUFkZCA9IHJlcXVpcmUoJy4vX3NldENhY2hlQWRkJyksXG4gICAgc2V0Q2FjaGVIYXMgPSByZXF1aXJlKCcuL19zZXRDYWNoZUhhcycpO1xuXG4vKipcbiAqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNhY2hlIG9iamVjdCB0byBzdG9yZSB1bmlxdWUgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFNldENhY2hlKHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcyA9PSBudWxsID8gMCA6IHZhbHVlcy5sZW5ndGg7XG5cbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU2V0Q2FjaGVgLlxuU2V0Q2FjaGUucHJvdG90eXBlLmFkZCA9IFNldENhY2hlLnByb3RvdHlwZS5wdXNoID0gc2V0Q2FjaGVBZGQ7XG5TZXRDYWNoZS5wcm90b3R5cGUuaGFzID0gc2V0Q2FjaGVIYXM7XG5cbm1vZHVsZS5leHBvcnRzID0gU2V0Q2FjaGU7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgc3RhY2tDbGVhciA9IHJlcXVpcmUoJy4vX3N0YWNrQ2xlYXInKSxcbiAgICBzdGFja0RlbGV0ZSA9IHJlcXVpcmUoJy4vX3N0YWNrRGVsZXRlJyksXG4gICAgc3RhY2tHZXQgPSByZXF1aXJlKCcuL19zdGFja0dldCcpLFxuICAgIHN0YWNrSGFzID0gcmVxdWlyZSgnLi9fc3RhY2tIYXMnKSxcbiAgICBzdGFja1NldCA9IHJlcXVpcmUoJy4vX3N0YWNrU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcblN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcblN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcblN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcblN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxubW9kdWxlLmV4cG9ydHMgPSBTdGFjaztcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW1ib2w7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgVWludDhBcnJheSA9IHJvb3QuVWludDhBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBVaW50OEFycmF5O1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBXZWFrTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdXZWFrTWFwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gV2Vha01hcDtcbiIsIi8qKlxuICogQWRkcyB0aGUga2V5LXZhbHVlIGBwYWlyYCB0byBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHBhaXIgVGhlIGtleS12YWx1ZSBwYWlyIHRvIGFkZC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG1hcGAuXG4gKi9cbmZ1bmN0aW9uIGFkZE1hcEVudHJ5KG1hcCwgcGFpcikge1xuICAvLyBEb24ndCByZXR1cm4gYG1hcC5zZXRgIGJlY2F1c2UgaXQncyBub3QgY2hhaW5hYmxlIGluIElFIDExLlxuICBtYXAuc2V0KHBhaXJbMF0sIHBhaXJbMV0pO1xuICByZXR1cm4gbWFwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFkZE1hcEVudHJ5O1xuIiwiLyoqXG4gKiBBZGRzIGB2YWx1ZWAgdG8gYHNldGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBtb2RpZnkuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhZGQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBzZXRgLlxuICovXG5mdW5jdGlvbiBhZGRTZXRFbnRyeShzZXQsIHZhbHVlKSB7XG4gIC8vIERvbid0IHJldHVybiBgc2V0LmFkZGAgYmVjYXVzZSBpdCdzIG5vdCBjaGFpbmFibGUgaW4gSUUgMTEuXG4gIHNldC5hZGQodmFsdWUpO1xuICByZXR1cm4gc2V0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFkZFNldEVudHJ5O1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZm9yRWFjaGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RWFjaChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkgPT09IGZhbHNlKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5RWFjaDtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZpbHRlcmAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheUZpbHRlcihhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXNJbmRleCA9IDAsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUZpbHRlcjtcbiIsInZhciBiYXNlVGltZXMgPSByZXF1aXJlKCcuL19iYXNlVGltZXMnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlMaWtlS2V5cztcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlNYXA7XG4iLCIvKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlQdXNoO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucmVkdWNlYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0QWNjdW1dIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YCBhc1xuICogIHRoZSBpbml0aWFsIHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBhcnJheVJlZHVjZShhcnJheSwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0pIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICBpZiAoaW5pdEFjY3VtICYmIGxlbmd0aCkge1xuICAgIGFjY3VtdWxhdG9yID0gYXJyYXlbKytpbmRleF07XG4gIH1cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5UmVkdWNlO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc29tZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5U29tZShhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheVNvbWU7XG4iLCJ2YXIgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnblZhbHVlJyksXG4gICAgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gIGlmICghKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGVxKG9ialZhbHVlLCB2YWx1ZSkpIHx8XG4gICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzaWduVmFsdWU7XG4iLCJ2YXIgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzb2NJbmRleE9mO1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gKiBvciBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnbihvYmplY3QsIHNvdXJjZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUFzc2lnbjtcbiIsInZhciBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4va2V5c0luJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ25JbihvYmplY3QsIHNvdXJjZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQXNzaWduSW47XG4iLCJ2YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19kZWZpbmVQcm9wZXJ0eScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBhc3NpZ25WYWx1ZWAgYW5kIGBhc3NpZ25NZXJnZVZhbHVlYCB3aXRob3V0XG4gKiB2YWx1ZSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5ID09ICdfX3Byb3RvX18nICYmIGRlZmluZVByb3BlcnR5KSB7XG4gICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgJ2VudW1lcmFibGUnOiB0cnVlLFxuICAgICAgJ3ZhbHVlJzogdmFsdWUsXG4gICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBc3NpZ25WYWx1ZTtcbiIsInZhciBTdGFjayA9IHJlcXVpcmUoJy4vX1N0YWNrJyksXG4gICAgYXJyYXlFYWNoID0gcmVxdWlyZSgnLi9fYXJyYXlFYWNoJyksXG4gICAgYXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25WYWx1ZScpLFxuICAgIGJhc2VBc3NpZ24gPSByZXF1aXJlKCcuL19iYXNlQXNzaWduJyksXG4gICAgYmFzZUFzc2lnbkluID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnbkluJyksXG4gICAgY2xvbmVCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUJ1ZmZlcicpLFxuICAgIGNvcHlBcnJheSA9IHJlcXVpcmUoJy4vX2NvcHlBcnJheScpLFxuICAgIGNvcHlTeW1ib2xzID0gcmVxdWlyZSgnLi9fY29weVN5bWJvbHMnKSxcbiAgICBjb3B5U3ltYm9sc0luID0gcmVxdWlyZSgnLi9fY29weVN5bWJvbHNJbicpLFxuICAgIGdldEFsbEtleXMgPSByZXF1aXJlKCcuL19nZXRBbGxLZXlzJyksXG4gICAgZ2V0QWxsS2V5c0luID0gcmVxdWlyZSgnLi9fZ2V0QWxsS2V5c0luJyksXG4gICAgZ2V0VGFnID0gcmVxdWlyZSgnLi9fZ2V0VGFnJyksXG4gICAgaW5pdENsb25lQXJyYXkgPSByZXF1aXJlKCcuL19pbml0Q2xvbmVBcnJheScpLFxuICAgIGluaXRDbG9uZUJ5VGFnID0gcmVxdWlyZSgnLi9faW5pdENsb25lQnlUYWcnKSxcbiAgICBpbml0Q2xvbmVPYmplY3QgPSByZXF1aXJlKCcuL19pbml0Q2xvbmVPYmplY3QnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xudmFyIENMT05FX0RFRVBfRkxBRyA9IDEsXG4gICAgQ0xPTkVfRkxBVF9GTEFHID0gMixcbiAgICBDTE9ORV9TWU1CT0xTX0ZMQUcgPSA0O1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIHN1cHBvcnRlZCBieSBgXy5jbG9uZWAuICovXG52YXIgY2xvbmVhYmxlVGFncyA9IHt9O1xuY2xvbmVhYmxlVGFnc1thcmdzVGFnXSA9IGNsb25lYWJsZVRhZ3NbYXJyYXlUYWddID1cbmNsb25lYWJsZVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRhVmlld1RhZ10gPVxuY2xvbmVhYmxlVGFnc1tib29sVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0ZVRhZ10gPVxuY2xvbmVhYmxlVGFnc1tmbG9hdDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZmxvYXQ2NFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbaW50MTZUYWddID1cbmNsb25lYWJsZVRhZ3NbaW50MzJUYWddID0gY2xvbmVhYmxlVGFnc1ttYXBUYWddID1cbmNsb25lYWJsZVRhZ3NbbnVtYmVyVGFnXSA9IGNsb25lYWJsZVRhZ3Nbb2JqZWN0VGFnXSA9XG5jbG9uZWFibGVUYWdzW3JlZ2V4cFRhZ10gPSBjbG9uZWFibGVUYWdzW3NldFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tzdHJpbmdUYWddID0gY2xvbmVhYmxlVGFnc1tzeW1ib2xUYWddID1cbmNsb25lYWJsZVRhZ3NbdWludDhUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50OENsYW1wZWRUYWddID1cbmNsb25lYWJsZVRhZ3NbdWludDE2VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG5jbG9uZWFibGVUYWdzW2Vycm9yVGFnXSA9IGNsb25lYWJsZVRhZ3NbZnVuY1RhZ10gPVxuY2xvbmVhYmxlVGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsb25lYCBhbmQgYF8uY2xvbmVEZWVwYCB3aGljaCB0cmFja3NcbiAqIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gRGVlcCBjbG9uZVxuICogIDIgLSBGbGF0dGVuIGluaGVyaXRlZCBwcm9wZXJ0aWVzXG4gKiAgNCAtIENsb25lIHN5bWJvbHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2tleV0gVGhlIGtleSBvZiBgdmFsdWVgLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBwYXJlbnQgb2JqZWN0IG9mIGB2YWx1ZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIG9iamVjdHMgYW5kIHRoZWlyIGNsb25lIGNvdW50ZXJwYXJ0cy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VDbG9uZSh2YWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCBvYmplY3QsIHN0YWNrKSB7XG4gIHZhciByZXN1bHQsXG4gICAgICBpc0RlZXAgPSBiaXRtYXNrICYgQ0xPTkVfREVFUF9GTEFHLFxuICAgICAgaXNGbGF0ID0gYml0bWFzayAmIENMT05FX0ZMQVRfRkxBRyxcbiAgICAgIGlzRnVsbCA9IGJpdG1hc2sgJiBDTE9ORV9TWU1CT0xTX0ZMQUc7XG5cbiAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICByZXN1bHQgPSBvYmplY3QgPyBjdXN0b21pemVyKHZhbHVlLCBrZXksIG9iamVjdCwgc3RhY2spIDogY3VzdG9taXplcih2YWx1ZSk7XG4gIH1cbiAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKTtcbiAgaWYgKGlzQXJyKSB7XG4gICAgcmVzdWx0ID0gaW5pdENsb25lQXJyYXkodmFsdWUpO1xuICAgIGlmICghaXNEZWVwKSB7XG4gICAgICByZXR1cm4gY29weUFycmF5KHZhbHVlLCByZXN1bHQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKSxcbiAgICAgICAgaXNGdW5jID0gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcblxuICAgIGlmIChpc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjbG9uZUJ1ZmZlcih2YWx1ZSwgaXNEZWVwKTtcbiAgICB9XG4gICAgaWYgKHRhZyA9PSBvYmplY3RUYWcgfHwgdGFnID09IGFyZ3NUYWcgfHwgKGlzRnVuYyAmJiAhb2JqZWN0KSkge1xuICAgICAgcmVzdWx0ID0gKGlzRmxhdCB8fCBpc0Z1bmMpID8ge30gOiBpbml0Q2xvbmVPYmplY3QodmFsdWUpO1xuICAgICAgaWYgKCFpc0RlZXApIHtcbiAgICAgICAgcmV0dXJuIGlzRmxhdFxuICAgICAgICAgID8gY29weVN5bWJvbHNJbih2YWx1ZSwgYmFzZUFzc2lnbkluKHJlc3VsdCwgdmFsdWUpKVxuICAgICAgICAgIDogY29weVN5bWJvbHModmFsdWUsIGJhc2VBc3NpZ24ocmVzdWx0LCB2YWx1ZSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWNsb25lYWJsZVRhZ3NbdGFnXSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0ID8gdmFsdWUgOiB7fTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGluaXRDbG9uZUJ5VGFnKHZhbHVlLCB0YWcsIGJhc2VDbG9uZSwgaXNEZWVwKTtcbiAgICB9XG4gIH1cbiAgLy8gQ2hlY2sgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMgYW5kIHJldHVybiBpdHMgY29ycmVzcG9uZGluZyBjbG9uZS5cbiAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQodmFsdWUpO1xuICBpZiAoc3RhY2tlZCkge1xuICAgIHJldHVybiBzdGFja2VkO1xuICB9XG4gIHN0YWNrLnNldCh2YWx1ZSwgcmVzdWx0KTtcblxuICB2YXIga2V5c0Z1bmMgPSBpc0Z1bGxcbiAgICA/IChpc0ZsYXQgPyBnZXRBbGxLZXlzSW4gOiBnZXRBbGxLZXlzKVxuICAgIDogKGlzRmxhdCA/IGtleXNJbiA6IGtleXMpO1xuXG4gIHZhciBwcm9wcyA9IGlzQXJyID8gdW5kZWZpbmVkIDoga2V5c0Z1bmModmFsdWUpO1xuICBhcnJheUVhY2gocHJvcHMgfHwgdmFsdWUsIGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgIGtleSA9IHN1YlZhbHVlO1xuICAgICAgc3ViVmFsdWUgPSB2YWx1ZVtrZXldO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBwb3B1bGF0ZSBjbG9uZSAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCBiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgdmFsdWUsIHN0YWNrKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VDbG9uZTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xudmFyIGJhc2VDcmVhdGUgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIG9iamVjdCgpIHt9XG4gIHJldHVybiBmdW5jdGlvbihwcm90bykge1xuICAgIGlmICghaXNPYmplY3QocHJvdG8pKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGlmIChvYmplY3RDcmVhdGUpIHtcbiAgICAgIHJldHVybiBvYmplY3RDcmVhdGUocHJvdG8pO1xuICAgIH1cbiAgICBvYmplY3QucHJvdG90eXBlID0gcHJvdG87XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBvYmplY3Q7XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ3JlYXRlO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maW5kSW5kZXhgIGFuZCBgXy5maW5kTGFzdEluZGV4YCB3aXRob3V0XG4gKiBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4LCBmcm9tUmlnaHQpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIGluZGV4ID0gZnJvbUluZGV4ICsgKGZyb21SaWdodCA/IDEgOiAtMSk7XG5cbiAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZpbmRJbmRleDtcbiIsInZhciBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWZhdWx0IHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldChvYmplY3QsIHBhdGgpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gMCxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgIG9iamVjdCA9IG9iamVjdFt0b0tleShwYXRoW2luZGV4KytdKV07XG4gIH1cbiAgcmV0dXJuIChpbmRleCAmJiBpbmRleCA9PSBsZW5ndGgpID8gb2JqZWN0IDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXQ7XG4iLCJ2YXIgYXJyYXlQdXNoID0gcmVxdWlyZSgnLi9fYXJyYXlQdXNoJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRBbGxLZXlzYCBhbmQgYGdldEFsbEtleXNJbmAgd2hpY2ggdXNlc1xuICogYGtleXNGdW5jYCBhbmQgYHN5bWJvbHNGdW5jYCB0byBnZXQgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3ltYm9sc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XG4gIHZhciByZXN1bHQgPSBrZXlzRnVuYyhvYmplY3QpO1xuICByZXR1cm4gaXNBcnJheShvYmplY3QpID8gcmVzdWx0IDogYXJyYXlQdXNoKHJlc3VsdCwgc3ltYm9sc0Z1bmMob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldEFsbEtleXM7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgZ2V0UmF3VGFnID0gcmVxdWlyZSgnLi9fZ2V0UmF3VGFnJyksXG4gICAgb2JqZWN0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19vYmplY3RUb1N0cmluZycpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0VGFnO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNJbmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUhhc0luKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBrZXkgaW4gT2JqZWN0KG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUhhc0luO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICovXG5mdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNBcmd1bWVudHM7XG4iLCJ2YXIgYmFzZUlzRXF1YWxEZWVwID0gcmVxdWlyZSgnLi9fYmFzZUlzRXF1YWxEZWVwJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0VxdWFsYCB3aGljaCBzdXBwb3J0cyBwYXJ0aWFsIGNvbXBhcmlzb25zXG4gKiBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gVW5vcmRlcmVkIGNvbXBhcmlzb25cbiAqICAyIC0gUGFydGlhbCBjb21wYXJpc29uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykge1xuICBpZiAodmFsdWUgPT09IG90aGVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgfHwgb3RoZXIgPT0gbnVsbCB8fCAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzT2JqZWN0TGlrZShvdGhlcikpKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gIH1cbiAgcmV0dXJuIGJhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGJhc2VJc0VxdWFsLCBzdGFjayk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzRXF1YWw7XG4iLCJ2YXIgU3RhY2sgPSByZXF1aXJlKCcuL19TdGFjaycpLFxuICAgIGVxdWFsQXJyYXlzID0gcmVxdWlyZSgnLi9fZXF1YWxBcnJheXMnKSxcbiAgICBlcXVhbEJ5VGFnID0gcmVxdWlyZSgnLi9fZXF1YWxCeVRhZycpLFxuICAgIGVxdWFsT2JqZWN0cyA9IHJlcXVpcmUoJy4vX2VxdWFsT2JqZWN0cycpLFxuICAgIGdldFRhZyA9IHJlcXVpcmUoJy4vX2dldFRhZycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDE7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAqIGRlZXAgY29tcGFyaXNvbnMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsRGVlcChvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBvYmpJc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgIG90aElzQXJyID0gaXNBcnJheShvdGhlciksXG4gICAgICBvYmpUYWcgPSBvYmpJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG9iamVjdCksXG4gICAgICBvdGhUYWcgPSBvdGhJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG90aGVyKTtcblxuICBvYmpUYWcgPSBvYmpUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG9ialRhZztcbiAgb3RoVGFnID0gb3RoVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvdGhUYWc7XG5cbiAgdmFyIG9iaklzT2JqID0gb2JqVGFnID09IG9iamVjdFRhZyxcbiAgICAgIG90aElzT2JqID0gb3RoVGFnID09IG9iamVjdFRhZyxcbiAgICAgIGlzU2FtZVRhZyA9IG9ialRhZyA9PSBvdGhUYWc7XG5cbiAgaWYgKGlzU2FtZVRhZyAmJiBpc0J1ZmZlcihvYmplY3QpKSB7XG4gICAgaWYgKCFpc0J1ZmZlcihvdGhlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgb2JqSXNBcnIgPSB0cnVlO1xuICAgIG9iaklzT2JqID0gZmFsc2U7XG4gIH1cbiAgaWYgKGlzU2FtZVRhZyAmJiAhb2JqSXNPYmopIHtcbiAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgIHJldHVybiAob2JqSXNBcnIgfHwgaXNUeXBlZEFycmF5KG9iamVjdCkpXG4gICAgICA/IGVxdWFsQXJyYXlzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spXG4gICAgICA6IGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgb2JqVGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgfVxuICBpZiAoIShiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcpKSB7XG4gICAgdmFyIG9iaklzV3JhcHBlZCA9IG9iaklzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnX193cmFwcGVkX18nKSxcbiAgICAgICAgb3RoSXNXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwgJ19fd3JhcHBlZF9fJyk7XG5cbiAgICBpZiAob2JqSXNXcmFwcGVkIHx8IG90aElzV3JhcHBlZCkge1xuICAgICAgdmFyIG9ialVud3JhcHBlZCA9IG9iaklzV3JhcHBlZCA/IG9iamVjdC52YWx1ZSgpIDogb2JqZWN0LFxuICAgICAgICAgIG90aFVud3JhcHBlZCA9IG90aElzV3JhcHBlZCA/IG90aGVyLnZhbHVlKCkgOiBvdGhlcjtcblxuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgIHJldHVybiBlcXVhbEZ1bmMob2JqVW53cmFwcGVkLCBvdGhVbndyYXBwZWQsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFpc1NhbWVUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgcmV0dXJuIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNFcXVhbERlZXA7XG4iLCJ2YXIgU3RhY2sgPSByZXF1aXJlKCcuL19TdGFjaycpLFxuICAgIGJhc2VJc0VxdWFsID0gcmVxdWlyZSgnLi9fYmFzZUlzRXF1YWwnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWF0Y2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtBcnJheX0gbWF0Y2hEYXRhIFRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSwgY3VzdG9taXplcikge1xuICB2YXIgaW5kZXggPSBtYXRjaERhdGEubGVuZ3RoLFxuICAgICAgbGVuZ3RoID0gaW5kZXgsXG4gICAgICBub0N1c3RvbWl6ZXIgPSAhY3VzdG9taXplcjtcblxuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gIWxlbmd0aDtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgaWYgKChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSlcbiAgICAgICAgICA/IGRhdGFbMV0gIT09IG9iamVjdFtkYXRhWzBdXVxuICAgICAgICAgIDogIShkYXRhWzBdIGluIG9iamVjdClcbiAgICAgICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgdmFyIGtleSA9IGRhdGFbMF0sXG4gICAgICAgIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIHNyY1ZhbHVlID0gZGF0YVsxXTtcblxuICAgIGlmIChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSkge1xuICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdGFjayA9IG5ldyBTdGFjaztcbiAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKCEocmVzdWx0ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcsIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICAgICAgOiByZXN1bHRcbiAgICAgICAgICApKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTWF0Y2g7XG4iLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzTWFza2VkID0gcmVxdWlyZSgnLi9faXNNYXNrZWQnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICB0b1NvdXJjZSA9IHJlcXVpcmUoJy4vX3RvU291cmNlJyk7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gaXNGdW5jdGlvbih2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTmF0aXZlO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc1R5cGVkQXJyYXk7XG4iLCJ2YXIgYmFzZU1hdGNoZXMgPSByZXF1aXJlKCcuL19iYXNlTWF0Y2hlcycpLFxuICAgIGJhc2VNYXRjaGVzUHJvcGVydHkgPSByZXF1aXJlKCcuL19iYXNlTWF0Y2hlc1Byb3BlcnR5JyksXG4gICAgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5JyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIHByb3BlcnR5ID0gcmVxdWlyZSgnLi9wcm9wZXJ0eScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLml0ZXJhdGVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSBbdmFsdWU9Xy5pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYW4gaXRlcmF0ZWUuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGl0ZXJhdGVlLlxuICovXG5mdW5jdGlvbiBiYXNlSXRlcmF0ZWUodmFsdWUpIHtcbiAgLy8gRG9uJ3Qgc3RvcmUgdGhlIGB0eXBlb2ZgIHJlc3VsdCBpbiBhIHZhcmlhYmxlIHRvIGF2b2lkIGEgSklUIGJ1ZyBpbiBTYWZhcmkgOS5cbiAgLy8gU2VlIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNTYwMzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGlkZW50aXR5O1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSlcbiAgICAgID8gYmFzZU1hdGNoZXNQcm9wZXJ0eSh2YWx1ZVswXSwgdmFsdWVbMV0pXG4gICAgICA6IGJhc2VNYXRjaGVzKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gcHJvcGVydHkodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJdGVyYXRlZTtcbiIsInZhciBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyksXG4gICAgbmF0aXZlS2V5cyA9IHJlcXVpcmUoJy4vX25hdGl2ZUtleXMnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VLZXlzO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKSxcbiAgICBuYXRpdmVLZXlzSW4gPSByZXF1aXJlKCcuL19uYXRpdmVLZXlzSW4nKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzSW5gIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXNJbihvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXNJbihvYmplY3QpO1xuICB9XG4gIHZhciBpc1Byb3RvID0gaXNQcm90b3R5cGUob2JqZWN0KSxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICBpZiAoIShrZXkgPT0gJ2NvbnN0cnVjdG9yJyAmJiAoaXNQcm90byB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlS2V5c0luO1xuIiwidmFyIGJhc2VJc01hdGNoID0gcmVxdWlyZSgnLi9fYmFzZUlzTWF0Y2gnKSxcbiAgICBnZXRNYXRjaERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXRjaERhdGEnKSxcbiAgICBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc2Agd2hpY2ggZG9lc24ndCBjbG9uZSBgc291cmNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzKHNvdXJjZSkge1xuICB2YXIgbWF0Y2hEYXRhID0gZ2V0TWF0Y2hEYXRhKHNvdXJjZSk7XG4gIGlmIChtYXRjaERhdGEubGVuZ3RoID09IDEgJiYgbWF0Y2hEYXRhWzBdWzJdKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKG1hdGNoRGF0YVswXVswXSwgbWF0Y2hEYXRhWzBdWzFdKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PT0gc291cmNlIHx8IGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNYXRjaGVzO1xuIiwidmFyIGJhc2VJc0VxdWFsID0gcmVxdWlyZSgnLi9fYmFzZUlzRXF1YWwnKSxcbiAgICBnZXQgPSByZXF1aXJlKCcuL2dldCcpLFxuICAgIGhhc0luID0gcmVxdWlyZSgnLi9oYXNJbicpLFxuICAgIGlzS2V5ID0gcmVxdWlyZSgnLi9faXNLZXknKSxcbiAgICBpc1N0cmljdENvbXBhcmFibGUgPSByZXF1aXJlKCcuL19pc1N0cmljdENvbXBhcmFibGUnKSxcbiAgICBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlJyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc1Byb3BlcnR5YCB3aGljaCBkb2Vzbid0IGNsb25lIGBzcmNWYWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzUHJvcGVydHkocGF0aCwgc3JjVmFsdWUpIHtcbiAgaWYgKGlzS2V5KHBhdGgpICYmIGlzU3RyaWN0Q29tcGFyYWJsZShzcmNWYWx1ZSkpIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUodG9LZXkocGF0aCksIHNyY1ZhbHVlKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIG9ialZhbHVlID0gZ2V0KG9iamVjdCwgcGF0aCk7XG4gICAgcmV0dXJuIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmIG9ialZhbHVlID09PSBzcmNWYWx1ZSlcbiAgICAgID8gaGFzSW4ob2JqZWN0LCBwYXRoKVxuICAgICAgOiBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1hdGNoZXNQcm9wZXJ0eTtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5KGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVByb3BlcnR5O1xuIiwidmFyIGJhc2VHZXQgPSByZXF1aXJlKCcuL19iYXNlR2V0Jyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUHJvcGVydHlgIHdoaWNoIHN1cHBvcnRzIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5RGVlcChwYXRoKSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQcm9wZXJ0eURlZXA7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUaW1lcztcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBhcnJheU1hcCA9IHJlcXVpcmUoJy4vX2FycmF5TWFwJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUb1N0cmluZztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVW5hcnk7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBhIGBjYWNoZWAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBjYWNoZUhhcyhjYWNoZSwga2V5KSB7XG4gIHJldHVybiBjYWNoZS5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYWNoZUhhcztcbiIsInZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNLZXkgPSByZXF1aXJlKCcuL19pc0tleScpLFxuICAgIHN0cmluZ1RvUGF0aCA9IHJlcXVpcmUoJy4vX3N0cmluZ1RvUGF0aCcpLFxuICAgIHRvU3RyaW5nID0gcmVxdWlyZSgnLi90b1N0cmluZycpO1xuXG4vKipcbiAqIENhc3RzIGB2YWx1ZWAgdG8gYSBwYXRoIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2FzdFBhdGgodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIGlzS2V5KHZhbHVlLCBvYmplY3QpID8gW3ZhbHVlXSA6IHN0cmluZ1RvUGF0aCh0b1N0cmluZyh2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhc3RQYXRoO1xuIiwidmFyIFVpbnQ4QXJyYXkgPSByZXF1aXJlKCcuL19VaW50OEFycmF5Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBhcnJheUJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBhcnJheUJ1ZmZlci5jb25zdHJ1Y3RvcihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgbmV3IFVpbnQ4QXJyYXkocmVzdWx0KS5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZUFycmF5QnVmZmVyO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIGFsbG9jVW5zYWZlID0gQnVmZmVyID8gQnVmZmVyLmFsbG9jVW5zYWZlIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiAgYGJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgVGhlIGJ1ZmZlciB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBjbG9uZUJ1ZmZlcihidWZmZXIsIGlzRGVlcCkge1xuICBpZiAoaXNEZWVwKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5zbGljZSgpO1xuICB9XG4gIHZhciBsZW5ndGggPSBidWZmZXIubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gYWxsb2NVbnNhZmUgPyBhbGxvY1Vuc2FmZShsZW5ndGgpIDogbmV3IGJ1ZmZlci5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gIGJ1ZmZlci5jb3B5KHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVCdWZmZXI7XG4iLCJ2YXIgY2xvbmVBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQXJyYXlCdWZmZXInKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGRhdGFWaWV3YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFWaWV3IFRoZSBkYXRhIHZpZXcgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIGRhdGEgdmlldy5cbiAqL1xuZnVuY3Rpb24gY2xvbmVEYXRhVmlldyhkYXRhVmlldywgaXNEZWVwKSB7XG4gIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKGRhdGFWaWV3LmJ1ZmZlcikgOiBkYXRhVmlldy5idWZmZXI7XG4gIHJldHVybiBuZXcgZGF0YVZpZXcuY29uc3RydWN0b3IoYnVmZmVyLCBkYXRhVmlldy5ieXRlT2Zmc2V0LCBkYXRhVmlldy5ieXRlTGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZURhdGFWaWV3O1xuIiwidmFyIGFkZE1hcEVudHJ5ID0gcmVxdWlyZSgnLi9fYWRkTWFwRW50cnknKSxcbiAgICBhcnJheVJlZHVjZSA9IHJlcXVpcmUoJy4vX2FycmF5UmVkdWNlJyksXG4gICAgbWFwVG9BcnJheSA9IHJlcXVpcmUoJy4vX21hcFRvQXJyYXknKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbnZhciBDTE9ORV9ERUVQX0ZMQUcgPSAxO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNsb25lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2xvbmVGdW5jIFRoZSBmdW5jdGlvbiB0byBjbG9uZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIG1hcC5cbiAqL1xuZnVuY3Rpb24gY2xvbmVNYXAobWFwLCBpc0RlZXAsIGNsb25lRnVuYykge1xuICB2YXIgYXJyYXkgPSBpc0RlZXAgPyBjbG9uZUZ1bmMobWFwVG9BcnJheShtYXApLCBDTE9ORV9ERUVQX0ZMQUcpIDogbWFwVG9BcnJheShtYXApO1xuICByZXR1cm4gYXJyYXlSZWR1Y2UoYXJyYXksIGFkZE1hcEVudHJ5LCBuZXcgbWFwLmNvbnN0cnVjdG9yKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZU1hcDtcbiIsIi8qKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgIGZsYWdzIGZyb20gdGhlaXIgY29lcmNlZCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlRmxhZ3MgPSAvXFx3KiQvO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgcmVnZXhwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHJlZ2V4cCBUaGUgcmVnZXhwIHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHJlZ2V4cC5cbiAqL1xuZnVuY3Rpb24gY2xvbmVSZWdFeHAocmVnZXhwKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgcmVnZXhwLmNvbnN0cnVjdG9yKHJlZ2V4cC5zb3VyY2UsIHJlRmxhZ3MuZXhlYyhyZWdleHApKTtcbiAgcmVzdWx0Lmxhc3RJbmRleCA9IHJlZ2V4cC5sYXN0SW5kZXg7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVSZWdFeHA7XG4iLCJ2YXIgYWRkU2V0RW50cnkgPSByZXF1aXJlKCcuL19hZGRTZXRFbnRyeScpLFxuICAgIGFycmF5UmVkdWNlID0gcmVxdWlyZSgnLi9fYXJyYXlSZWR1Y2UnKSxcbiAgICBzZXRUb0FycmF5ID0gcmVxdWlyZSgnLi9fc2V0VG9BcnJheScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xudmFyIENMT05FX0RFRVBfRkxBRyA9IDE7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBzZXRgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjbG9uZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNsb25lIHZhbHVlcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgc2V0LlxuICovXG5mdW5jdGlvbiBjbG9uZVNldChzZXQsIGlzRGVlcCwgY2xvbmVGdW5jKSB7XG4gIHZhciBhcnJheSA9IGlzRGVlcCA/IGNsb25lRnVuYyhzZXRUb0FycmF5KHNldCksIENMT05FX0RFRVBfRkxBRykgOiBzZXRUb0FycmF5KHNldCk7XG4gIHJldHVybiBhcnJheVJlZHVjZShhcnJheSwgYWRkU2V0RW50cnksIG5ldyBzZXQuY29uc3RydWN0b3IpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lU2V0O1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGBzeW1ib2xgIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHN5bWJvbCBUaGUgc3ltYm9sIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBzeW1ib2wgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBjbG9uZVN5bWJvbChzeW1ib2wpIHtcbiAgcmV0dXJuIHN5bWJvbFZhbHVlT2YgPyBPYmplY3Qoc3ltYm9sVmFsdWVPZi5jYWxsKHN5bWJvbCkpIDoge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVTeW1ib2w7XG4iLCJ2YXIgY2xvbmVBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQXJyYXlCdWZmZXInKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHR5cGVkQXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gdHlwZWRBcnJheSBUaGUgdHlwZWQgYXJyYXkgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHR5cGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBjbG9uZVR5cGVkQXJyYXkodHlwZWRBcnJheSwgaXNEZWVwKSB7XG4gIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKHR5cGVkQXJyYXkuYnVmZmVyKSA6IHR5cGVkQXJyYXkuYnVmZmVyO1xuICByZXR1cm4gbmV3IHR5cGVkQXJyYXkuY29uc3RydWN0b3IoYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkubGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVR5cGVkQXJyYXk7XG4iLCIvKipcbiAqIENvcGllcyB0aGUgdmFsdWVzIG9mIGBzb3VyY2VgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheT1bXV0gVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIHRvLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlBcnJheShzb3VyY2UsIGFycmF5KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcblxuICBhcnJheSB8fCAoYXJyYXkgPSBBcnJheShsZW5ndGgpKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtpbmRleF0gPSBzb3VyY2VbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5QXJyYXk7XG4iLCJ2YXIgYXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25WYWx1ZScpLFxuICAgIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpO1xuXG4vKipcbiAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMgdG8gY29weS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvcGllZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSwgcHJvcHMsIG9iamVjdCwgY3VzdG9taXplcikge1xuICB2YXIgaXNOZXcgPSAhb2JqZWN0O1xuICBvYmplY3QgfHwgKG9iamVjdCA9IHt9KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG5cbiAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICA/IGN1c3RvbWl6ZXIob2JqZWN0W2tleV0sIHNvdXJjZVtrZXldLCBrZXksIG9iamVjdCwgc291cmNlKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbmV3VmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gICAgaWYgKGlzTmV3KSB7XG4gICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5T2JqZWN0O1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAgZ2V0U3ltYm9scyA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHMnKTtcblxuLyoqXG4gKiBDb3BpZXMgb3duIHN5bWJvbHMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgZnJvbS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlTeW1ib2xzKHNvdXJjZSwgb2JqZWN0KSB7XG4gIHJldHVybiBjb3B5T2JqZWN0KHNvdXJjZSwgZ2V0U3ltYm9scyhzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlTeW1ib2xzO1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAgZ2V0U3ltYm9sc0luID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9sc0luJyk7XG5cbi8qKlxuICogQ29waWVzIG93biBhbmQgaW5oZXJpdGVkIHN5bWJvbHMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgZnJvbS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlTeW1ib2xzSW4oc291cmNlLCBvYmplY3QpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzSW4oc291cmNlKSwgb2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5U3ltYm9sc0luO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbm1vZHVsZS5leHBvcnRzID0gY29yZUpzRGF0YTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKTtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHZhciBmdW5jID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2RlZmluZVByb3BlcnR5Jyk7XG4gICAgZnVuYyh7fSwgJycsIHt9KTtcbiAgICByZXR1cm4gZnVuYztcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmaW5lUHJvcGVydHk7XG4iLCJ2YXIgU2V0Q2FjaGUgPSByZXF1aXJlKCcuL19TZXRDYWNoZScpLFxuICAgIGFycmF5U29tZSA9IHJlcXVpcmUoJy4vX2FycmF5U29tZScpLFxuICAgIGNhY2hlSGFzID0gcmVxdWlyZSgnLi9fY2FjaGVIYXMnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYGFycmF5YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cbiAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1BhcnRpYWwgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KGFycmF5KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gdHJ1ZSxcbiAgICAgIHNlZW4gPSAoYml0bWFzayAmIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpID8gbmV3IFNldENhY2hlIDogdW5kZWZpbmVkO1xuXG4gIHN0YWNrLnNldChhcnJheSwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIGFycmF5KTtcblxuICAvLyBJZ25vcmUgbm9uLWluZGV4IHByb3BlcnRpZXMuXG4gIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2luZGV4XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBhcnJWYWx1ZSwgaW5kZXgsIG90aGVyLCBhcnJheSwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihhcnJWYWx1ZSwgb3RoVmFsdWUsIGluZGV4LCBhcnJheSwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgaWYgKGNvbXBhcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChjb21wYXJlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKHNlZW4pIHtcbiAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSwgb3RoSW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghY2FjaGVIYXMoc2Vlbiwgb3RoSW5kZXgpICYmXG4gICAgICAgICAgICAgICAgKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzZWVuLnB1c2gob3RoSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEoXG4gICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG4gICAgICAgICAgICBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKGFycmF5KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbEFycmF5cztcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBVaW50OEFycmF5ID0gcmVxdWlyZSgnLi9fVWludDhBcnJheScpLFxuICAgIGVxID0gcmVxdWlyZSgnLi9lcScpLFxuICAgIGVxdWFsQXJyYXlzID0gcmVxdWlyZSgnLi9fZXF1YWxBcnJheXMnKSxcbiAgICBtYXBUb0FycmF5ID0gcmVxdWlyZSgnLi9fbWFwVG9BcnJheScpLFxuICAgIHNldFRvQXJyYXkgPSByZXF1aXJlKCcuL19zZXRUb0FycmF5Jyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgIChvYmplY3QuYnl0ZU9mZnNldCAhPSBvdGhlci5ieXRlT2Zmc2V0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XG5cbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgICFlcXVhbEZ1bmMobmV3IFVpbnQ4QXJyYXkob2JqZWN0KSwgbmV3IFVpbnQ4QXJyYXkob3RoZXIpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAvLyBDb2VyY2UgYm9vbGVhbnMgdG8gYDFgIG9yIGAwYCBhbmQgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzLlxuICAgICAgLy8gSW52YWxpZCBkYXRlcyBhcmUgY29lcmNlZCB0byBgTmFOYC5cbiAgICAgIHJldHVybiBlcSgrb2JqZWN0LCArb3RoZXIpO1xuXG4gICAgY2FzZSBlcnJvclRhZzpcbiAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIC8vIENvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgYW5kIHRyZWF0IHN0cmluZ3MsIHByaW1pdGl2ZXMgYW5kIG9iamVjdHMsXG4gICAgICAvLyBhcyBlcXVhbC4gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG4gICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG5cbiAgICBjYXNlIG1hcFRhZzpcbiAgICAgIHZhciBjb252ZXJ0ID0gbWFwVG9BcnJheTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRztcbiAgICAgIGNvbnZlcnQgfHwgKGNvbnZlcnQgPSBzZXRUb0FycmF5KTtcblxuICAgICAgaWYgKG9iamVjdC5zaXplICE9IG90aGVyLnNpemUgJiYgIWlzUGFydGlhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICBiaXRtYXNrIHw9IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUc7XG5cbiAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgdmFyIHJlc3VsdCA9IGVxdWFsQXJyYXlzKGNvbnZlcnQob2JqZWN0KSwgY29udmVydChvdGhlciksIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICBpZiAoc3ltYm9sVmFsdWVPZikge1xuICAgICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZi5jYWxsKG9iamVjdCkgPT0gc3ltYm9sVmFsdWVPZi5jYWxsKG90aGVyKTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWxCeVRhZztcbiIsInZhciBnZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fZ2V0QWxsS2V5cycpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDE7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBvYmpQcm9wcyA9IGdldEFsbEtleXMob2JqZWN0KSxcbiAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcbiAgICAgIG90aFByb3BzID0gZ2V0QWxsS2V5cyhvdGhlciksXG4gICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzUGFydGlhbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICBpZiAoIShpc1BhcnRpYWwgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XG5cbiAgdmFyIHNraXBDdG9yID0gaXNQYXJ0aWFsO1xuICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlLCBrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gKG9ialZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpXG4gICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG4gIH1cbiAgaWYgKHJlc3VsdCAmJiAhc2tpcEN0b3IpIHtcbiAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbE9iamVjdHM7XG4iLCIvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZyZWVHbG9iYWw7XG4iLCJ2YXIgYmFzZUdldEFsbEtleXMgPSByZXF1aXJlKCcuL19iYXNlR2V0QWxsS2V5cycpLFxuICAgIGdldFN5bWJvbHMgPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXMob2JqZWN0KSB7XG4gIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXMsIGdldFN5bWJvbHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFsbEtleXM7XG4iLCJ2YXIgYmFzZUdldEFsbEtleXMgPSByZXF1aXJlKCcuL19iYXNlR2V0QWxsS2V5cycpLFxuICAgIGdldFN5bWJvbHNJbiA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHNJbicpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4va2V5c0luJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsS2V5c0luKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzSW4sIGdldFN5bWJvbHNJbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QWxsS2V5c0luO1xuIiwidmFyIGlzS2V5YWJsZSA9IHJlcXVpcmUoJy4vX2lzS2V5YWJsZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWFwRGF0YTtcbiIsInZhciBpc1N0cmljdENvbXBhcmFibGUgPSByZXF1aXJlKCcuL19pc1N0cmljdENvbXBhcmFibGUnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3Mgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbWF0Y2ggZGF0YSBvZiBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gZ2V0TWF0Y2hEYXRhKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0ga2V5cyhvYmplY3QpLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICB2YXIga2V5ID0gcmVzdWx0W2xlbmd0aF0sXG4gICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICByZXN1bHRbbGVuZ3RoXSA9IFtrZXksIHZhbHVlLCBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE1hdGNoRGF0YTtcbiIsInZhciBiYXNlSXNOYXRpdmUgPSByZXF1aXJlKCcuL19iYXNlSXNOYXRpdmUnKSxcbiAgICBnZXRWYWx1ZSA9IHJlcXVpcmUoJy4vX2dldFZhbHVlJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TmF0aXZlO1xuIiwidmFyIG92ZXJBcmcgPSByZXF1aXJlKCcuL19vdmVyQXJnJyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFByb3RvdHlwZTtcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFJhd1RhZztcbiIsInZhciBhcnJheUZpbHRlciA9IHJlcXVpcmUoJy4vX2FycmF5RmlsdGVyJyksXG4gICAgc3R1YkFycmF5ID0gcmVxdWlyZSgnLi9zdHViQXJyYXknKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHMgPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHJldHVybiBhcnJheUZpbHRlcihuYXRpdmVHZXRTeW1ib2xzKG9iamVjdCksIGZ1bmN0aW9uKHN5bWJvbCkge1xuICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgc3ltYm9sKTtcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFN5bWJvbHM7XG4iLCJ2YXIgYXJyYXlQdXNoID0gcmVxdWlyZSgnLi9fYXJyYXlQdXNoJyksXG4gICAgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgZ2V0U3ltYm9scyA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHMnKSxcbiAgICBzdHViQXJyYXkgPSByZXF1aXJlKCcuL3N0dWJBcnJheScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzSW4gPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHdoaWxlIChvYmplY3QpIHtcbiAgICBhcnJheVB1c2gocmVzdWx0LCBnZXRTeW1ib2xzKG9iamVjdCkpO1xuICAgIG9iamVjdCA9IGdldFByb3RvdHlwZShvYmplY3QpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFN5bWJvbHNJbjtcbiIsInZhciBEYXRhVmlldyA9IHJlcXVpcmUoJy4vX0RhdGFWaWV3JyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyksXG4gICAgUHJvbWlzZSA9IHJlcXVpcmUoJy4vX1Byb21pc2UnKSxcbiAgICBTZXQgPSByZXF1aXJlKCcuL19TZXQnKSxcbiAgICBXZWFrTWFwID0gcmVxdWlyZSgnLi9fV2Vha01hcCcpLFxuICAgIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgdG9Tb3VyY2UgPSByZXF1aXJlKCcuL190b1NvdXJjZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcHJvbWlzZVRhZyA9ICdbb2JqZWN0IFByb21pc2VdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWFwcywgc2V0cywgYW5kIHdlYWttYXBzLiAqL1xudmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcbiAgICBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoTWFwKSxcbiAgICBwcm9taXNlQ3RvclN0cmluZyA9IHRvU291cmNlKFByb21pc2UpLFxuICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQpLFxuICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcCk7XG5cbi8qKlxuICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbnZhciBnZXRUYWcgPSBiYXNlR2V0VGFnO1xuXG4vLyBGYWxsYmFjayBmb3IgZGF0YSB2aWV3cywgbWFwcywgc2V0cywgYW5kIHdlYWsgbWFwcyBpbiBJRSAxMSBhbmQgcHJvbWlzZXMgaW4gTm9kZS5qcyA8IDYuXG5pZiAoKERhdGFWaWV3ICYmIGdldFRhZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpKSkgIT0gZGF0YVZpZXdUYWcpIHx8XG4gICAgKE1hcCAmJiBnZXRUYWcobmV3IE1hcCkgIT0gbWFwVGFnKSB8fFxuICAgIChQcm9taXNlICYmIGdldFRhZyhQcm9taXNlLnJlc29sdmUoKSkgIT0gcHJvbWlzZVRhZykgfHxcbiAgICAoU2V0ICYmIGdldFRhZyhuZXcgU2V0KSAhPSBzZXRUYWcpIHx8XG4gICAgKFdlYWtNYXAgJiYgZ2V0VGFnKG5ldyBXZWFrTWFwKSAhPSB3ZWFrTWFwVGFnKSkge1xuICBnZXRUYWcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBiYXNlR2V0VGFnKHZhbHVlKSxcbiAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWcgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgY3RvclN0cmluZyA9IEN0b3IgPyB0b1NvdXJjZShDdG9yKSA6ICcnO1xuXG4gICAgaWYgKGN0b3JTdHJpbmcpIHtcbiAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuICAgICAgICBjYXNlIGRhdGFWaWV3Q3RvclN0cmluZzogcmV0dXJuIGRhdGFWaWV3VGFnO1xuICAgICAgICBjYXNlIG1hcEN0b3JTdHJpbmc6IHJldHVybiBtYXBUYWc7XG4gICAgICAgIGNhc2UgcHJvbWlzZUN0b3JTdHJpbmc6IHJldHVybiBwcm9taXNlVGFnO1xuICAgICAgICBjYXNlIHNldEN0b3JTdHJpbmc6IHJldHVybiBzZXRUYWc7XG4gICAgICAgIGNhc2Ugd2Vha01hcEN0b3JTdHJpbmc6IHJldHVybiB3ZWFrTWFwVGFnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFRhZztcbiIsIi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFZhbHVlO1xuIiwidmFyIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBleGlzdHMgb24gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2sgcHJvcGVydGllcy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBmYWxzZTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XG4gICAgaWYgKCEocmVzdWx0ID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gIH1cbiAgaWYgKHJlc3VsdCB8fCArK2luZGV4ICE9IGxlbmd0aCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgbGVuZ3RoID0gb2JqZWN0ID09IG51bGwgPyAwIDogb2JqZWN0Lmxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiYgaXNJbmRleChrZXksIGxlbmd0aCkgJiZcbiAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc1BhdGg7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaERlbGV0ZTtcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hHZXQ7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoSGFzO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoU2V0O1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBhcnJheSBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNsb25lLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lQXJyYXkoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGFycmF5LmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgLy8gQWRkIHByb3BlcnRpZXMgYXNzaWduZWQgYnkgYFJlZ0V4cCNleGVjYC5cbiAgaWYgKGxlbmd0aCAmJiB0eXBlb2YgYXJyYXlbMF0gPT0gJ3N0cmluZycgJiYgaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgJ2luZGV4JykpIHtcbiAgICByZXN1bHQuaW5kZXggPSBhcnJheS5pbmRleDtcbiAgICByZXN1bHQuaW5wdXQgPSBhcnJheS5pbnB1dDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZUFycmF5O1xuIiwidmFyIGNsb25lQXJyYXlCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUFycmF5QnVmZmVyJyksXG4gICAgY2xvbmVEYXRhVmlldyA9IHJlcXVpcmUoJy4vX2Nsb25lRGF0YVZpZXcnKSxcbiAgICBjbG9uZU1hcCA9IHJlcXVpcmUoJy4vX2Nsb25lTWFwJyksXG4gICAgY2xvbmVSZWdFeHAgPSByZXF1aXJlKCcuL19jbG9uZVJlZ0V4cCcpLFxuICAgIGNsb25lU2V0ID0gcmVxdWlyZSgnLi9fY2xvbmVTZXQnKSxcbiAgICBjbG9uZVN5bWJvbCA9IHJlcXVpcmUoJy4vX2Nsb25lU3ltYm9sJyksXG4gICAgY2xvbmVUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fY2xvbmVUeXBlZEFycmF5Jyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZSBiYXNlZCBvbiBpdHMgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNsb25pbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNsb25lRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2xvbmUgdmFsdWVzLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVCeVRhZyhvYmplY3QsIHRhZywgY2xvbmVGdW5jLCBpc0RlZXApIHtcbiAgdmFyIEN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgIHJldHVybiBjbG9uZUFycmF5QnVmZmVyKG9iamVjdCk7XG5cbiAgICBjYXNlIGJvb2xUYWc6XG4gICAgY2FzZSBkYXRlVGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yKCtvYmplY3QpO1xuXG4gICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgIHJldHVybiBjbG9uZURhdGFWaWV3KG9iamVjdCwgaXNEZWVwKTtcblxuICAgIGNhc2UgZmxvYXQzMlRhZzogY2FzZSBmbG9hdDY0VGFnOlxuICAgIGNhc2UgaW50OFRhZzogY2FzZSBpbnQxNlRhZzogY2FzZSBpbnQzMlRhZzpcbiAgICBjYXNlIHVpbnQ4VGFnOiBjYXNlIHVpbnQ4Q2xhbXBlZFRhZzogY2FzZSB1aW50MTZUYWc6IGNhc2UgdWludDMyVGFnOlxuICAgICAgcmV0dXJuIGNsb25lVHlwZWRBcnJheShvYmplY3QsIGlzRGVlcCk7XG5cbiAgICBjYXNlIG1hcFRhZzpcbiAgICAgIHJldHVybiBjbG9uZU1hcChvYmplY3QsIGlzRGVlcCwgY2xvbmVGdW5jKTtcblxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yKG9iamVjdCk7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgIHJldHVybiBjbG9uZVJlZ0V4cChvYmplY3QpO1xuXG4gICAgY2FzZSBzZXRUYWc6XG4gICAgICByZXR1cm4gY2xvbmVTZXQob2JqZWN0LCBpc0RlZXAsIGNsb25lRnVuYyk7XG5cbiAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgIHJldHVybiBjbG9uZVN5bWJvbChvYmplY3QpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdENsb25lQnlUYWc7XG4iLCJ2YXIgYmFzZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX2Jhc2VDcmVhdGUnKSxcbiAgICBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyk7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lT2JqZWN0KG9iamVjdCkge1xuICByZXR1cm4gKHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNQcm90b3R5cGUob2JqZWN0KSlcbiAgICA/IGJhc2VDcmVhdGUoZ2V0UHJvdG90eXBlKG9iamVjdCkpXG4gICAgOiB7fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbml0Q2xvbmVPYmplY3Q7XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8IHJlSXNVaW50LnRlc3QodmFsdWUpKSAmJlxuICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0luZGV4O1xuIiwidmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlSXNEZWVwUHJvcCA9IC9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcXFxdfFxcXFwuKSo/XFwxKVxcXS8sXG4gICAgcmVJc1BsYWluUHJvcCA9IC9eXFx3KiQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSBhbmQgbm90IGEgcHJvcGVydHkgcGF0aC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5KHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8XG4gICAgICB2YWx1ZSA9PSBudWxsIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiByZUlzUGxhaW5Qcm9wLnRlc3QodmFsdWUpIHx8ICFyZUlzRGVlcFByb3AudGVzdCh2YWx1ZSkgfHxcbiAgICAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0KG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzS2V5O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzS2V5YWJsZTtcbiIsInZhciBjb3JlSnNEYXRhID0gcmVxdWlyZSgnLi9fY29yZUpzRGF0YScpO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbn0oKSk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTWFza2VkO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUHJvdG90eXBlO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaWYgc3VpdGFibGUgZm9yIHN0cmljdFxuICogIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlICYmICFpc09iamVjdCh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTdHJpY3RDb21wYXJhYmxlO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUNsZWFyO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2U7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICAtLXRoaXMuc2l6ZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlRGVsZXRlO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUdldDtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlSGFzO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgICsrdGhpcy5zaXplO1xuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlU2V0O1xuIiwidmFyIEhhc2ggPSByZXF1aXJlKCcuL19IYXNoJyksXG4gICAgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUNsZWFyO1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlRGVsZXRlO1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUdldDtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlSGFzO1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSxcbiAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZVNldDtcbiIsIi8qKlxuICogQ29udmVydHMgYG1hcGAgdG8gaXRzIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAqL1xuZnVuY3Rpb24gbWFwVG9BcnJheShtYXApIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShtYXAuc2l6ZSk7XG5cbiAgbWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwVG9BcnJheTtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBtYXRjaGVzUHJvcGVydHlgIGZvciBzb3VyY2UgdmFsdWVzIHN1aXRhYmxlXG4gKiBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUoa2V5LCBzcmNWYWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Rba2V5XSA9PT0gc3JjVmFsdWUgJiZcbiAgICAgIChzcmNWYWx1ZSAhPT0gdW5kZWZpbmVkIHx8IChrZXkgaW4gT2JqZWN0KG9iamVjdCkpKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZTtcbiIsInZhciBtZW1vaXplID0gcmVxdWlyZSgnLi9tZW1vaXplJyk7XG5cbi8qKiBVc2VkIGFzIHRoZSBtYXhpbXVtIG1lbW9pemUgY2FjaGUgc2l6ZS4gKi9cbnZhciBNQVhfTUVNT0laRV9TSVpFID0gNTAwO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tZW1vaXplYCB3aGljaCBjbGVhcnMgdGhlIG1lbW9pemVkIGZ1bmN0aW9uJ3NcbiAqIGNhY2hlIHdoZW4gaXQgZXhjZWVkcyBgTUFYX01FTU9JWkVfU0laRWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtZW1vaXplQ2FwcGVkKGZ1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IG1lbW9pemUoZnVuYywgZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKGNhY2hlLnNpemUgPT09IE1BWF9NRU1PSVpFX1NJWkUpIHtcbiAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG4gIH0pO1xuXG4gIHZhciBjYWNoZSA9IHJlc3VsdC5jYWNoZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplQ2FwcGVkO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUNyZWF0ZTtcbiIsInZhciBvdmVyQXJnID0gcmVxdWlyZSgnLi9fb3ZlckFyZycpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlS2V5cztcbiIsIi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlXG4gKiBbYE9iamVjdC5rZXlzYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBleGNlcHQgdGhhdCBpdCBpbmNsdWRlcyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBuYXRpdmVLZXlzSW4ob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUtleXNJbjtcbiIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbm9kZVV0aWw7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvYmplY3RUb1N0cmluZztcbiIsIi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG92ZXJBcmc7XG4iLCJ2YXIgZnJlZUdsb2JhbCA9IHJlcXVpcmUoJy4vX2ZyZWVHbG9iYWwnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJvb3Q7XG4iLCIvKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogQWRkcyBgdmFsdWVgIHRvIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgYWRkXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBhbGlhcyBwdXNoXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUFkZCh2YWx1ZSkge1xuICB0aGlzLl9fZGF0YV9fLnNldCh2YWx1ZSwgSEFTSF9VTkRFRklORUQpO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRDYWNoZUFkZDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRDYWNoZUhhcztcbiIsIi8qKlxuICogQ29udmVydHMgYHNldGAgdG8gYW4gYXJyYXkgb2YgaXRzIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG5cbiAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0VG9BcnJheTtcbiIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBTdGFja1xuICovXG5mdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0NsZWFyO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIHJlc3VsdCA9IGRhdGFbJ2RlbGV0ZSddKGtleSk7XG5cbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrRGVsZXRlO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrR2V0O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0hhcztcbiIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKSxcbiAgICBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyk7XG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKlxuICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xuICAgIHZhciBwYWlycyA9IGRhdGEuX19kYXRhX187XG4gICAgaWYgKCFNYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICB9XG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrU2V0O1xuIiwidmFyIG1lbW9pemVDYXBwZWQgPSByZXF1aXJlKCcuL19tZW1vaXplQ2FwcGVkJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUxlYWRpbmdEb3QgPSAvXlxcLi8sXG4gICAgcmVQcm9wTmFtZSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwkKSkvZztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xudmFyIHN0cmluZ1RvUGF0aCA9IG1lbW9pemVDYXBwZWQoZnVuY3Rpb24oc3RyaW5nKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKHJlTGVhZGluZ0RvdC50ZXN0KHN0cmluZykpIHtcbiAgICByZXN1bHQucHVzaCgnJyk7XG4gIH1cbiAgc3RyaW5nLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN0cmluZykge1xuICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdUb1BhdGg7XG4iLCJ2YXIgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAqL1xuZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvS2V5O1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvU291cmNlO1xuIiwidmFyIGJhc2VDbG9uZSA9IHJlcXVpcmUoJy4vX2Jhc2VDbG9uZScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xudmFyIENMT05FX1NZTUJPTFNfRkxBRyA9IDQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHNoYWxsb3cgY2xvbmUgb2YgYHZhbHVlYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvbiB0aGVcbiAqIFtzdHJ1Y3R1cmVkIGNsb25lIGFsZ29yaXRobV0oaHR0cHM6Ly9tZG4uaW8vU3RydWN0dXJlZF9jbG9uZV9hbGdvcml0aG0pXG4gKiBhbmQgc3VwcG9ydHMgY2xvbmluZyBhcnJheXMsIGFycmF5IGJ1ZmZlcnMsIGJvb2xlYW5zLCBkYXRlIG9iamVjdHMsIG1hcHMsXG4gKiBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLCBzZXRzLCBzdHJpbmdzLCBzeW1ib2xzLCBhbmQgdHlwZWRcbiAqIGFycmF5cy4gVGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYGFyZ3VtZW50c2Agb2JqZWN0cyBhcmUgY2xvbmVkXG4gKiBhcyBwbGFpbiBvYmplY3RzLiBBbiBlbXB0eSBvYmplY3QgaXMgcmV0dXJuZWQgZm9yIHVuY2xvbmVhYmxlIHZhbHVlcyBzdWNoXG4gKiBhcyBlcnJvciBvYmplY3RzLCBmdW5jdGlvbnMsIERPTSBub2RlcywgYW5kIFdlYWtNYXBzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gKiBAc2VlIF8uY2xvbmVEZWVwXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gW3sgJ2EnOiAxIH0sIHsgJ2InOiAyIH1dO1xuICpcbiAqIHZhciBzaGFsbG93ID0gXy5jbG9uZShvYmplY3RzKTtcbiAqIGNvbnNvbGUubG9nKHNoYWxsb3dbMF0gPT09IG9iamVjdHNbMF0pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBjbG9uZSh2YWx1ZSkge1xuICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9TWU1CT0xTX0ZMQUcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lO1xuIiwiLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXE7XG4iLCJ2YXIgYmFzZUZpbmRJbmRleCA9IHJlcXVpcmUoJy4vX2Jhc2VGaW5kSW5kZXgnKSxcbiAgICBiYXNlSXRlcmF0ZWUgPSByZXF1aXJlKCcuL19iYXNlSXRlcmF0ZWUnKSxcbiAgICB0b0ludGVnZXIgPSByZXF1aXJlKCcuL3RvSW50ZWdlcicpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3RcbiAqIGVsZW1lbnQgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMS4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgLTFgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiBmYWxzZSB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IHRydWUgfVxuICogXTtcbiAqXG4gKiBfLmZpbmRJbmRleCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby51c2VyID09ICdiYXJuZXknOyB9KTtcbiAqIC8vID0+IDBcbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kSW5kZXgodXNlcnMsIHsgJ3VzZXInOiAnZnJlZCcsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAqIC8vID0+IDFcbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmRJbmRleCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICogLy8gPT4gMFxuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kSW5kZXgodXNlcnMsICdhY3RpdmUnKTtcbiAqIC8vID0+IDJcbiAqL1xuZnVuY3Rpb24gZmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIHZhciBpbmRleCA9IGZyb21JbmRleCA9PSBudWxsID8gMCA6IHRvSW50ZWdlcihmcm9tSW5kZXgpO1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgaW5kZXggPSBuYXRpdmVNYXgobGVuZ3RoICsgaW5kZXgsIDApO1xuICB9XG4gIHJldHVybiBiYXNlRmluZEluZGV4KGFycmF5LCBiYXNlSXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgaW5kZXgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZpbmRJbmRleDtcbiIsInZhciBiYXNlR2V0ID0gcmVxdWlyZSgnLi9fYmFzZUdldCcpO1xuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzXG4gKiBgdW5kZWZpbmVkYCwgdGhlIGBkZWZhdWx0VmFsdWVgIGlzIHJldHVybmVkIGluIGl0cyBwbGFjZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuNy4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgZm9yIGB1bmRlZmluZWRgIHJlc29sdmVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAqXG4gKiBfLmdldChvYmplY3QsICdhWzBdLmIuYycpO1xuICogLy8gPT4gM1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgWydhJywgJzAnLCAnYicsICdjJ10pO1xuICogLy8gPT4gM1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2EuYi5jJywgJ2RlZmF1bHQnKTtcbiAqIC8vID0+ICdkZWZhdWx0J1xuICovXG5mdW5jdGlvbiBnZXQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0O1xuIiwidmFyIGJhc2VIYXNJbiA9IHJlcXVpcmUoJy4vX2Jhc2VIYXNJbicpLFxuICAgIGhhc1BhdGggPSByZXF1aXJlKCcuL19oYXNQYXRoJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBvciBpbmhlcml0ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0gXy5jcmVhdGUoeyAnYSc6IF8uY3JlYXRlKHsgJ2InOiAyIH0pIH0pO1xuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYS5iJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsIFsnYScsICdiJ10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYicpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaGFzSW4ob2JqZWN0LCBwYXRoKSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgYmFzZUhhc0luKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNJbjtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKlxuICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaWRlbnRpdHk7XG4iLCJ2YXIgYmFzZUlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9fYmFzZUlzQXJndW1lbnRzJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcmd1bWVudHM7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5O1xuIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheUxpa2U7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKSxcbiAgICBzdHViRmFsc2UgPSByZXF1aXJlKCcuL3N0dWJGYWxzZScpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNCdWZmZXI7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0Z1bmN0aW9uO1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTGVuZ3RoO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3Q7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdExpa2U7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTeW1ib2w7XG4iLCJ2YXIgYmFzZUlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vX2Jhc2VJc1R5cGVkQXJyYXknKSxcbiAgICBiYXNlVW5hcnkgPSByZXF1aXJlKCcuL19iYXNlVW5hcnknKSxcbiAgICBub2RlVXRpbCA9IHJlcXVpcmUoJy4vX25vZGVVdGlsJyk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVHlwZWRBcnJheTtcbiIsInZhciBhcnJheUxpa2VLZXlzID0gcmVxdWlyZSgnLi9fYXJyYXlMaWtlS2V5cycpLFxuICAgIGJhc2VLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUtleXMnKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG5mdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5cztcbiIsInZhciBhcnJheUxpa2VLZXlzID0gcmVxdWlyZSgnLi9fYXJyYXlMaWtlS2V5cycpLFxuICAgIGJhc2VLZXlzSW4gPSByZXF1aXJlKCcuL19iYXNlS2V5c0luJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXNJbihuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG5mdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QsIHRydWUpIDogYmFzZUtleXNJbihvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXNJbjtcbiIsInZhciBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyk7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcbiAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxuICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICpcbiAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGVcbiAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBjbGVhcmAsIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xuICpcbiAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiB2YWx1ZXMob3RoZXIpO1xuICogLy8gPT4gWzMsIDRdXG4gKlxuICogb2JqZWN0LmEgPSAyO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiAvLyBNb2RpZnkgdGhlIHJlc3VsdCBjYWNoZS5cbiAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWydhJywgJ2InXVxuICpcbiAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXG4gKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuICovXG5mdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IChyZXNvbHZlciAhPSBudWxsICYmIHR5cGVvZiByZXNvbHZlciAhPSAnZnVuY3Rpb24nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF0sXG4gICAgICAgIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGU7XG5cbiAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpIHx8IGNhY2hlO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIG1lbW9pemVkLmNhY2hlID0gbmV3IChtZW1vaXplLkNhY2hlIHx8IE1hcENhY2hlKTtcbiAgcmV0dXJuIG1lbW9pemVkO1xufVxuXG4vLyBFeHBvc2UgYE1hcENhY2hlYC5cbm1lbW9pemUuQ2FjaGUgPSBNYXBDYWNoZTtcblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplO1xuIiwidmFyIGJhc2VQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2Jhc2VQcm9wZXJ0eScpLFxuICAgIGJhc2VQcm9wZXJ0eURlZXAgPSByZXF1aXJlKCcuL19iYXNlUHJvcGVydHlEZWVwJyksXG4gICAgaXNLZXkgPSByZXF1aXJlKCcuL19pc0tleScpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbXG4gKiAgIHsgJ2EnOiB7ICdiJzogMiB9IH0sXG4gKiAgIHsgJ2EnOiB7ICdiJzogMSB9IH1cbiAqIF07XG4gKlxuICogXy5tYXAob2JqZWN0cywgXy5wcm9wZXJ0eSgnYS5iJykpO1xuICogLy8gPT4gWzIsIDFdXG4gKlxuICogXy5tYXAoXy5zb3J0Qnkob2JqZWN0cywgXy5wcm9wZXJ0eShbJ2EnLCAnYiddKSksICdhLmInKTtcbiAqIC8vID0+IFsxLCAyXVxuICovXG5mdW5jdGlvbiBwcm9wZXJ0eShwYXRoKSB7XG4gIHJldHVybiBpc0tleShwYXRoKSA/IGJhc2VQcm9wZXJ0eSh0b0tleShwYXRoKSkgOiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHByb3BlcnR5O1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBhcnJheXMgPSBfLnRpbWVzKDIsIF8uc3R1YkFycmF5KTtcbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXMpO1xuICogLy8gPT4gW1tdLCBbXV1cbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXNbMF0gPT09IGFycmF5c1sxXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBzdHViQXJyYXkoKSB7XG4gIHJldHVybiBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHViQXJyYXk7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R1YkZhbHNlO1xuIiwidmFyIHRvTnVtYmVyID0gcmVxdWlyZSgnLi90b051bWJlcicpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwLFxuICAgIE1BWF9JTlRFR0VSID0gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDg7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIGZpbml0ZSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEyLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b0Zpbml0ZSgzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b0Zpbml0ZShOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9GaW5pdGUoSW5maW5pdHkpO1xuICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAqXG4gKiBfLnRvRmluaXRlKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b0Zpbml0ZSh2YWx1ZSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiAwO1xuICB9XG4gIHZhbHVlID0gdG9OdW1iZXIodmFsdWUpO1xuICBpZiAodmFsdWUgPT09IElORklOSVRZIHx8IHZhbHVlID09PSAtSU5GSU5JVFkpIHtcbiAgICB2YXIgc2lnbiA9ICh2YWx1ZSA8IDAgPyAtMSA6IDEpO1xuICAgIHJldHVybiBzaWduICogTUFYX0lOVEVHRVI7XG4gIH1cbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/IHZhbHVlIDogMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0Zpbml0ZTtcbiIsInZhciB0b0Zpbml0ZSA9IHJlcXVpcmUoJy4vdG9GaW5pdGUnKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGludGVnZXIuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9JbnRlZ2VyYF0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvaW50ZWdlcikuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b0ludGVnZXIoMy4yKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLnRvSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDBcbiAqXG4gKiBfLnRvSW50ZWdlcihJbmZpbml0eSk7XG4gKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICpcbiAqIF8udG9JbnRlZ2VyKCczLjInKTtcbiAqIC8vID0+IDNcbiAqL1xuZnVuY3Rpb24gdG9JbnRlZ2VyKHZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSB0b0Zpbml0ZSh2YWx1ZSksXG4gICAgICByZW1haW5kZXIgPSByZXN1bHQgJSAxO1xuXG4gIHJldHVybiByZXN1bHQgPT09IHJlc3VsdCA/IChyZW1haW5kZXIgPyByZXN1bHQgLSByZW1haW5kZXIgOiByZXN1bHQpIDogMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0ludGVnZXI7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE5BTiA9IDAgLyAwO1xuXG4vKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLiAqL1xudmFyIHJlVHJpbSA9IC9eXFxzK3xcXHMrJC9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJpbmFyeSBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvY3RhbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG5cbi8qKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB3aXRob3V0IGEgZGVwZW5kZW5jeSBvbiBgcm9vdGAuICovXG52YXIgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b051bWJlcigzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gSW5maW5pdHlcbiAqXG4gKiBfLnRvTnVtYmVyKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gTkFOO1xuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gIH1cbiAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlVHJpbSwgJycpO1xuICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b051bWJlcjtcbiIsInZhciBiYXNlVG9TdHJpbmcgPSByZXF1aXJlKCcuL19iYXNlVG9TdHJpbmcnKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvU3RyaW5nKG51bGwpO1xuICogLy8gPT4gJydcbiAqXG4gKiBfLnRvU3RyaW5nKC0wKTtcbiAqIC8vID0+ICctMCdcbiAqXG4gKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAnMSwyLDMnXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvU3RyaW5nO1xuIiwiLyogZ2xvYmFscyBtb2R1bGU6IGZhbHNlLCByZXF1aXJlOiBmYWxzZSAqL1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdGxldCBfZmkgPSByZXF1aXJlKCdsb2Rhc2gvZmluZEluZGV4JylcclxuXHRcdC8vICwgX2lzZXEgPSByZXF1aXJlKCdsb2Rhc2gvaXNFcXVhbCcpXHJcblx0XHQsIF9jbG9uZSA9IHJlcXVpcmUoJ2xvZGFzaC9jbG9uZScpXHJcblx0XHQvL3V0aWxpdGllc1xyXG5cdFx0Ly8gY29uc3RcclxuXHJcblx0XHQsIF9pc2VxID0gKHgsIHkpID0+IHtcclxuXHJcblx0XHRcdGlmICghQXJyYXkuaXNBcnJheSh4KSB8fCAhQXJyYXkuaXNBcnJheSh5KSkge1xyXG5cdFx0XHRcdHJldHVybiB4ID09IHkvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxyXG5cdFx0XHRcdC8vIHJldHVybiB4ID09PSB5XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHgubGVuZ3RoICE9PSB5Lmxlbmd0aCkgcmV0dXJuIGZhbHNlXHJcblx0XHRcdGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB4Lmxlbmd0aDsgaW5kZXgrKykge1xyXG5cdFx0XHRcdGlmICghX2lzZXEoeFtpbmRleF0sIHlbaW5kZXhdKSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiB0cnVlXHJcblxyXG5cdFx0fVxyXG5cdFx0LCBteUluZGV4T2YgPSAoYSwgYikgPT4ge1xyXG5cdFx0XHRyZXR1cm4gX2ZpKGEsIGZ1bmN0aW9uICh4KSB7IHJldHVybiBfaXNlcSh4LCBiKSB9KTtcclxuXHRcdH1cclxuXHQvLyB0aGlzIHZlcnNpb24sIHdpdGhvdXQgdGhlIF9maSBkZXBlbmRlbmN5LCBkb2Vzbid0IHdvcmshdG9kb1xyXG5cdC8vICAsIG15SW5kZXhPZiA9IChhcnJheSwgaXRlbSkgPT4ge1xyXG5cdC8vIFx0XHRmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgYXJyYXkubGVuZ3RoOyBpbmRleCsrKSB7XHJcblx0Ly8gXHRcdFx0aWYgKF9pc2VxKGFycmF5W2luZGV4XSwgaXRlbSkpIHtcclxuXHQvLyBcdFx0XHRcdHJldHVybiBpbmRleDtcclxuXHJcblx0Ly8gXHRcdFx0fVxyXG5cdC8vIFx0XHRcdHJldHVybiAtMTtcclxuXHQvLyBcdFx0fVxyXG5cclxuXHQvLyBcdH1cclxuXHJcblx0Ly8gXHQsIF9jbG9uZSA9IHJlcXVpcmUoJ2xvZGFzaC9jbG9uZScpXHJcblxyXG5cclxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxyXG5cdC8vIGJvYXJkTW9kZSA9IG9wdGlvbnMuYm9hcmRNb2RlIHx8ICd0Jy8qdDp0b3JvaWQ7IGM6Y2xhc3NpYyDigKYqL1xyXG5cdC8vICwgYm9hcmREaW1lbnNpb25zID0gb3B0aW9ucy5ib2FyZERpbWVuc2lvbnMgfHwgWzExLCAxMV0vKm1vdmUgbGF0ZXIqL1xyXG5cdC8vICwgcnVsZXMgPSBvcHRpb25zLnJ1bGVzIHx8IHtcclxuXHQvLyBzdWljaWRlOiB0cnVlLFxyXG5cdC8vIHN1cGVya286IGZhbHNlXHJcblx0Ly8gfVxyXG5cdGxldCAkID0ge31cclxuXHQvLy8vcHJvYmxlbSB3aXRoIHRoZSBvYmplY3Qgc3ByZWFkIG9wZXJhdG9yIGFuZCB0aGUgYnVpbGQgc28gdXNpbmcgT2JqZWN0LmFzc2lnbiBpbnN0ZWFkLlxyXG5cdC8vICQucnVsZXMgPSB7XHJcblx0Ly8gXHRcdHN1aWNpZGU6IHRydWUsXHJcblx0Ly8gXHRcdC8vIHN1cGVya286IGZhbHNlIC8q4oeSdG9kbzogZW5mb3JjZSB3aGVuIHRydWU/Ki8sXHJcblx0Ly8gXHRcdGtvbWk6IDcuNSxcclxuXHQvLyBcdFx0Li4uIG9wdGlvbnMucnVsZXNcclxuXHQvLyBcdH1cclxuXHQkLnJ1bGVzID0gT2JqZWN0LmFzc2lnbih7fSwge1xyXG5cdFx0c3VpY2lkZTogdHJ1ZSxcclxuXHRcdC8vIHN1cGVya286IGZhbHNlIC8q4oeSdG9kbzogZW5mb3JjZSB3aGVuIHRydWU/Ki8sXHJcblx0XHRrb21pOiA3LjUsXHJcblx0fSwgb3B0aW9ucy5ydWxlcylcclxuXHJcblx0Ly8gJC5tb3ZlcyA9IG9wdGlvbnMubW92ZXMgfHwgW11cclxuXHQkLm9wdGlvbnMgPSBvcHRpb25zXHJcblx0b3B0aW9ucy5ib2FyZERpbWVuc2lvbnMgPSBvcHRpb25zLmJvYXJkRGltZW5zaW9ucyB8fCBbMTEsIDExXVxyXG5cdG9wdGlvbnMuYm9hcmRNb2RlID0gb3B0aW9ucy5ib2FyZE1vZGUgfHwgJ3QnLyp0OnRvcm9pZDsgYzpjbGFzc2ljIOKApiovXHJcblx0JC5ib2FyZCA9IHt9XHJcblx0JC5ib2FyZC5ibGFja1N0b25lcyA9IG9wdGlvbnMuYmxhY2tTdG9uZXMgfHwgW11cclxuXHQkLmJvYXJkLndoaXRlU3RvbmVzID0gb3B0aW9ucy53aGl0ZVN0b25lcyB8fCBbXVxyXG5cclxuXHQkLmJvYXJkLm5leHRQbGF5ZXIgPSBvcHRpb25zLm5leHRQbGF5ZXIgfHwgXCJiXCJcclxuXHQkLmJvYXJkLmNhcHR1cmVkID0gb3B0aW9ucy5jYXB0dXJlZCB8fCBbMCwgMF1cclxuXHJcblx0JC5leHBvcnREYXRhID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0YmxhY2tTdG9uZXM6ICQuYm9hcmQuYmxhY2tTdG9uZXMubWFwKF9jbG9uZSksXHJcblxyXG5cdFx0XHR3aGl0ZVN0b25lczogJC5ib2FyZC53aGl0ZVN0b25lcy5tYXAoX2Nsb25lKSxcclxuXHRcdFx0Y2FwdHVyZWQ6IF9jbG9uZSgkLmJvYXJkLmNhcHR1cmVkKSxcclxuXHRcdFx0bmV4dFBsYXllcjogJC5ib2FyZC5uZXh0UGxheWVyXHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQkLmxvYWREYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuXHRcdCQuYm9hcmQuYmxhY2tTdG9uZXMgPSBkYXRhLmJsYWNrU3RvbmVzXHJcblx0XHQkLmJvYXJkLndoaXRlU3RvbmVzID0gZGF0YS53aGl0ZVN0b25lc1xyXG5cdFx0JC5ib2FyZC5jYXB0dXJlZCA9IGRhdGEuY2FwdHVyZWRcclxuXHRcdCQuYm9hcmQubmV4dFBsYXllciA9IGRhdGEubmV4dFBsYXllclxyXG5cdH1cclxuXHJcblx0Ly90b3JvaWRcclxuXHRpZiAob3B0aW9ucy5ib2FyZE1vZGUgPT09ICd0JykgJC5ib2FyZC5nZXROZWlnaGJvdXJzID1cclxuXHRcdGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0XHRsZXQgcmVzdWx0ID0gW11cclxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcclxuXHRcdFx0XHRsZXQgbmV3UG9pbnRcclxuXHRcdFx0XHRzd2l0Y2ggKGkpIHtcclxuXHRcdFx0XHRcdGNhc2UgMDpcclxuXHRcdFx0XHRcdFx0bmV3UG9pbnQgPSBbcG9pbnRbMF0gKyAxLCBwb2ludFsxXV1cclxuXHRcdFx0XHRcdFx0YnJlYWtcclxuXHRcdFx0XHRcdGNhc2UgMTpcclxuXHRcdFx0XHRcdFx0bmV3UG9pbnQgPSBbcG9pbnRbMF0gLSAxLCBwb2ludFsxXV1cclxuXHRcdFx0XHRcdFx0YnJlYWtcclxuXHRcdFx0XHRcdGNhc2UgMjpcclxuXHRcdFx0XHRcdFx0bmV3UG9pbnQgPSBbcG9pbnRbMF0sIHBvaW50WzFdICsgMV1cclxuXHRcdFx0XHRcdFx0YnJlYWtcclxuXHRcdFx0XHRcdGNhc2UgMzpcclxuXHRcdFx0XHRcdFx0bmV3UG9pbnQgPSBbcG9pbnRbMF0sIHBvaW50WzFdIC0gMV1cclxuXHRcdFx0XHRcdFx0YnJlYWtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmVzdWx0LnB1c2goWyhuZXdQb2ludFswXSArIG9wdGlvbnMuYm9hcmREaW1lbnNpb25zWzBdKSAlIG9wdGlvbnMuYm9hcmREaW1lbnNpb25zWzBdLCAobmV3UG9pbnRbMV0gKyBvcHRpb25zLmJvYXJkRGltZW5zaW9uc1sxXSkgJSBvcHRpb25zLmJvYXJkRGltZW5zaW9uc1sxXV0pXHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHJlc3VsdFxyXG5cdFx0fVxyXG5cdGlmIChvcHRpb25zLmJvYXJkTW9kZSA9PT0gJ2MnKSAkLmJvYXJkLmdldE5laWdoYm91cnMgPVxyXG5cdFx0ZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRcdGxldCByZXN1bHQgPSBbXVxyXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xyXG5cdFx0XHRcdGxldCBuZXdQb2ludFxyXG5cdFx0XHRcdHN3aXRjaCAoaSkge1xyXG5cdFx0XHRcdFx0Y2FzZSAwOlxyXG5cdFx0XHRcdFx0XHRuZXdQb2ludCA9IFtwb2ludFswXSArIDEsIHBvaW50WzFdXVxyXG5cdFx0XHRcdFx0XHRicmVha1xyXG5cdFx0XHRcdFx0Y2FzZSAxOlxyXG5cdFx0XHRcdFx0XHRuZXdQb2ludCA9IFtwb2ludFswXSAtIDEsIHBvaW50WzFdXVxyXG5cdFx0XHRcdFx0XHRicmVha1xyXG5cdFx0XHRcdFx0Y2FzZSAyOlxyXG5cdFx0XHRcdFx0XHRuZXdQb2ludCA9IFtwb2ludFswXSwgcG9pbnRbMV0gKyAxXVxyXG5cdFx0XHRcdFx0XHRicmVha1xyXG5cdFx0XHRcdFx0Y2FzZSAzOlxyXG5cdFx0XHRcdFx0XHRuZXdQb2ludCA9IFtwb2ludFswXSwgcG9pbnRbMV0gLSAxXVxyXG5cdFx0XHRcdFx0XHRicmVha1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAobmV3UG9pbnRbMF0gPj0gMCAmJiBuZXdQb2ludFswXSA8IG9wdGlvbnMuYm9hcmREaW1lbnNpb25zWzBdXHJcblx0XHRcdFx0XHQmJiBuZXdQb2ludFsxXSA+PSAwICYmIG5ld1BvaW50WzFdIDwgb3B0aW9ucy5ib2FyZERpbWVuc2lvbnNbMV1cclxuXHRcdFx0XHQpXHJcblx0XHRcdFx0XHRyZXN1bHQucHVzaChuZXdQb2ludClcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gcmVzdWx0XHJcblx0XHR9XHJcblx0Ly90b2RvOiBrbGVpbiwgcHJvamVjdGl2ZSBwbGFuZSwg4oCmXHJcblxyXG5cdCQuYm9hcmQuaXNFbXB0eSA9IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIG15SW5kZXhPZigkLmJvYXJkLmJsYWNrU3RvbmVzLCBwb2ludCkgPCAwXHJcblx0XHRcdCYmIG15SW5kZXhPZigkLmJvYXJkLndoaXRlU3RvbmVzLCBwb2ludCkgPCAwXHJcblx0fVxyXG5cdCQuYm9hcmQuZ2V0Q29sb3VyID0gZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRpZiAobXlJbmRleE9mKCQuYm9hcmQuYmxhY2tTdG9uZXMsIHBvaW50KSA+PSAwKSByZXR1cm4gJ2InXHJcblx0XHRpZiAobXlJbmRleE9mKCQuYm9hcmQud2hpdGVTdG9uZXMsIHBvaW50KSA+PSAwKSByZXR1cm4gJ3cnXHJcblx0XHRyZXR1cm4gJ2UnXHJcblx0fVxyXG5cdC8qKlxyXG5cdCAqIERldGVybWluZXMgaWYgYSBwb2ludCBpcyBwYXJ0IG9mIGEgY2hhaW4gd2l0aCBhIGxpYmVydHk7IGlmIHRoZXJlIGFyZSBubyBsaWJlcnRpZXMgdGhlbiBpdCByZXR1cm5zIHRoZSBjaGFpbiBvZiBzdG9uZXMgb2YgdGhlIHNhbWUgY29sb3VyIHRoYXQgYXJlIGNvbm5lY3RlZCB0byBgc3RhcnRQb2ludGAuIEFsc28gdXNlZCBmb3IgY291bnRpbmcgdG8gcmV0dXJuIGNvbm5lY3RlZCBjb21wb25lbnRzIG9mIHNhbWUgY29sb3VyIChibGFjaywgd2hpdGUgb3IgZW1wdHkpLlxyXG5cdCAqIEBwYXJhbSB7Kn0gc3RhcnRQb2ludCBcclxuXHQgKiBAcGFyYW0ge3N0cmluZ3xudWxsfSBjaGFpbkNvbG91ciBpbmRpY2F0ZXMgdGhlIGNvbG91ciBvZiB0aGUgc3RhcnRpbmcgcG9pbnQuXHJcblx0ICogQHBhcmFtIHsqfSBbc3RvcENvbG91cj0nZSddIHN0b3Agd29ya2luZyBpZiB0aGUgY2hhaW4gbWVldHMgdGhpcyBjb2xvdXJcclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZ2V0Q29sb3VyPSQuYm9hcmQuZ2V0Q29sb3VyXSBGdW5jdGlvbiB1c2VkIHRvIGRldGVybWluZSB0aGUgY29sb3VyIG9mIGEgcG9pbnQuXHJcblx0ICogQHJldHVybnMge2Jvb2x8YXJyYXl9IFJldHVybnMgYHRydWVgIGlmIHRoZSB0aGUgY29tcG9uZW50IG1lZXRzIGBzdG9wQ29sb3VyYCwgYW5kIGFuIGFycmF5IGNvbnRhaW5pbmcgY29ubmVjdGVkIGNvbXBvbmVudCBvZiBwb2ludHMgbGlua2VkIHRvIGBzdGFydFBvaW50YCBvdGhlcndpc2UuIFxyXG5cdCAqL1x0XHJcblx0ZnVuY3Rpb24gY2hhaW5IYXNMaWJlcnR5IChzdGFydFBvaW50LCBjaGFpbkNvbG91ciwgc3RvcENvbG91ciwgZ2V0Q29sb3VyKSB7XHJcblx0XHRpZiAoc3RvcENvbG91ciA9PT0gdW5kZWZpbmVkKVxyXG5cdFx0XHRzdG9wQ29sb3VyID0gJ2UnLy9ieSBkZWZhdWx0LCBzdG9wIGdldHRpbmcgdGhlIGNoYWluIHdoZW4gdGhlcmUgaXMgYSBsaWJlcnR5LlxyXG5cdFx0aWYgKGdldENvbG91ciA9PT0gdW5kZWZpbmVkKVxyXG5cdFx0XHRnZXRDb2xvdXIgPSAkLmJvYXJkLmdldENvbG91ci8vYnkgZGVmYXVsdCwgdXNlIHRoZSB1c3VhbCBib2FyZCBjb2xvdXIgZnVuY3Rpb25cclxuXHJcblx0XHRpZiAoY2hhaW5Db2xvdXIgPT09IG51bGwpXHJcblx0XHRcdGNoYWluQ29sb3VyID0gZ2V0Q29sb3VyKHN0YXJ0UG9pbnQpXHJcblx0XHRsZXRcclxuXHRcdFx0Y2hhaW4gPSBbc3RhcnRQb2ludF1cclxuXHRcdFx0LCB0b0V4cGxvcmUgPSBbXVxyXG5cdFx0XHQsIHBvaW50ID0gc3RhcnRQb2ludCAvL2Fzc3VtZWQgdG8gYmUgb2YgY29sb3VyIGNoYWluQ29sb3VyXHJcblxyXG5cdFx0d2hpbGUgKHBvaW50ICE9PSB1bmRlZmluZWQpIHtcclxuXHJcblx0XHRcdGxldCBuZWlnaGJvdXJzID0gJC5ib2FyZC5nZXROZWlnaGJvdXJzKHBvaW50KVxyXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG5laWdoYm91cnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRsZXQgbmV3UG9pbnQgPSBuZWlnaGJvdXJzW2ldLFxyXG5cdFx0XHRcdFx0bmV3Q29sb3VyID0gZ2V0Q29sb3VyKG5ld1BvaW50KVxyXG5cdFx0XHRcdGlmIChuZXdDb2xvdXIgPT09IHN0b3BDb2xvdXIpIHJldHVybiB0cnVlO1xyXG5cdFx0XHRcdGlmIChuZXdDb2xvdXIgPT09IGNoYWluQ29sb3VyKSB7XHJcblx0XHRcdFx0XHRpZiAobXlJbmRleE9mKGNoYWluLCBuZXdQb2ludCkgPCAwKSB7XHJcblx0XHRcdFx0XHRcdGNoYWluLnB1c2gobmV3UG9pbnQpXHJcblx0XHRcdFx0XHRcdC8vIGlmIChteUluZGV4T2YodG9FeHBsb3JlLCBuZXdQb2ludCkgPCAwKVxyXG5cdFx0XHRcdFx0XHR0b0V4cGxvcmUucHVzaChuZXdQb2ludClcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0cG9pbnQgPSB0b0V4cGxvcmUucG9wKClcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gY2hhaW47XHJcblx0fVxyXG5cclxuXHQkLmJvYXJkLmNoYWluSGFzTGliZXJ0eSA9IGNoYWluSGFzTGliZXJ0eSBcclxuXHJcblx0JC5ib2FyZC5zY29yZSA9IGZ1bmN0aW9uIChkZWFkU3RvbmVzKSB7XHJcblx0XHQvKlxyXG5cdFx0Z28gdGhyb3VnaCB0aGUgd2hvbGUgYm9hcmQgXHJcblx0XHQqL1xyXG5cdFx0aWYgKGRlYWRTdG9uZXMgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRkZWFkU3RvbmVzID0gW11cclxuXHRcdH1cclxuXHJcblx0XHRsZXQgcmVzdWx0ID0ge1xyXG5cdFx0XHRibGFja0VtcHR5OiBbXVxyXG5cdFx0XHQsIHdoaXRlRW1wdHk6IFtdXHJcblx0XHRcdCwgZGFtZTogW11cclxuXHRcdFx0LCBibGFja0FsaXZlOiBbXVxyXG5cdFx0XHQsIHdoaXRlQWxpdmU6IFtdXHJcblx0XHRcdCwgYmxhY2tEZWFkOiBbXVxyXG5cdFx0XHQsIHdoaXRlRGVhZDogW11cclxuXHRcdFx0LCB0b3RhbEJsYWNrQ2FwdHVyZWQ6ICQuYm9hcmQuY2FwdHVyZWRbMF0gLy9uYiBCIHN0b25lcyByZW1vdmVkIGJ5IFcgZHVyaW5nIHRoZSBnYW1lXHJcblx0XHRcdCwgdG90YWxXaGl0ZUNhcHR1cmVkOiAkLmJvYXJkLmNhcHR1cmVkWzFdIC8vbmIgVyBzdG9uZXMgcmVtb3ZlZCBieSBCIGR1cmluZyB0aGUgZ2FtZVxyXG5cdFx0XHQvL3RvZG86Y291bGQgcmVwbGFjZSBieSBhbiBjbGFzcy4gZGF0YSBzdG9yZWQgaW4gYSBiaWcgYXJyYXkgb2YgcGFpcnMgW3BvaW50LCBzdGF0dXNdXHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGRlYWRTdG9uZXMubGVuZ3RoOyBpbmRleCsrKSB7XHJcblx0XHRcdGNvbnN0IGRlYWRTdG9uZSA9IGRlYWRTdG9uZXNbaW5kZXhdO1xyXG5cdFx0XHRsZXQgZGVhZENvbG91ciA9ICQuYm9hcmQuZ2V0Q29sb3VyKGRlYWRTdG9uZSlcclxuXHRcdFx0aWYgKGRlYWRDb2xvdXIgPT09ICdlJykgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIG1hcmtlZCBkZWFkIHN0b25lJylcclxuXHRcdFx0bGV0XHJcblx0XHRcdFx0ZGVhZFRvRmlsbCA9IGRlYWRDb2xvdXIgPT09ICdiJyA/IHJlc3VsdC5ibGFja0RlYWQgOiByZXN1bHQud2hpdGVEZWFkXHJcblx0XHRcdFx0LCBlbXB0eVRvRmlsbCA9IGRlYWRDb2xvdXIgPT09ICdiJyA/IHJlc3VsdC53aGl0ZUVtcHR5IDogcmVzdWx0LmJsYWNrRW1wdHlcclxuXHRcdFx0XHQsIGFsaXZlVG9GaWxsID0gZGVhZENvbG91ciA9PT0gJ2InID8gcmVzdWx0LndoaXRlQWxpdmUgOiByZXN1bHQuYmxhY2tBbGl2ZVxyXG5cdFx0XHRcdCwgcHJvY2Vzc1BvaW50ID0gKHBvaW50LCBjb2xvdXIpID0+IHtcclxuXHRcdFx0XHRcdGlmIChjb2xvdXIgPT09IGRlYWRDb2xvdXIgJiYgbXlJbmRleE9mKGRlYWRUb0ZpbGwsIHBvaW50KSA8IDApIHtcclxuXHRcdFx0XHRcdFx0ZGVhZFRvRmlsbC5wdXNoKHBvaW50KVxyXG5cdFx0XHRcdFx0XHRlbXB0eVRvRmlsbC5wdXNoKHBvaW50KVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKChjb2xvdXIgPT09IGRlYWRDb2xvdXIgfHwgY29sb3VyID09PSAnZScpICYmIG15SW5kZXhPZihlbXB0eVRvRmlsbCwgcG9pbnQpIDwgMCkge1xyXG5cdFx0XHRcdFx0XHRlbXB0eVRvRmlsbC5wdXNoKHBvaW50KVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKGNvbG91ciAhPT0gZGVhZENvbG91ciAmJiBjb2xvdXIgIT09ICdlJyAmJiBteUluZGV4T2YoYWxpdmVUb0ZpbGwsIHBvaW50KSA8IDApIHtcclxuXHRcdFx0XHRcdFx0YWxpdmVUb0ZpbGwucHVzaChwb2ludClcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0LCBnZXRDb2xvdXJGb3JEZWFkQ29tcG9uZW50ID0gKHBvaW50KSA9PiB7XHJcblx0XHRcdFx0XHRsZXQgY29sb3VyID0gJC5ib2FyZC5nZXRDb2xvdXIocG9pbnQpXHJcblx0XHRcdFx0XHRwcm9jZXNzUG9pbnQocG9pbnQsIGNvbG91cilcclxuXHRcdFx0XHRcdHJldHVybiBjb2xvdXIgPT09IGRlYWRDb2xvdXIgPyAnZScgOiBjb2xvdXJcclxuXHRcdFx0XHR9XHJcblx0XHRcdHByb2Nlc3NQb2ludChkZWFkU3RvbmUsIGRlYWRDb2xvdXIpXHJcblx0XHRcdCQuYm9hcmQuY2hhaW5IYXNMaWJlcnR5KGRlYWRTdG9uZSwgJ2UnLCAnJywgZ2V0Q29sb3VyRm9yRGVhZENvbXBvbmVudClcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKGxldCBpID0gMCxleGl0TG9vcCA9IGZhbHNlOyBpIDwgb3B0aW9ucy5ib2FyZERpbWVuc2lvbnNbMF07IGkrKykge1xyXG5cdFx0XHRpZiAoZXhpdExvb3ApIHtcclxuXHRcdFx0XHRicmVha1xyXG5cdFx0XHR9XHJcblx0XHRcdGZvciAobGV0IGogPSAwOyBqIDwgb3B0aW9ucy5ib2FyZERpbWVuc2lvbnNbMV07IGorKykge1xyXG5cdFx0XHRcdGlmIChyZXN1bHQuYmxhY2tFbXB0eS5sZW5ndGhcclxuXHRcdFx0XHRcdCsgcmVzdWx0LndoaXRlRW1wdHkubGVuZ3RoXHJcblx0XHRcdFx0XHQrIHJlc3VsdC5kYW1lLmxlbmd0aFxyXG5cdFx0XHRcdFx0KyByZXN1bHQuYmxhY2tBbGl2ZS5sZW5ndGhcclxuXHRcdFx0XHRcdCsgcmVzdWx0LndoaXRlQWxpdmUubGVuZ3RoXHJcblx0XHRcdFx0XHQvLyArIHJlc3VsdC5ibGFja0RlYWQubGVuZ3RoXHJcblx0XHRcdFx0XHQvLyArIHJlc3VsdC53aGl0ZURlYWQubGVuZ3RoXHJcblx0XHRcdFx0XHQ9PT0gb3B0aW9ucy5ib2FyZERpbWVuc2lvbnNbMF0gKiBvcHRpb25zLmJvYXJkRGltZW5zaW9uc1sxXVxyXG5cdFx0XHRcdCkge1xyXG5cdFx0XHRcdFx0ZXhpdExvb3AgPSB0cnVlXHJcblx0XHRcdFx0XHRicmVha1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRjb25zdCBwb2ludCA9IFtpLCBqXSwgY29sb3VyID0gJC5ib2FyZC5nZXRDb2xvdXIocG9pbnQpXHJcblxyXG5cdFx0XHRcdGlmIChjb2xvdXIgPT09ICdiJ1xyXG5cdFx0XHRcdCkge1xyXG5cdFx0XHRcdFx0aWYgKG15SW5kZXhPZihyZXN1bHQuYmxhY2tBbGl2ZSwgcG9pbnQpIDwgMFxyXG5cdFx0XHRcdFx0XHQmJiBteUluZGV4T2YocmVzdWx0LmJsYWNrRGVhZCwgcG9pbnQpIDwgMCkge1xyXG5cdFx0XHRcdFx0XHRyZXN1bHQuYmxhY2tBbGl2ZS5wdXNoKHBvaW50KVxyXG5cdFx0XHRcdFx0fSBlbHNlIGNvbnRpbnVlXHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmIChjb2xvdXIgPT09ICd3Jykge1xyXG5cdFx0XHRcdFx0aWYgKG15SW5kZXhPZihyZXN1bHQud2hpdGVBbGl2ZSwgcG9pbnQpIDwgMFxyXG5cdFx0XHRcdFx0XHQmJiBteUluZGV4T2YocmVzdWx0LndoaXRlRGVhZCwgcG9pbnQpIDwgMCkge1xyXG5cdFx0XHRcdFx0XHRyZXN1bHQud2hpdGVBbGl2ZS5wdXNoKHBvaW50KVxyXG5cdFx0XHRcdFx0fSBlbHNlIGNvbnRpbnVlXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoY29sb3VyID09PSAnZScpIHtcclxuXHRcdFx0XHRcdGlmIChteUluZGV4T2YocmVzdWx0LmJsYWNrRW1wdHksIHBvaW50KSA+PSAwXHJcblx0XHRcdFx0XHRcdHx8IG15SW5kZXhPZihyZXN1bHQud2hpdGVFbXB0eSwgcG9pbnQpID49IDBcclxuXHRcdFx0XHRcdFx0fHwgbXlJbmRleE9mKHJlc3VsdC5kYW1lLCBwb2ludCkgPj0gMCkge1xyXG5cdFx0XHRcdFx0XHRjb250aW51ZVxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGxldFxyXG5cdFx0XHRcdFx0XHRtZWV0c0JsYWNrID0gZmFsc2VcclxuXHRcdFx0XHRcdFx0LCBtZWV0c1doaXRlID0gZmFsc2VcclxuXHRcdFx0XHRcdFx0LCBpc0JsYWNrVGVycml0b3J5ID0gZmFsc2VcclxuXHRcdFx0XHRcdFx0LCBpc1doaXRlVGVycml0b3J5ID0gZmFsc2VcclxuXHRcdFx0XHRcdFx0LCBnZXRDb2xvdXJGb3JTY29yaW5nID0gKHBvaW50KSA9PiB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGxldCBjb2xvdXIgPSAkLmJvYXJkLmdldENvbG91cihwb2ludClcclxuXHRcdFx0XHRcdFx0XHRzd2l0Y2ggKGNvbG91cikge1xyXG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSAnYic6XHJcblx0XHRcdFx0XHRcdFx0XHRcdGlmIChteUluZGV4T2YocmVzdWx0LmJsYWNrRGVhZCwgcG9pbnQpID49IDApIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjb2xvdXIgPSAnZSdcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpc1doaXRlVGVycml0b3J5ID0gdHJ1ZVxyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG1lZXRzQmxhY2sgPSB0cnVlXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKG15SW5kZXhPZihyZXN1bHQuYmxhY2tBbGl2ZSwgcG9pbnQpIDwgMCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzdWx0LmJsYWNrQWxpdmUucHVzaChwb2ludClcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0XHRjYXNlICd3JzpcclxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKG15SW5kZXhPZihyZXN1bHQud2hpdGVEZWFkLCBwb2ludCkgPj0gMCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNvbG91ciA9ICdlJ1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlzQmxhY2tUZXJyaXRvcnkgPSB0cnVlXHJcblx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0bWVldHNXaGl0ZSA9IHRydWVcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAobXlJbmRleE9mKHJlc3VsdC53aGl0ZUFsaXZlLCBwb2ludCkgPCAwKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXN1bHQud2hpdGVBbGl2ZS5wdXNoKHBvaW50KVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0Oi8vbm90aGluZyBuZWVkZWQgZm9yICdlJ1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGNvbG91clxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRsZXQgZW1wdHlDb21wb25lbnQgPSAkLmJvYXJkLmNoYWluSGFzTGliZXJ0eShwb2ludCwgJ2UnLCAnJywgZ2V0Q29sb3VyRm9yU2NvcmluZylcclxuXHRcdFx0XHRcdGlmICghbWVldHNCbGFjayAmJiAhbWVldHNXaGl0ZSkge1xyXG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2NvdW50aW5nIGFuIGVtcHR5IGJvYXJkIScpXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiAoaXNCbGFja1RlcnJpdG9yeSAmJiBpc1doaXRlVGVycml0b3J5KSB7XHJcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcigndG9vIG1hbnkgc3RvbmVzIG1hcmtlZCBhcyBkZWFkJylcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdC8vY291bGQgc3RvcmUgdGhlIGRpZmZlcmVudCBlbXB0eSBjb21wb25lbnRzOiBWMiBcclxuXHRcdFx0XHRcdGlmIChtZWV0c0JsYWNrICYmIG1lZXRzV2hpdGUpIHtcclxuXHRcdFx0XHRcdFx0cmVzdWx0LmRhbWUgPSByZXN1bHQuZGFtZS5jb25jYXQoZW1wdHlDb21wb25lbnQpXHJcblx0XHRcdFx0XHRcdGNvbnRpbnVlXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiAobWVldHNCbGFjaykge1xyXG5cdFx0XHRcdFx0XHRyZXN1bHQuYmxhY2tFbXB0eSA9IHJlc3VsdC5ibGFja0VtcHR5LmNvbmNhdChlbXB0eUNvbXBvbmVudClcclxuXHRcdFx0XHRcdFx0Y29udGludWVcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmIChtZWV0c1doaXRlKSB7XHJcblx0XHRcdFx0XHRcdHJlc3VsdC53aGl0ZUVtcHR5ID0gcmVzdWx0LndoaXRlRW1wdHkuY29uY2F0KGVtcHR5Q29tcG9uZW50KVxyXG5cdFx0XHRcdFx0XHRjb250aW51ZVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0Ly90b3RhbHNcclxuXHRcdHJlc3VsdC50b3RhbEJsYWNrRGVhZCA9IHJlc3VsdC5ibGFja0RlYWQubGVuZ3RoXHJcblx0XHRyZXN1bHQudG90YWxXaGl0ZURlYWQgPSByZXN1bHQud2hpdGVEZWFkLmxlbmd0aFxyXG5cdFx0cmVzdWx0LnRvdGFsQmxhY2tUZXJyaXRvcnkgPSByZXN1bHQuYmxhY2tFbXB0eS5sZW5ndGhcclxuXHRcdHJlc3VsdC50b3RhbFdoaXRlVGVycml0b3J5ID0gcmVzdWx0LndoaXRlRW1wdHkubGVuZ3RoXHJcblxyXG5cclxuXHRcdC8vdG9kbzogaW1wbGVtZW50IG90aGVyIHJ1bGVzZXRzLiBGb3Igbm93LCBqdXN0IGRvIHRlcnJpdG9yeSArIHByaXNvbmVycyAoSmFwYW5lc2Ugc3R5bGUgY291bnRpbmcpXHJcblx0XHRyZXN1bHQuYmxhY2tTY29yZSA9XHJcblx0XHRcdHJlc3VsdC50b3RhbFdoaXRlRGVhZFxyXG5cdFx0XHQrIHJlc3VsdC50b3RhbFdoaXRlQ2FwdHVyZWRcclxuXHRcdFx0KyByZXN1bHQudG90YWxCbGFja1RlcnJpdG9yeVxyXG5cdFx0cmVzdWx0LndoaXRlU2NvcmUgPVxyXG5cdFx0XHRyZXN1bHQudG90YWxCbGFja0RlYWRcclxuXHRcdFx0KyByZXN1bHQudG90YWxCbGFja0NhcHR1cmVkXHJcblx0XHRcdCsgcmVzdWx0LnRvdGFsV2hpdGVUZXJyaXRvcnlcclxuXHRcdFx0KyAkLnJ1bGVzLmtvbWlcclxuXHRcdGxldCByID0gcmVzdWx0LmJsYWNrU2NvcmUgLSByZXN1bHQud2hpdGVTY29yZVxyXG5cdFx0aWYgKHIgPT09IDApIHJlc3VsdC5SRSA9ICcwJ1xyXG5cdFx0ZWxzZSBpZiAociA+IDApIHJlc3VsdC5SRSA9ICdCKycgKyByXHJcblx0XHRlbHNlIHJlc3VsdC5SRSA9ICdXKycgKyAoLXIpXHJcblx0XHRyZXR1cm4gcmVzdWx0XHJcblx0fVxyXG5cclxuXHQkLmJvYXJkLmVtcHR5ID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0JC5ib2FyZC53aGl0ZVN0b25lcyA9IFtdXHJcblx0XHQkLmJvYXJkLmJsYWNrU3RvbmVzID0gW11cclxuXHRcdCQuYm9hcmQuY2FwdHVyZWQgPSBbMCwgMF1cclxuXHJcblx0fVxyXG5cclxuXHQkLnJlbW92ZUNoYWluID0gZnVuY3Rpb24gKGNoYWluLCBjb2xvdXIpIHtcclxuXHRcdGxldCB0b1JlbW92ZUZyb20gPSBjb2xvdXIgPT09ICd3JyA/ICQuYm9hcmQud2hpdGVTdG9uZXMgOiAkLmJvYXJkLmJsYWNrU3RvbmVzXHJcblx0XHRmb3IgKGxldCBqID0gMDsgaiA8IGNoYWluLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdGxldCBpbmRleCA9IG15SW5kZXhPZih0b1JlbW92ZUZyb20sIGNoYWluW2pdKVxyXG5cdFx0XHR0b1JlbW92ZUZyb20uc3BsaWNlKGluZGV4LCAxKVxyXG5cdFx0XHRpZiAoY29sb3VyID09PSAndycpICQuYm9hcmQuY2FwdHVyZWRbMV0gPSAkLmJvYXJkLmNhcHR1cmVkWzFdICsgMVxyXG5cdFx0XHRlbHNlICQuYm9hcmQuY2FwdHVyZWRbMF0gPSAkLmJvYXJkLmNhcHR1cmVkWzBdICsgMVxyXG5cdFx0fVxyXG5cdH1cclxuXHQkLnBsYXkgPSBmdW5jdGlvbiAocGxheWVyQ29sb3VyLCBwb2ludCkge1xyXG5cclxuXHJcblxyXG5cdFx0Ly8gbGV0IHJlc3VsdCA9IFwib2tcIlxyXG5cdFx0aWYgKCEkLmJvYXJkLmlzRW1wdHkocG9pbnQpKVxyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ3BvaW50IGlzIG5vdCBlbXB0eScpXHJcblx0XHQvLyBjb25zb2xlLmxvZygncG9pbnQgaXMgbm90IGVtcHR5JyArIHBvaW50KVxyXG5cclxuXHRcdGlmIChwbGF5ZXJDb2xvdXIgPT09ICdiJykgJC5ib2FyZC5ibGFja1N0b25lcy5wdXNoKHBvaW50KVxyXG5cdFx0ZWxzZSAkLmJvYXJkLndoaXRlU3RvbmVzLnB1c2gocG9pbnQpXHJcblxyXG5cdFx0bGV0IG5laWdoYm91cnMgPSAkLmJvYXJkLmdldE5laWdoYm91cnMocG9pbnQpXHJcblx0XHRcdCwgcmVtb3ZlZCA9IFtdLy9jaGFpbnMgcmVtb3ZlZFxyXG5cclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbmVpZ2hib3Vycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRsZXQgbmVpZ2hib3VyID0gbmVpZ2hib3Vyc1tpXSwgY29sb3VyID0gJC5ib2FyZC5nZXRDb2xvdXIobmVpZ2hib3VyKVxyXG5cdFx0XHRpZiAoY29sb3VyID09PSBwbGF5ZXJDb2xvdXIgfHwgY29sb3VyID09PSAnZScpIGNvbnRpbnVlXHJcblx0XHRcdGxldCBvcHBDb2xvdXIgPSAkLmdldE9wcG9zaXRlQ29sb3VyKHBsYXllckNvbG91ciksXHJcblx0XHRcdFx0ciA9ICQuYm9hcmQuY2hhaW5IYXNMaWJlcnR5KG5laWdoYm91ciwgb3BwQ29sb3VyKVxyXG5cdFx0XHRpZiAociA9PT0gdHJ1ZSkgY29udGludWVcclxuXHRcdFx0Ly8vL3JlbW92ZSAtIG5vIGxpYmVydGllc1xyXG5cdFx0XHRyZW1vdmVkW3JlbW92ZWQubGVuZ3RoXSA9IHJcclxuXHJcblx0XHRcdCQucmVtb3ZlQ2hhaW4ociwgb3BwQ29sb3VyKVxyXG5cclxuXHRcdFx0Ly8gbGV0IGNoYWluVG9SZW1vdmUgPSByWzFdLFxyXG5cdFx0XHQvLyB0b1JlbW92ZUZyb20gPSBwbGF5ZXJDb2xvdXIgPT09ICdiJyA/ICQuYm9hcmQud2hpdGVTdG9uZXMgOiAkLmJvYXJkLmJsYWNrU3RvbmVzXHJcblx0XHRcdC8vIGZvciAobGV0IGogPSAwOyBqPGNoYWluVG9SZW1vdmUubGVuZ3RoOyBqKyspXHJcblx0XHRcdC8vIHtcclxuXHRcdFx0Ly8gbGV0IGluZGV4ID0gbXlJbmRleE9mKHRvUmVtb3ZlRnJvbSxjaGFpblRvUmVtb3ZlW2pdKVxyXG5cdFx0XHQvLyB0b1JlbW92ZUZyb20uc3BsaWNlKGluZGV4LCAxKVxyXG5cdFx0XHQvLyBpZiAocGxheWVyQ29sb3VyID09PSAnYicpICQuYm9hcmQuY2FwdHVyZWRbMV0gPSAkLmJvYXJkLmNhcHR1cmVkWzFdICsgMVxyXG5cdFx0XHQvLyBlbHNlICQuYm9hcmQuY2FwdHVyZWRbMF0gPSAkLmJvYXJkLmNhcHR1cmVkWzBdICsgMVxyXG5cdFx0XHQvLyB9XHJcblx0XHRcdC8vIHJlbW92ZWQgPSB0cnVlXHJcblx0XHR9XHJcblx0XHRsZXQgc3VpY2lkZSA9IGZhbHNlXHJcblx0XHRpZiAocmVtb3ZlZC5sZW5ndGggPT09IDApIHtcclxuXHRcdFx0bGV0IHMgPSAkLmJvYXJkLmNoYWluSGFzTGliZXJ0eShwb2ludCwgcGxheWVyQ29sb3VyKVxyXG5cdFx0XHRpZiAocyAhPT0gdHJ1ZSkge1xyXG5cdFx0XHRcdGlmICgkLnJ1bGVzLnN1aWNpZGUpIHtcclxuXHRcdFx0XHRcdCQucmVtb3ZlQ2hhaW4ocywgcGxheWVyQ29sb3VyKVxyXG5cdFx0XHRcdFx0c3VpY2lkZSA9IHNcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ3N1aWNpZGUnKS8vaXNu4oCZdCBhbGxvd2VkXHJcblx0XHRcdFx0XHQvL3RvZG86IHJlbW92ZSBwb2ludCBmcm9tIHdoaXRlU3RvbmVzIG9yIGJsYWNrU3RvbmVzXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0LypcclxuXHRcdFx0c3RvcmluZyB0aGUgc2l0dWF0aW9uIGluIG1lbW9yeSAtIHdvdWxkIGJlIHVzZWZ1bCB3aGVuIGltcGxlbWVudGluZyBnb2luZyBiYWNrIGEgbW92ZSwgc3VwZXJrbywg4oCmXHJcblx0XHRcdG5vdCBuZWVkZWQgZm9yIG5vd1xyXG5cdFx0Ki9cclxuXHRcdC8vJC5tb3Zlcy5wdXNoKFtwbGF5ZXJDb2xvdXIscG9pbnQsXy5jbG9uZSgkLmJvYXJkLndoaXRlU3RvbmVzKSxfLmNsb25lKCQuYm9hcmQuYmxhY2tTdG9uZXMpXSlcclxuXHRcdC8vICQubW92ZXMucHVzaChbcGxheWVyQ29sb3VyLHBvaW50XSlcclxuXHJcblx0XHQvLyBnZXROZWlnaGJvdXJzW2ldID0gW2dldE5laWdoYm91cnNbaV0sICQuYm9hcmQuZ2V0Q29sb3VyW2dldE5laWdoYm91cnNbaV1dXHJcblx0XHQvLyAvL+KAplxyXG5cclxuXHJcblx0XHRyZXR1cm4geyByZW1vdmVkLCBzdWljaWRlIH1cclxuXHR9XHJcblx0JC5nZXRPcHBvc2l0ZUNvbG91ciA9IGZ1bmN0aW9uIChjb2xvdXIpIHtcclxuXHRcdHN3aXRjaCAoY29sb3VyKSB7XHJcblx0XHRcdGNhc2UgJ2InOlxyXG5cdFx0XHRcdHJldHVybiAndydcclxuXHRcdFx0Y2FzZSAndyc6XHJcblx0XHRcdFx0cmV0dXJuICdiJ1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG51bGxcclxuXHR9XHJcblx0cmV0dXJuICRcclxuXHJcbn0iLCJ2YXIgYmFzZUluZGV4T2YgPSByZXF1aXJlKCcuL19iYXNlSW5kZXhPZicpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5pbmNsdWRlc2AgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBzcGVjaWZ5aW5nIGFuIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHRhcmdldGAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlJbmNsdWRlcyhhcnJheSwgdmFsdWUpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiYgYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCAwKSA+IC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5SW5jbHVkZXM7XG4iLCIvKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXJyYXlJbmNsdWRlc2AgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhIGNvbXBhcmF0b3IuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdGFyZ2V0YCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheUluY2x1ZGVzV2l0aChhcnJheSwgdmFsdWUsIGNvbXBhcmF0b3IpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChjb21wYXJhdG9yKHZhbHVlLCBhcnJheVtpbmRleF0pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5SW5jbHVkZXNXaXRoO1xuIiwidmFyIGFycmF5UHVzaCA9IHJlcXVpcmUoJy4vX2FycmF5UHVzaCcpLFxuICAgIGlzRmxhdHRlbmFibGUgPSByZXF1aXJlKCcuL19pc0ZsYXR0ZW5hYmxlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmxhdHRlbmAgd2l0aCBzdXBwb3J0IGZvciByZXN0cmljdGluZyBmbGF0dGVuaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkZXB0aCBUaGUgbWF4aW11bSByZWN1cnNpb24gZGVwdGguXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwcmVkaWNhdGU9aXNGbGF0dGVuYWJsZV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU3RyaWN0XSBSZXN0cmljdCB0byB2YWx1ZXMgdGhhdCBwYXNzIGBwcmVkaWNhdGVgIGNoZWNrcy5cbiAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHQ9W11dIFRoZSBpbml0aWFsIHJlc3VsdCB2YWx1ZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZUZsYXR0ZW4oYXJyYXksIGRlcHRoLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgcHJlZGljYXRlIHx8IChwcmVkaWNhdGUgPSBpc0ZsYXR0ZW5hYmxlKTtcbiAgcmVzdWx0IHx8IChyZXN1bHQgPSBbXSk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKGRlcHRoID4gMCAmJiBwcmVkaWNhdGUodmFsdWUpKSB7XG4gICAgICBpZiAoZGVwdGggPiAxKSB7XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGZsYXR0ZW4gYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIGJhc2VGbGF0dGVuKHZhbHVlLCBkZXB0aCAtIDEsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcnJheVB1c2gocmVzdWx0LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghaXNTdHJpY3QpIHtcbiAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGbGF0dGVuO1xuIiwidmFyIGJhc2VGaW5kSW5kZXggPSByZXF1aXJlKCcuL19iYXNlRmluZEluZGV4JyksXG4gICAgYmFzZUlzTmFOID0gcmVxdWlyZSgnLi9fYmFzZUlzTmFOJyksXG4gICAgc3RyaWN0SW5kZXhPZiA9IHJlcXVpcmUoJy4vX3N0cmljdEluZGV4T2YnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pbmRleE9mYCB3aXRob3V0IGBmcm9tSW5kZXhgIGJvdW5kcyBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZVxuICAgID8gc3RyaWN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleClcbiAgICA6IGJhc2VGaW5kSW5kZXgoYXJyYXksIGJhc2VJc05hTiwgZnJvbUluZGV4KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSW5kZXhPZjtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYU5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbnVtYmVyIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYE5hTmAsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTmFOO1xuIiwidmFyIFNldENhY2hlID0gcmVxdWlyZSgnLi9fU2V0Q2FjaGUnKSxcbiAgICBhcnJheUluY2x1ZGVzID0gcmVxdWlyZSgnLi9fYXJyYXlJbmNsdWRlcycpLFxuICAgIGFycmF5SW5jbHVkZXNXaXRoID0gcmVxdWlyZSgnLi9fYXJyYXlJbmNsdWRlc1dpdGgnKSxcbiAgICBjYWNoZUhhcyA9IHJlcXVpcmUoJy4vX2NhY2hlSGFzJyksXG4gICAgY3JlYXRlU2V0ID0gcmVxdWlyZSgnLi9fY3JlYXRlU2V0JyksXG4gICAgc2V0VG9BcnJheSA9IHJlcXVpcmUoJy4vX3NldFRvQXJyYXknKTtcblxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmlxQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuaXEoYXJyYXksIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgaXNDb21tb24gPSB0cnVlLFxuICAgICAgcmVzdWx0ID0gW10sXG4gICAgICBzZWVuID0gcmVzdWx0O1xuXG4gIGlmIChjb21wYXJhdG9yKSB7XG4gICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXNXaXRoO1xuICB9XG4gIGVsc2UgaWYgKGxlbmd0aCA+PSBMQVJHRV9BUlJBWV9TSVpFKSB7XG4gICAgdmFyIHNldCA9IGl0ZXJhdGVlID8gbnVsbCA6IGNyZWF0ZVNldChhcnJheSk7XG4gICAgaWYgKHNldCkge1xuICAgICAgcmV0dXJuIHNldFRvQXJyYXkoc2V0KTtcbiAgICB9XG4gICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICBpbmNsdWRlcyA9IGNhY2hlSGFzO1xuICAgIHNlZW4gPSBuZXcgU2V0Q2FjaGU7XG4gIH1cbiAgZWxzZSB7XG4gICAgc2VlbiA9IGl0ZXJhdGVlID8gW10gOiByZXN1bHQ7XG4gIH1cbiAgb3V0ZXI6XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUpIDogdmFsdWU7XG5cbiAgICB2YWx1ZSA9IChjb21wYXJhdG9yIHx8IHZhbHVlICE9PSAwKSA/IHZhbHVlIDogMDtcbiAgICBpZiAoaXNDb21tb24gJiYgY29tcHV0ZWQgPT09IGNvbXB1dGVkKSB7XG4gICAgICB2YXIgc2VlbkluZGV4ID0gc2Vlbi5sZW5ndGg7XG4gICAgICB3aGlsZSAoc2VlbkluZGV4LS0pIHtcbiAgICAgICAgaWYgKHNlZW5bc2VlbkluZGV4XSA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGl0ZXJhdGVlKSB7XG4gICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFpbmNsdWRlcyhzZWVuLCBjb21wdXRlZCwgY29tcGFyYXRvcikpIHtcbiAgICAgIGlmIChzZWVuICE9PSByZXN1bHQpIHtcbiAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVW5pcTtcbiIsInZhciBTZXQgPSByZXF1aXJlKCcuL19TZXQnKSxcbiAgICBub29wID0gcmVxdWlyZSgnLi9ub29wJyksXG4gICAgc2V0VG9BcnJheSA9IHJlcXVpcmUoJy4vX3NldFRvQXJyYXknKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc2V0IG9iamVjdCBvZiBgdmFsdWVzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYWRkIHRvIHRoZSBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgc2V0LlxuICovXG52YXIgY3JlYXRlU2V0ID0gIShTZXQgJiYgKDEgLyBzZXRUb0FycmF5KG5ldyBTZXQoWywtMF0pKVsxXSkgPT0gSU5GSU5JVFkpID8gbm9vcCA6IGZ1bmN0aW9uKHZhbHVlcykge1xuICByZXR1cm4gbmV3IFNldCh2YWx1ZXMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVTZXQ7XG4iLCIvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZyZWVHbG9iYWw7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzcHJlYWRhYmxlU3ltYm9sID0gU3ltYm9sID8gU3ltYm9sLmlzQ29uY2F0U3ByZWFkYWJsZSA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGZsYXR0ZW5hYmxlIGBhcmd1bWVudHNgIG9iamVjdCBvciBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmbGF0dGVuYWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0ZsYXR0ZW5hYmxlKHZhbHVlKSB7XG4gIHJldHVybiBpc0FycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkgfHxcbiAgICAhIShzcHJlYWRhYmxlU3ltYm9sICYmIHZhbHVlICYmIHZhbHVlW3NwcmVhZGFibGVTeW1ib2xdKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0ZsYXR0ZW5hYmxlO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uaW5kZXhPZmAgd2hpY2ggcGVyZm9ybXMgc3RyaWN0IGVxdWFsaXR5XG4gKiBjb21wYXJpc29ucyBvZiB2YWx1ZXMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gc3RyaWN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICB2YXIgaW5kZXggPSBmcm9tSW5kZXggLSAxLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0cmljdEluZGV4T2Y7XG4iLCJ2YXIgYmFzZUZsYXR0ZW4gPSByZXF1aXJlKCcuL19iYXNlRmxhdHRlbicpO1xuXG4vKipcbiAqIEZsYXR0ZW5zIGBhcnJheWAgYSBzaW5nbGUgbGV2ZWwgZGVlcC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmZsYXR0ZW4oWzEsIFsyLCBbMywgWzRdXSwgNV1dKTtcbiAqIC8vID0+IFsxLCAyLCBbMywgWzRdXSwgNV1cbiAqL1xuZnVuY3Rpb24gZmxhdHRlbihhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gIHJldHVybiBsZW5ndGggPyBiYXNlRmxhdHRlbihhcnJheSwgMSkgOiBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmbGF0dGVuO1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGB1bmRlZmluZWRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi4zLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5ub29wKTtcbiAqIC8vID0+IFt1bmRlZmluZWQsIHVuZGVmaW5lZF1cbiAqL1xuZnVuY3Rpb24gbm9vcCgpIHtcbiAgLy8gTm8gb3BlcmF0aW9uIHBlcmZvcm1lZC5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBub29wO1xuIiwidmFyIGJhc2VJdGVyYXRlZSA9IHJlcXVpcmUoJy4vX2Jhc2VJdGVyYXRlZScpLFxuICAgIGJhc2VVbmlxID0gcmVxdWlyZSgnLi9fYmFzZVVuaXEnKTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaXFgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IGluIGBhcnJheWAgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaFxuICogdW5pcXVlbmVzcyBpcyBjb21wdXRlZC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXMgZGV0ZXJtaW5lZCBieSB0aGVcbiAqIG9yZGVyIHRoZXkgb2NjdXIgaW4gdGhlIGFycmF5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDpcbiAqICh2YWx1ZSkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnVuaXFCeShbMi4xLCAxLjIsIDIuM10sIE1hdGguZmxvb3IpO1xuICogLy8gPT4gWzIuMSwgMS4yXVxuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy51bmlxQnkoW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCAneCcpO1xuICogLy8gPT4gW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH1dXG4gKi9cbmZ1bmN0aW9uIHVuaXFCeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYmFzZVVuaXEoYXJyYXksIGJhc2VJdGVyYXRlZShpdGVyYXRlZSwgMikpIDogW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdW5pcUJ5O1xuIiwiLyoqXG4gKiBDb252ZXJ0IFNHRiBmaWxlcyB0byBhIEpTIG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IHNnZiBBIHZhbGlkIFNHRiBmaWxlLlxuICogQHNlZSBodHRwOi8vd3d3LnJlZC1iZWFuLmNvbS9zZ2Yvc2dmNC5odG1sXG4gKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBTR0YgZmlsZSByZXByZXNlbnRlZCBhcyBhIEpTIG9iamVjdFxuICovXG5leHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKHNnZikge1xuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIHBhcnNlO1xuXHR2YXIgcGFyc2VyO1xuXHR2YXIgY29sbGVjdGlvbiA9IHt9O1xuXG5cdC8vIHRyYWNrcyB0aGUgY3VycmVudCBzZXF1ZW5jZVxuXHR2YXIgc2VxdWVuY2U7XG5cblx0Ly8gdHJhY2tzIHRoZSBjdXJyZW50IG5vZGVcblx0dmFyIG5vZGU7XG5cblx0Ly8gdHJhY2tzIHRoZSBsYXN0IFByb3BJZGVudFxuXHR2YXIgbGFzdFByb3BJZGVudDtcblxuXHQvLyBBIG1hcCBvZiBmdW5jdGlvbnMgdG8gcGFyc2UgdGhlIGRpZmZlcmVudCBjb21wb25lbnRzIG9mIGFuIFNHRiBmaWxlXG5cdHBhcnNlciA9IHtcblxuXHRcdGJlZ2luU2VxdWVuY2U6IGZ1bmN0aW9uIChzZ2YpIHtcblx0XHRcdHZhciBrZXkgPSAnc2VxdWVuY2VzJztcblxuXHRcdFx0Ly8gVG9wLWxldmVsIHNlcXVlbmNlcyBhcmUgZ2FtZVRyZWVzXG5cdFx0XHRpZiAoIXNlcXVlbmNlKSB7XG5cdFx0XHRcdHNlcXVlbmNlID0gY29sbGVjdGlvbjtcblx0XHRcdFx0a2V5ID0gJ2dhbWVUcmVlcyc7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChzZXF1ZW5jZS5nYW1lVHJlZXMpIHtcblx0XHRcdFx0a2V5ID0gJ2dhbWVUcmVlcyc7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBuZXdTZXF1ZW5jZSA9IHtcblx0XHRcdFx0cGFyZW50OiBzZXF1ZW5jZVxuXHRcdFx0fTtcblxuXHRcdFx0c2VxdWVuY2Vba2V5XSA9IHNlcXVlbmNlW2tleV0gfHwgW107XG5cdFx0XHRzZXF1ZW5jZVtrZXldLnB1c2gobmV3U2VxdWVuY2UpO1xuXHRcdFx0c2VxdWVuY2UgPSBuZXdTZXF1ZW5jZTtcblxuXHRcdFx0cmV0dXJuIHNnZi5zdWJzdHJpbmcoMSk7XG5cdFx0fSxcblxuXHRcdGVuZFNlcXVlbmNlOiBmdW5jdGlvbiAoc2dmKSB7XG5cdFx0XHRpZiAoc2VxdWVuY2UucGFyZW50KSB7XG5cdFx0XHRcdHNlcXVlbmNlID0gc2VxdWVuY2UucGFyZW50O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2VxdWVuY2UgPSBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHNnZi5zdWJzdHJpbmcoMSk7XG5cdFx0fSxcblxuXHRcdG5vZGU6IGZ1bmN0aW9uIChzZ2YpIHtcblx0XHRcdG5vZGUgPSB7fTtcblx0XHRcdHNlcXVlbmNlLm5vZGVzID0gc2VxdWVuY2Uubm9kZXMgfHwgW107XG5cdFx0XHRzZXF1ZW5jZS5ub2Rlcy5wdXNoKG5vZGUpO1xuXHRcdFx0cmV0dXJuIHNnZi5zdWJzdHJpbmcoMSk7XG5cdFx0fSxcblxuXHRcdHByb3BlcnR5OiBmdW5jdGlvbiAoc2dmKSB7XG5cdFx0XHR2YXIgcHJvcFZhbHVlO1xuXG5cdFx0XHQvLyBTZWFyY2ggZm9yIHRoZSBmaXJzdCB1bmVzY2FwZWQgXVxuXHRcdFx0dmFyIGZpcnN0UHJvcEVuZCA9IHNnZi5tYXRjaCgvKFteXFxcXFxcXV18XFxcXCgufFxcbnxcXHIpKSpcXF0vKTtcblxuXHRcdFx0aWYgKCFmaXJzdFByb3BFbmQubGVuZ3RoKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignbWFsZm9ybWVkIHNnZicpO1xuXHRcdFx0fVxuXG5cdFx0XHRmaXJzdFByb3BFbmQgPSBmaXJzdFByb3BFbmRbMF0ubGVuZ3RoO1xuXG5cdFx0XHR2YXIgcHJvcGVydHkgPSBzZ2Yuc3Vic3RyaW5nKDAsIGZpcnN0UHJvcEVuZCk7XG5cdFx0XHR2YXIgcHJvcFZhbHVlQmVnaW4gPSBwcm9wZXJ0eS5pbmRleE9mKCdbJyk7XG5cdFx0XHR2YXIgcHJvcElkZW50ID0gcHJvcGVydHkuc3Vic3RyaW5nKDAsIHByb3BWYWx1ZUJlZ2luKTtcblxuXHRcdFx0Ly8gUG9pbnQgbGlzdHMgZG9uJ3QgZGVjbGFyZSBhIFByb3BJZGVudCBmb3IgZWFjaCBQcm9wVmFsdWVcblx0XHRcdC8vIEluc3RlYWQsIHRoZXkgc2hvdWxkIHVzZSB0aGUgbGFzdCBkZWNsYXJlZCBwcm9wZXJ0eVxuXHRcdFx0Ly8gU2VlOiBodHRwOi8vd3d3LnJlZC1iZWFuLmNvbS9zZ2Yvc2dmNC5odG1sI21vdmUvcG9zXG5cdFx0XHRpZiAoIXByb3BJZGVudCkge1xuXHRcdFx0XHRwcm9wSWRlbnQgPSBsYXN0UHJvcElkZW50O1xuXG5cdFx0XHRcdC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IHByb3BlcnR5IGluIGEgbGlzdCBvZiBtdWx0aXBsZVxuXHRcdFx0XHQvLyBwcm9wZXJ0aWVzLCB3ZSBuZWVkIHRvIHdyYXAgdGhlIFByb3BWYWx1ZSBpbiBhbiBhcnJheVxuXHRcdFx0XHRpZiAoIUFycmF5LmlzQXJyYXkobm9kZVtwcm9wSWRlbnRdKSkge1xuXHRcdFx0XHRcdG5vZGVbcHJvcElkZW50XSA9IFtub2RlW3Byb3BJZGVudF1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGxhc3RQcm9wSWRlbnQgPSBwcm9wSWRlbnQ7XG5cblx0XHRcdHByb3BWYWx1ZSA9IHByb3BlcnR5LnN1YnN0cmluZyhwcm9wVmFsdWVCZWdpbiArIDEsIHByb3BlcnR5Lmxlbmd0aCAtIDEpO1xuXG5cdFx0XHQvLyBXZSBoYXZlIG5vIHByb2JsZW0gcGFyc2luZyBQcm9wSWRlbnRzIG9mIGFueSBsZW5ndGgsIGJ1dCB0aGUgc3BlY1xuXHRcdFx0Ly8gc2F5cyB0aGV5IHNob3VsZCBiZSBubyBsb25nZXIgdGhhbiB0d28gY2hhcmFjdGVycy5cblx0XHRcdC8vXG5cdFx0XHQvLyBodHRwOi8vd3d3LnJlZC1iZWFuLmNvbS9zZ2Yvc2dmNC5odG1sIzIuMlxuXHRcdFx0aWYgKHByb3BJZGVudC5sZW5ndGggPiAyKSB7XG5cdFx0XHRcdC8vIFRPRE86IFdoYXQncyB0aGUgYmVzdCB3YXkgdG8gaXNzdWUgYSB3YXJuaW5nP1xuXHRcdFx0XHRjb25zb2xlLndhcm4oXG5cdFx0XHRcdFx0J1NHRiBQcm9wSWRlbnRzIHNob3VsZCBiZSBubyBsb25nZXIgdGhhbiB0d28gY2hhcmFjdGVyczonLCBwcm9wSWRlbnRcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkobm9kZVtwcm9wSWRlbnRdKSkge1xuXHRcdFx0XHRub2RlW3Byb3BJZGVudF0ucHVzaChwcm9wVmFsdWUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bm9kZVtwcm9wSWRlbnRdID0gcHJvcFZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc2dmLnN1YnN0cmluZyhmaXJzdFByb3BFbmQpO1xuXHRcdH0sXG5cblx0XHQvLyBXaGl0ZXNwYWNlLCB0YWJzLCBvciBhbnl0aGluZyBlbHNlIHdlIGRvbid0IHJlY29nbml6ZVxuXHRcdHVucmVjb2duaXplZDogZnVuY3Rpb24gKHNnZikge1xuXG5cdFx0XHQvLyBNYXJjaCBhaGVhZCB0byB0aGUgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdHJldHVybiBzZ2Yuc3Vic3RyaW5nKDEpO1xuXHRcdH1cblx0fTtcblxuXHQvLyBQcm9jZXNzZXMgYW4gU0dGIGZpbGUgY2hhcmFjdGVyIGJ5IGNoYXJhY3RlclxuXHRwYXJzZSA9IGZ1bmN0aW9uIChzZ2YpIHtcblx0XHR3aGlsZSAoc2dmKSB7XG5cdFx0XHR2YXIgaW5pdGlhbCA9IHNnZi5zdWJzdHJpbmcoMCwgMSk7XG5cdFx0XHR2YXIgdHlwZTtcblxuXHRcdFx0Ly8gVXNlIHRoZSBpbml0aWFsICh0aGUgZmlyc3QgY2hhcmFjdGVyIGluIHRoZSByZW1haW5pbmcgc2dmIGZpbGUpIHRvXG5cdFx0XHQvLyBkZWNpZGUgd2hpY2ggcGFyc2VyIGZ1bmN0aW9uIHRvIHVzZVxuXHRcdFx0aWYgKGluaXRpYWwgPT09ICcoJykge1xuXHRcdFx0XHR0eXBlID0gJ2JlZ2luU2VxdWVuY2UnO1xuXHRcdFx0fSBlbHNlIGlmIChpbml0aWFsID09PSAnKScpIHtcblx0XHRcdFx0dHlwZSA9ICdlbmRTZXF1ZW5jZSc7XG5cdFx0XHR9IGVsc2UgaWYgKGluaXRpYWwgPT09ICc7Jykge1xuXHRcdFx0XHR0eXBlID0gJ25vZGUnO1xuXHRcdFx0fSBlbHNlIGlmIChpbml0aWFsLnNlYXJjaCgvW0EtWlxcW10vKSAhPT0gLTEpIHtcblx0XHRcdFx0dHlwZSA9ICdwcm9wZXJ0eSc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0eXBlID0gJ3VucmVjb2duaXplZCc7XG5cdFx0XHR9XG5cblx0XHRcdHNnZiA9IHBhcnNlclt0eXBlXShzZ2YpO1xuXHRcdH1cblxuXHRcdHJldHVybiBjb2xsZWN0aW9uO1xuXHR9O1xuXG5cdC8vIEJlZ2luIHBhcnNpbmcgdGhlIFNHRiBmaWxlXG5cdHJldHVybiBwYXJzZShzZ2YpO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhbiBTR0YgZmlsZSBmcm9tIGEgU21hcnRHYW1lIFJlY29yZCBKYXZhU2NyaXB0IE9iamVjdFxuICogQHBhcmFtIHtvYmplY3R9IHJlY29yZCBBIHJlY29yZCBvYmplY3QuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSByZWNvcmQgYXMgYSBzdHJpbmcgc3VpdGFibGUgZm9yIHNhdmluZyBhcyBhbiBTR0YgZmlsZVxuICovXG5leHBvcnRzLmdlbmVyYXRlID0gZnVuY3Rpb24gKHJlY29yZCkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0ZnVuY3Rpb24gc3RyaW5naWZ5U2VxdWVuY2VzKHNlcXVlbmNlcykge1xuXHRcdHZhciBjb250ZW50cyA9ICcnO1xuXG5cdFx0c2VxdWVuY2VzLmZvckVhY2goZnVuY3Rpb24gKHNlcXVlbmNlKSB7XG5cdFx0XHRjb250ZW50cyArPSAnKCc7XG5cblx0XHRcdC8vIFBhcnNlIGFsbCBub2RlcyBpbiB0aGlzIHNlcXVlbmNlXG5cdFx0XHRpZiAoc2VxdWVuY2Uubm9kZXMpIHtcblx0XHRcdFx0c2VxdWVuY2Uubm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuXHRcdFx0XHRcdHZhciBub2RlU3RyaW5nID0gJzsnO1xuXHRcdFx0XHRcdGZvciAodmFyIHByb3BlcnR5IGluIG5vZGUpIHtcblx0XHRcdFx0XHRcdGlmIChub2RlLmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuXHRcdFx0XHRcdFx0XHR2YXIgcHJvcCA9IG5vZGVbcHJvcGVydHldO1xuXHRcdFx0XHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheShwcm9wKSkge1xuXHRcdFx0XHRcdFx0XHRcdHByb3AgPSBwcm9wLmpvaW4oJ11bJyk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0bm9kZVN0cmluZyArPSBwcm9wZXJ0eSArICdbJyArIHByb3AgKyAnXSc7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNvbnRlbnRzICs9IG5vZGVTdHJpbmc7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYWxsIHRoZSBmdW5jdGlvbiB3ZSdyZSBpbiByZWN1cnNpdmVseSBmb3IgYW55IGNoaWxkIHNlcXVlbmNlc1xuXHRcdFx0aWYgKHNlcXVlbmNlLnNlcXVlbmNlcykge1xuXHRcdFx0XHRjb250ZW50cyArPSBzdHJpbmdpZnlTZXF1ZW5jZXMoc2VxdWVuY2Uuc2VxdWVuY2VzKTtcblx0XHRcdH1cblxuXHRcdFx0Y29udGVudHMgKz0gJyknO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIGNvbnRlbnRzO1xuXHR9XG5cblx0cmV0dXJuIHN0cmluZ2lmeVNlcXVlbmNlcyhyZWNvcmQuZ2FtZVRyZWVzKTtcbn07XG5cbiIsIi8qKlxuICogSW50ZXJhY3Qgd2l0aCBzbWFydGdhbWUgb2JqZWN0cy5cbiAqIEBwYXJhbSB7b2JqZWN0fSBzbWFydGdhbWUgQSBKUyBPYmplY3QgcmVwcmVzZW50aW5nIGEgc21hcnRnYW1lXG4gKiBAc2VlIGh0dHA6Ly93d3cucmVkLWJlYW4uY29tL3NnZi9zZ2Y0Lmh0bWxcbiAqIEByZXR1cm4ge29iamVjdH0gQW4gb2JqZWN0IHdpdGggbWV0aG9kcyBmb3IgbmF2aWdhdGluZyBhbmQgbWFuaXB1bGF0aW5nIGFcbiAqIHNtYXJ0Z2FtZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzbWFydGdhbWUpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBzZXF1ZW5jZTtcblx0dmFyIG5vZGU7XG5cblx0dmFyIFNtYXJ0Z2FtZXIgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5pbml0KCk7XG5cdH07XG5cblx0U21hcnRnYW1lci5wcm90b3R5cGUgPSB7XG5cdFx0aW5pdDogZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKHNtYXJ0Z2FtZSkge1xuXHRcdFx0XHR0aGlzLmdhbWUgPSBzbWFydGdhbWUuZ2FtZVRyZWVzWzBdO1xuXHRcdFx0XHR0aGlzLnJlc2V0KCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vIExvYWQgYSBzbWFydGdhbWUgdG8gbWFrZSBpdCBwb3NzaWJsZSB0byBsb2FkIG5ldyBnYW1lcyBvciBhZGQgb25lIGFmdGVyXG5cdFx0Ly8gaW5pdGlhbGl6YXRpb24sIGlmIGRlc2lyZWRcblx0XHRsb2FkOiBmdW5jdGlvbiAobmV3U21hcnRnYW1lKSB7XG5cdFx0XHRzbWFydGdhbWUgPSBuZXdTbWFydGdhbWU7XG5cdFx0XHR0aGlzLmluaXQoKTtcblx0XHR9LFxuXG5cdFx0Ly8gSGF2aW5nIG11bHRpcGxlIGdhbWVzIGluIGEgY29sbGVjdGlvbiBpcyBub3QgY29tbW9uLCBidXQgaXQncyBwYXJ0IG9mXG5cdFx0Ly8gdGhlIHNwZWNcblx0XHRnYW1lczogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIHNtYXJ0Z2FtZS5nYW1lVHJlZXM7XG5cdFx0fSxcblxuXHRcdHNlbGVjdEdhbWU6IGZ1bmN0aW9uIChpKSB7XG5cdFx0XHRpZiAoaSA8IHNtYXJ0Z2FtZS5nYW1lVHJlZXMubGVuZ3RoKSB7XG5cdFx0XHRcdHRoaXMuZ2FtZSA9IHNtYXJ0Z2FtZS5nYW1lVHJlZXNbaV07XG5cdFx0XHRcdHRoaXMucmVzZXQoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcigndGhlIGNvbGxlY3Rpb24gZG9lc25cXCd0IGNvbnRhaW4gdGhhdCBtYW55IGdhbWVzJyk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cblx0XHRyZXNldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0c2VxdWVuY2UgPSB0aGlzLmdhbWU7XG5cdFx0XHRub2RlID0gc2VxdWVuY2Uubm9kZXNbMF07XG5cdFx0XHR0aGlzLnBhdGggPSB7IG06IDAgfTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXHRcdGdldFNtYXJ0Z2FtZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIHNtYXJ0Z2FtZTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJuIGFueSB2YXJpYXRpb25zIGF2YWlsYWJsZSBhdCB0aGUgY3VycmVudCBtb3ZlXG5cdFx0ICoqL1xuXHRcdHZhcmlhdGlvbnM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmIChzZXF1ZW5jZSkge1xuXHRcdFx0XHR2YXIgbG9jYWxOb2RlcyA9IHNlcXVlbmNlLm5vZGVzO1xuXHRcdFx0XHR2YXIgbG9jYWxJbmRleCA9IChsb2NhbE5vZGVzKSA/IGxvY2FsTm9kZXMuaW5kZXhPZihub2RlKSA6IG51bGw7XG5cblx0XHRcdFx0aWYgKGxvY2FsTm9kZXMpIHtcblx0XHRcdFx0XHRpZiAobG9jYWxJbmRleCA9PT0gKGxvY2FsTm9kZXMubGVuZ3RoIC0gMSkpIHtcblx0XHRcdFx0XHRcdHJldHVybiBzZXF1ZW5jZS5zZXF1ZW5jZXMgfHwgW107XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogR28gdG8gdGhlIG5leHQgbW92ZVxuXHRcdCAqKi9cblx0XHRuZXh0OiBmdW5jdGlvbiAodmFyaWF0aW9uKSB7XG5cdFx0XHR2YXJpYXRpb24gPSB2YXJpYXRpb24gfHwgMDtcblxuXHRcdFx0dmFyIGxvY2FsTm9kZXMgPSBzZXF1ZW5jZS5ub2Rlcztcblx0XHRcdHZhciBsb2NhbEluZGV4ID0gKGxvY2FsTm9kZXMpID8gbG9jYWxOb2Rlcy5pbmRleE9mKG5vZGUpIDogbnVsbDtcblxuXHRcdFx0Ly8gSWYgdGhlcmUgYXJlIG5vIGFkZGl0aW9uYWwgbm9kZXMgaW4gdGhpcyBzZXF1ZW5jZSxcblx0XHRcdC8vIGFkdmFuY2UgdG8gdGhlIG5leHQgb25lXG5cdFx0XHRpZiAobG9jYWxJbmRleCA9PT0gbnVsbCB8fCBsb2NhbEluZGV4ID49IChsb2NhbE5vZGVzLmxlbmd0aCAtIDEpKSB7XG5cdFx0XHRcdGlmIChzZXF1ZW5jZS5zZXF1ZW5jZXMpIHtcblx0XHRcdFx0XHRpZiAoc2VxdWVuY2Uuc2VxdWVuY2VzW3ZhcmlhdGlvbl0pIHtcblx0XHRcdFx0XHRcdHNlcXVlbmNlID0gc2VxdWVuY2Uuc2VxdWVuY2VzW3ZhcmlhdGlvbl07XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNlcXVlbmNlID0gc2VxdWVuY2Uuc2VxdWVuY2VzWzBdO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG5vZGUgPSBzZXF1ZW5jZS5ub2Rlc1swXTtcblxuXHRcdFx0XHRcdC8vIE5vdGUgdGhlIGZvcmsgY2hvc2VuIGZvciB0aGlzIHZhcmlhdGlvbiBpbiB0aGUgcGF0aFxuXHRcdFx0XHRcdHRoaXMucGF0aFt0aGlzLnBhdGgubV0gPSB2YXJpYXRpb247XG5cdFx0XHRcdFx0dGhpcy5wYXRoLm0gKz0gMTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBFbmQgb2Ygc2VxdWVuY2UgLyBnYW1lXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5vZGUgPSBsb2NhbE5vZGVzW2xvY2FsSW5kZXggKyAxXTtcblx0XHRcdFx0dGhpcy5wYXRoLm0gKz0gMTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEdvIHRvIHRoZSBwcmV2aW91cyBtb3ZlXG5cdFx0ICoqL1xuXHRcdHByZXZpb3VzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgbG9jYWxOb2RlcyA9IHNlcXVlbmNlLm5vZGVzO1xuXHRcdFx0dmFyIGxvY2FsSW5kZXggPSAobG9jYWxOb2RlcykgPyBsb2NhbE5vZGVzLmluZGV4T2Yobm9kZSkgOiBudWxsO1xuXG5cdFx0XHQvLyBEZWxldGUgYW55IHZhcmlhdGlvbiBmb3JrcyBhdCB0aGlzIHBvaW50XG5cdFx0XHQvLyBUT0RPOiBNYWtlIHRoaXMgY29uZmlndXJhYmxlLi4uIHdlIHNob3VsZCBrZWVwIHRoaXMgaWYgd2UncmVcblx0XHRcdC8vIHJlbWVtYmVyaW5nIGNob3NlbiBwYXRoc1xuXHRcdFx0ZGVsZXRlIHRoaXMucGF0aFt0aGlzLnBhdGgubV07XG5cblx0XHRcdGlmICghbG9jYWxJbmRleCB8fCBsb2NhbEluZGV4ID09PSAwKSB7XG5cdFx0XHRcdGlmIChzZXF1ZW5jZS5wYXJlbnQgJiYgIXNlcXVlbmNlLnBhcmVudC5nYW1lVHJlZXMpIHtcblx0XHRcdFx0XHRzZXF1ZW5jZSA9IHNlcXVlbmNlLnBhcmVudDtcblx0XHRcdFx0XHRpZiAoc2VxdWVuY2Uubm9kZXMpIHtcblx0XHRcdFx0XHRcdG5vZGUgPSBzZXF1ZW5jZS5ub2Rlc1tzZXF1ZW5jZS5ub2Rlcy5sZW5ndGggLSAxXTtcblx0XHRcdFx0XHRcdHRoaXMucGF0aC5tIC09IDE7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG5vZGUgPSBudWxsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBBbHJlYWR5IGF0IHRoZSBiZWdpbm5pbmdcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bm9kZSA9IGxvY2FsTm9kZXNbbG9jYWxJbmRleCAtIDFdO1xuXHRcdFx0XHR0aGlzLnBhdGgubSAtPSAxO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0Ly8gR28gdG8gdGhlIGxhc3QgbW92ZSBvZiB0aGUgZ2FtZVxuXHRcdGxhc3Q6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciB0b3RhbE1vdmVzID0gdGhpcy50b3RhbE1vdmVzKCk7XG5cblx0XHRcdHdoaWxlKHRoaXMucGF0aC5tIDwgdG90YWxNb3Zlcykge1xuXHRcdFx0XHR0aGlzLm5leHQoKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXHRcdC8vIEdvIHRvIHRoZSBmaXJzdCBtb3ZlIG9mIHRoZSBnYW1lXG5cdFx0Zmlyc3Q6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMucmVzZXQoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBHbyB0byBhIHBhcnRpY3VsYXIgbW92ZSwgc3BlY2lmaWVkIGFzIGFcblx0XHQgKiBhKSBudW1iZXJcblx0XHQgKiBiKSBwYXRoIHN0cmluZ1xuXHRcdCAqIGMpIHBhdGggb2JqZWN0XG5cdFx0ICoqL1xuXHRcdGdvVG86IGZ1bmN0aW9uIChwYXRoKSB7XG5cdFx0XHRpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdHBhdGggPSB0aGlzLnBhdGhUcmFuc2Zvcm0ocGF0aCwgJ29iamVjdCcpO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgcGF0aCA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0cGF0aCA9IHsgbTogcGF0aCB9O1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnJlc2V0KCk7XG5cblx0XHRcdHZhciBuID0gbm9kZTtcblxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLm0gJiYgbjsgaSArPSAxKSB7XG5cdFx0XHRcdC8vIENoZWNrIGZvciBhIHZhcmlhdGlvbiBpbiB0aGUgcGF0aCBmb3IgdGhlIHVwY29taW5nIG1vdmVcblx0XHRcdFx0dmFyIHZhcmlhdGlvbiA9IHBhdGhbaSArIDFdIHx8IDA7XG5cdFx0XHRcdG4gPSB0aGlzLm5leHQodmFyaWF0aW9uKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXHRcdGdldEdhbWVJbmZvOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nYW1lLm5vZGVzWzBdO1xuXHRcdH0sXG5cblx0XHQvLyBQcm92aWRlIHRoZSBjdXJyZW50IG5vZGVcblx0XHRub2RlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gbm9kZTtcblx0XHR9LFxuXG5cdFx0Ly8gR2V0IHRoZSB0b3RhbCBudW1iZXIgb2YgbW92ZXMgaW4gYSBnYW1lXG5cdFx0dG90YWxNb3ZlczogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGxvY2FsU2VxdWVuY2UgPSB0aGlzLmdhbWU7XG5cdFx0XHR2YXIgbW92ZXMgPSAwO1xuXHRcdFx0d2hpbGUobG9jYWxTZXF1ZW5jZSkge1xuXHRcdFx0XHRtb3ZlcyArPSBsb2NhbFNlcXVlbmNlLm5vZGVzLmxlbmd0aDtcblxuXHRcdFx0XHRpZiAobG9jYWxTZXF1ZW5jZS5zZXF1ZW5jZXMpIHtcblx0XHRcdFx0XHRsb2NhbFNlcXVlbmNlID0gbG9jYWxTZXF1ZW5jZS5zZXF1ZW5jZXNbMF07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bG9jYWxTZXF1ZW5jZSA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVE9ETzogUmlnaHQgbm93IHdlJ3JlICphc3N1bWluZyogdGhhdCB0aGUgcm9vdCBub2RlIGRvZXNuJ3QgaGF2ZSBhXG5cdFx0XHQvLyBtb3ZlIGluIGl0LCB3aGljaCBpcyAqcmVjb21tZW5kZWQqIGJ1dCBub3QgcmVxdWlyZWQgcHJhY3RpY2UuXG5cdFx0XHQvLyBAc2VlIGh0dHA6Ly93d3cucmVkLWJlYW4uY29tL3NnZi9zZ2Y0Lmh0bWxcblx0XHRcdC8vIFwiTm90ZTogaXQncyBiYWQgc3R5bGUgdG8gaGF2ZSBtb3ZlIHByb3BlcnRpZXMgaW4gcm9vdCBub2Rlcy5cblx0XHRcdC8vIChpdCBpc24ndCBmb3JiaWRkZW4gdGhvdWdoKVwiXG5cdFx0XHRyZXR1cm4gbW92ZXMgLSAxO1xuXHRcdH0sXG5cblx0XHQvLyBHZXQgb3Igc2V0IGEgY29tbWVudCBvbiB0aGUgY3VycmVudCBub2RlXG5cdFx0Ly8gQHNlZSBodHRwOi8vd3d3LnJlZC1iZWFuLmNvbS9zZ2Yvc2dmNC5odG1sI3RleHRcblx0XHRjb21tZW50OiBmdW5jdGlvbiAodGV4dCkge1xuXHRcdFx0aWYgKHR5cGVvZiB0ZXh0ID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHQvLyBVbmVzY2FwZSBjaGFyYWN0ZXJzXG5cdFx0XHRcdGlmIChub2RlLkMpIHtcblx0XHRcdFx0XHRyZXR1cm4gbm9kZS5DLnJlcGxhY2UoL1xcXFwoW1xcXFw6XFxdXSkvZywgJyQxJyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuICcnO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBFc2NhcGUgY2hhcmFjdGVyc1xuXHRcdFx0XHRub2RlLkMgPSB0ZXh0LnJlcGxhY2UoL1tcXFxcOlxcXV0vZywgJ1xcXFwkJicpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBUcmFuc2xhdGUgYWxwaGEgY29vcmRpbmF0ZXMgaW50byBhbiBhcnJheVxuXHRcdCAqIEBwYXJhbSBzdHJpbmcgYWxwaGFDb29yZGluYXRlc1xuXHRcdCAqIEByZXR1cm4gYXJyYXkgW3gsIHldXG5cdFx0ICoqL1xuXHRcdHRyYW5zbGF0ZUNvb3JkaW5hdGVzOiBmdW5jdGlvbiAoYWxwaGFDb29yZGluYXRlcykge1xuXHRcdFx0dmFyIGNvb3JkaW5hdGVMYWJlbHMgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xuXHRcdFx0dmFyIGludGVyc2VjdGlvbiA9IFtdO1xuXG5cdFx0XHRpbnRlcnNlY3Rpb25bMF0gPSBjb29yZGluYXRlTGFiZWxzLmluZGV4T2YoYWxwaGFDb29yZGluYXRlcy5zdWJzdHJpbmcoMCwgMSkpO1xuXHRcdFx0aW50ZXJzZWN0aW9uWzFdID0gY29vcmRpbmF0ZUxhYmVscy5pbmRleE9mKGFscGhhQ29vcmRpbmF0ZXMuc3Vic3RyaW5nKDEsIDIpKTtcblxuXHRcdFx0cmV0dXJuIGludGVyc2VjdGlvbjtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQ29udmVydCBwYXRoIG9iamVjdHMgdG8gc3RyaW5ncyBhbmQgcGF0aCBzdHJpbmdzIHRvIG9iamVjdHNcblx0XHQgKiovXG5cdFx0cGF0aFRyYW5zZm9ybTogZnVuY3Rpb24gKGlucHV0LCBvdXRwdXRUeXBlLCB2ZXJib3NlKSB7XG5cdFx0XHR2YXIgb3V0cHV0O1xuXG5cdFx0XHQvLyBJZiBubyBvdXRwdXQgdHlwZSBoYXMgYmVlbiBzcGVjaWZpZWQsIHRyeSB0byBzZXQgaXQgdG8gdGhlXG5cdFx0XHQvLyBvcHBvc2l0ZSBvZiB0aGUgaW5wdXRcblx0XHRcdGlmICh0eXBlb2Ygb3V0cHV0VHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0b3V0cHV0VHlwZSA9ICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSA/ICdvYmplY3QnIDogJ3N0cmluZyc7XG5cdFx0XHR9XG5cblx0XHRcdC8qKlxuXHRcdFx0ICogVHVybiBhIHBhdGggb2JqZWN0IGludG8gYSBzdHJpbmcuXG5cdFx0XHQgKi9cblx0XHRcdGZ1bmN0aW9uIHN0cmluZ2lmeShpbnB1dCkge1xuXHRcdFx0XHRpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdHJldHVybiBpbnB1dDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICghaW5wdXQpIHtcblx0XHRcdFx0XHRyZXR1cm4gJyc7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRvdXRwdXQgPSBpbnB1dC5tO1xuXG5cdFx0XHRcdHZhciB2YXJpYXRpb25zID0gW107XG5cdFx0XHRcdGZvciAodmFyIGtleSBpbiBpbnB1dCkge1xuXHRcdFx0XHRcdGlmIChpbnB1dC5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIGtleSAhPT0gJ20nKSB7XG5cdFx0XHRcdFx0XHQvLyBPbmx5IHNob3cgdmFyaWF0aW9ucyB0aGF0IGFyZSBub3QgdGhlIHByaW1hcnkgb25lLCBzaW5jZVxuXHRcdFx0XHRcdFx0Ly8gcHJpbWFyeSB2YXJpYXRpb25zIGFyZSBjaG9zZW4gYnkgZGVmYXVsdFxuXHRcdFx0XHRcdFx0aWYgKGlucHV0W2tleV0gPiAwKSB7XG5cdFx0XHRcdFx0XHRcdGlmICh2ZXJib3NlKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyaWF0aW9ucy5wdXNoKCcsIHZhcmlhdGlvbiAnICsgaW5wdXRba2V5XSArICcgYXQgbW92ZSAnICsga2V5KTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR2YXJpYXRpb25zLnB1c2goJy0nICsga2V5ICsgJzonICsgaW5wdXRba2V5XSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRvdXRwdXQgKz0gdmFyaWF0aW9ucy5qb2luKCcnKTtcblx0XHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHRcdH1cblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUdXJuIGEgcGF0aCBzdHJpbmcgaW50byBhbiBvYmplY3QuXG5cdFx0XHQgKi9cblx0XHRcdGZ1bmN0aW9uIHBhcnNlKGlucHV0KSB7XG5cdFx0XHRcdGlmICh0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdFx0aW5wdXQgPSBzdHJpbmdpZnkoaW5wdXQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCFpbnB1dCkge1xuXHRcdFx0XHRcdHJldHVybiB7IG06IDAgfTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBwYXRoID0gaW5wdXQuc3BsaXQoJy0nKTtcblx0XHRcdFx0b3V0cHV0ID0ge1xuXHRcdFx0XHRcdG06IE51bWJlcihwYXRoLnNoaWZ0KCkpXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0aWYgKHBhdGgubGVuZ3RoKSB7XG5cdFx0XHRcdFx0cGF0aC5mb3JFYWNoKGZ1bmN0aW9uICh2YXJpYXRpb24sIGkpIHtcblx0XHRcdFx0XHRcdHZhcmlhdGlvbiA9IHZhcmlhdGlvbi5zcGxpdCgnOicpO1xuXHRcdFx0XHRcdFx0b3V0cHV0W051bWJlcih2YXJpYXRpb25bMF0pXSA9IHBhcnNlSW50KHZhcmlhdGlvblsxXSwgMTApO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG91dHB1dFR5cGUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdG91dHB1dCA9IHN0cmluZ2lmeShpbnB1dCk7XG5cdFx0XHR9IGVsc2UgaWYgKG91dHB1dFR5cGUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdG91dHB1dCA9IHBhcnNlKGlucHV0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dCA9IHVuZGVmaW5lZDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIG5ldyBTbWFydGdhbWVyKCk7XG59O1xuIiwiLyogZ2xvYmFscyBtb2R1bGU6IGZhbHNlLCByZXF1aXJlOiBmYWxzZVxyXG5cclxuKi9cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9ICh2YXJpYW50U2dmLCBvcHRpb25zKSA9PiB7XHJcbiAgJ3VzZSBzdHJpY3QnIFxyXG4gIGxldCB0cmFuc2Zvcm1lciA9IHJlcXVpcmUoJy4vdHJhbnNmb3JtZXInKVxyXG5cdCwgIHNtYXJ0Z2FtZSA9IHJlcXVpcmUoJ3NtYXJ0Z2FtZScpXHJcblx0LCAgc21hcnRnYW1lciA9IHJlcXVpcmUoJ3NtYXJ0Z2FtZXInKVxyXG5cdCwgIHRHbyA9IHJlcXVpcmUoJ2dvLXZhcmlhbnRzLWVuZ2luZScpKClcclxuICAgIHJldHVybiAodHJhbnNmb3JtZXIob3B0aW9ucykpLnRyYW5zZm9ybShcclxuICBcclxuICAgIHZhcmlhbnRTZ2ZcclxuICAgICwgdEdvXHJcbiAgICAsIHNtYXJ0Z2FtZVxyXG4gICAgLCBzbWFydGdhbWVyXHJcbiAgICApXHJcbiAgfSIsIu+7vy8qIGdsb2JhbHMgbW9kdWxlOiBmYWxzZSwgcmVxdWlyZTogZmFsc2VcclxuXHJcbiovXHJcbi8qKlxyXG4gKiBQcm92aWRlcyBhIGZ1bmN0aW9uIGZvciB0cmFuc2Zvcm1pbmcgU0dGIGZvciBhIEdvIHZhcmlhbnQgdG8gU0dGIGZvciBhIHN0YW5kYXJkIEdvIHZpZXdlcjsgYWxzbyBwcm92aWRlcyBhIGZ1bmN0aW9uIGZvciB0aGUgaW52ZXJzZSB0cmFuc2Zvcm1hdGlvbi5cclxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zPV0gRGVmaW5lcyB2YXJpb3VzIG9wdGlvbnMgZm9yIHRoZSBvdXRwdXQgU0dGLiBNYXkgYmUgb21pdHRlZCwgaW4gd2hpY2ggY2FzZSB0aGUgZGVmYXVsdCBvcHRpb25zIChzZWUgYmVsb3cpIGFyZSB1c2VkLlxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmFkZENvbW1lbnRzID0gZmFsc2VdIFdoZW4gZmxhZ2dlZCwgY29tbWVudHMgYXJlIGFkZGVkIHRvIGVhY2ggbm9kZSBnaXZpbmcgdGhlIG1vdmUgbnVtYmVyIGFuZCB0aGUgbnVtYmVyIG9mIHN0b25lcyBjYXB0dXJlZCBieSBCbGFjayBhbmQgV2hpdGUuXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYWRkTW92ZU51bWJlciA9IGZhbHNlXSBXaGVuIGZsYWdnZWQsIE1OIGluZm9ybWF0aW9uIGlzIGFkZGVkIHRvIGVhY2ggbm9kZS5cclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1vdmVUeXBlID0gMl0gQ29udHJvbHMgaG93IG1vdmVzIGFyZSByZXByZXNlbnRlZCBpbiB0aGUgdHJhbnNmb3JtZWQgU0dGLiBFeGFtcGxlcyBnaXZlbiBmb3IgYmxhY2sgbW92ZXMsIHNvIHdpdGggb3B0aW9uIDIgYSB3aGl0ZSBtb3ZlIGlzIHJlcHJlc2VudGVkIGJ5IGBXW3BvaW50XUFXW290aGVyUG9pbnRzXWAuIE9wdGlvbnM6IFxyXG4gKiAwOiBgQUJbcG9pbnRzXWA7XHJcbiAqIDE6IGBBQltwb2ludHNdQltdYCAoc2FtZSBhcyBmb3IgYG1vdmVUeXBlPT09MGAgYnV0IHdpdGggdGhlIOKAnHBhc3PigJ0gKOKAnEJbXeKAnSk7XHJcbiAqIDI6IGBCW3BvaW50XUFCW290aGVyUG9pbnRzXWAgd2hlcmUgYHBvaW50YCBpcyB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIG1vdmUgaW4gdGhlIG1haW4gYm9hcmQgKGEgc2luZ2xlIHBvaW50KSwgYW5kIGBvdGhlclBvaW50c2AgaXMgYW4gYXJyYXkgb2YgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBtb3ZlIGluIHRoZSB3cmFwYXJvdW5kIGFyZWEuO1xyXG4gKiAzOiBgQltwb2ludHNdYDtcclxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm1hcmtMYXN0TW92ZSA9IG51bGxdIEdpdmVzIHRoZSBTR0Ygbm9kZSB0byBiZSBjcmVhdGVkIHRvIG1hcmsgZWFjaCBtb3ZlLiBNYXkgYmUgbGVmdCBlbXB0eS9udWxsL3VuZGVmaW5lZC4gT3IgZWxzZSBhIHZhbHVlIGxpa2UgYFwiQ1JcImAuXHJcbiAqIEBwYXJhbSB7YXJyYXl9IFtvcHRpb25zLmJvYXJkRGltZW5zaW9ucyA9IFsxMSwgMTFdXSBNYXkgYmUgdXNlZCBmb3IgcmVjdGFuZ3VsYXIgdC1Hby4gU2hvdWxkIGJlIG9tbWl0dGVkIGZvciBbbiwgbl0gdC1Hbywgd2hlcmUgbiBpcyBzcGVjaWZpZWQgaW4gdGhlIGlucHV0IFNHRiAoQHBhcmFtIHZhcmlhbnRTZ2YpLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuY29vcmRpbmF0ZXNUeXBlID0gMF0gMDogbm9uZTtcclxuICogMTogKOKGkuKGkTtBfDEtS3wxMSk6IFdlc3Rlcm47XHJcbiAqIDI6ICjihpLihpE7QXwxLUx8MTEpOiBXZXN0ZXJuLCBubyDigJxJ4oCdO1xyXG4gKiAzOiAo4oaS4oaTOzF8MS0xMXwxMSk6IExhdGluL0xhdGluLCB0b3AgdG8gYm90dG9tO1xyXG4gKiA0OiAo4oaS4oaTOzF8MS0xMXzljYHkuIApOiBMYXRpbi9DaGluZXNlLCB0b3AgdG8gYm90dG9tO1xyXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMud3JhcGFyb3VuZE1hcmtlcnNUeXBlID0gMV0gMDogbm9uZTtcclxuICogMTogRnVsbCBvdXRsaW5lLCB1c2luZyB1bmljb2RlIEJveCBEcmF3aW5nIHN5bWJvbHM7XHJcbiAqIDI6IGNvcm5lcnMgYW5kIG1pZGRsZXMsIHVzaW5nIHVuaWNvZGUgQm94IERyYXdpbmcgc3ltYm9scztcclxuICogMzoganVzdCBjb3JuZXJzLCB1c2luZyB1bmljb2RlIEJveCBEcmF3aW5nIHN5bWJvbHM7XHJcbiAqIDQ6IGp1c3QgbWlkZGxlcywgdXNpbmcgdW5pY29kZSBCb3ggRHJhd2luZyBzeW1ib2xzO1xyXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMucHJvamVjdGlvblNldHRpbmdzPV0gRnVydGhlciBvcHRpb25hbCBzZXR0aW5ncyBmb3IgaG93IHRoZSAodG9yb2lkYWwsIG9yIG90aGVyIHNvcnQgb2YpIGJvYXJkIGlzIHByb2plY3RlZCB0byBhIGZsYXQgZ3JpZC5cclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnByb2plY3Rpb25TZXR0aW5ncy53cmFwYXJvdW5kID0gNF0gIE51bWJlciBvZiBsaW5lcyB0byBhZGQgZm9yIHRoZSDigJx3cmFwYXJvdW5k4oCdLlxyXG4gKiBAcGFyYW0ge2FycmF5fSBbb3B0aW9ucy5wcm9qZWN0aW9uU2V0dGluZ3Mub2Zmc2V0ID0gWzAsMF1dICBUcmFuc2xhdGlvbiB0byBhcHBseSB0byBhbGwgbW92ZXMuXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhbnNmb3JtVG9TdHJpbmc9dHJ1ZV0gV2hlbiBzZXQgdG8gZmFsc2UsIHRoZSBvdXRwdXQgaXMgYW4gb2JqZWN0IChhbiBpbnN0YW5jZSBvZiBhIFNtYXJ0Z2FtZSkuXHJcbiAqIEBwdWJsaWNcclxuICogQHJldHVybiB7b2JqZWN0fSBBbiBvYmplY3QgZXhwb3NpbmcgZnVuY3Rpb25zIGZvciBnb2luZyBiYWNrIGFuZCBmb3J0aCBiZXR3ZWVuIFNHRiBmb3IgYSBzdGFuZGFyZCB2aWV3ZXIsIGFuZCBTR0YgZm9yIGEgZ2FtZSBvZiB0b3JvaWRhbCBHb1xyXG4gKi8vKnRvZG9zOlxyXG5vcGlvbnMucGxhY2VzVG9Db3VudCBEZWZhdWx0OiB1bmRlZmluZWQuIE1heSBiZTogJ2xhc3QnfFtjb3VudEluZm8xLCAuLiBjb3VudEluZm8xXS4gY291bnRJbmZvIGlzIGEgcGF0aCBwbHVzIGFuIGFycmF5IHdpdGggYSBwb2ludCBmb3IgZWFjaCBjaGFpbiB0byBiZSBjb25zaWRlcmVkIGFzIGRlYWQuIHtwYXRoLCBkZWFkQ2hhaW5zOiBbLi4uXX1cclxub3B0aW9ucy5wcm9qZWN0aW9uU2V0dGluZ3Mucm90YXRpb24ge2ludGVnZXJ9IERlZmF1bHQgdmFsdWU6IDAuIEFsbG93ZWQgdmFsdWVzOiAwIC4uIDNcclxub3B0aW9ucy5wcm9qZWN0aW9uU2V0dGluZ3Mubm9ybWFsaXplUGxhY2UgYXJyYXksIG9yIG9uZSBvZjogQywgVEwgVFIgQkwgQlIgKGNlbnRyZSwgdG9wIGxlZnQsIHRvcCByaWdodCwgYm90dG9tIGxlZnQsIGJvdHRvbSByaWdodClcclxub3B0aW9ucy5wcm9qZWN0aW9uU2V0dGluZ3Mubm9ybWFsaXplIHtib29sZWFufSBcclxuXHJcbiovXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybWVyKG9wdGlvbnNcclxuKSB7XHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdGNvbnN0XHJcblx0XHRfZmxhdHRlbiA9IHJlcXVpcmUoJ2xvZGFzaC9mbGF0dGVuJylcclxuXHRcdCwgX3VuaXFCeSA9IHJlcXVpcmUoJ2xvZGFzaC91bmlxQnknKVxyXG5cdFx0LCBfZmkgPSByZXF1aXJlKCdsb2Rhc2gvZmluZEluZGV4JylcclxuXHRcdCwgbW9kdWxvID0gKHgsIHkpID0+ICh4ICUgeSArIHkpICUgeVxyXG5cdFx0LCBzb3VyY2VTZ2ZNZXNzYWdlID0gJ3NvdXJjZSBzZ2YgZm9yIHRvcm9pZGFsIEdvIGhhcyBiZWVuIGFkYXB0ZWQgYnkgZ28tdmFyaWFudHMtdHJhbnNmb3JtZXIgc28gYXMgdG8gYmUgcmVuZGVyZWQgYnkgYW55IHN0YW5kYXJkIEdvIGFwcGxpY2F0aW9uJ1xyXG5cdG9wdGlvbnMgPSB7XHJcblx0XHRib2FyZERpbWVuc2lvbnM6IFsxMSwgMTFdXHJcblx0XHQsIHRyYW5zZm9ybVRvU3RyaW5nOiB0cnVlXHJcblx0XHQsIGFkZENvbW1lbnRzOiB0cnVlXHJcblx0XHQsIGNvb3JkaW5hdGVzVHlwZTogMFxyXG5cdFx0LCB3cmFwYXJvdW5kTWFya2Vyc1R5cGU6IDFcclxuXHRcdCwgbW92ZVR5cGU6IDJcclxuXHRcdCwgbWFya0xhc3RNb3ZlOiBudWxsXHJcblx0XHQvL2Fib3ZlIGFyZSB0aGUgZGVmYXVsdHNcclxuXHRcdCwgLi4ub3B0aW9uc1xyXG5cdH1cclxuXHRvcHRpb25zLnByb2plY3Rpb25TZXR0aW5ncyA9XHJcblx0XHR7XHJcblx0XHRcdHdyYXBhcm91bmQ6IDQsXHJcblx0XHRcdG9mZnNldDogWzAsIDBdLFxyXG5cdFx0XHQuLi5vcHRpb25zLnByb2plY3Rpb25TZXR0aW5nc1xyXG5cdFx0fVxyXG5cclxuXHRpZiAob3B0aW9ucy5hZGRQYXNzZXMgPT09IHVuZGVmaW5lZClcclxuXHRcdG9wdGlvbnMuYWRkUGFzc2VzID0gdHJ1ZTtcclxuXHJcblx0b3B0aW9ucy5ib2FyZERpbWVuc2lvbnMgPSBvcHRpb25zLmJvYXJkRGltZW5zaW9ucyB8fCBbMTEsIDExXVxyXG5cclxuXHRpZiAob3B0aW9ucy50cmFuc2Zvcm1Ub1N0cmluZyA9PT0gdW5kZWZpbmVkKVxyXG5cdFx0b3B0aW9ucy50cmFuc2Zvcm1Ub1N0cmluZyA9IHRydWU7XHJcblxyXG5cdGlmIChvcHRpb25zLmFkZENvbW1lbnRzID09PSB1bmRlZmluZWQpXHJcblx0XHRvcHRpb25zLmFkZENvbW1lbnRzID0gdHJ1ZTtcclxuXHQvLyBvcHRpb25zLnByb2plY3Rpb25TZXR0aW5ncyA9IFxyXG5cclxuXHRsZXQgd3JhcGFyb3VuZCA9IG9wdGlvbnMucHJvamVjdGlvblNldHRpbmdzLndyYXBhcm91bmRcclxuXHJcblx0bGV0ICQgPSB7fVxyXG5cdFx0Ly8gLCBfbWFya2Vyc0ZvcldyYXBhcm91bmQgPSBudWxsXHJcblx0XHQsIGNvb3JkaW5hdGVMYWJlbHMgPSBmdW5jdGlvbiAoaSkge1xyXG5cdFx0XHQvLyA5Ny4uMTIyIGFuZCA2NS4uOTBcclxuXHRcdFx0cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA8IDI2ID8gaSArIDk3IDogaSArIDM5KVxyXG5cdFx0XHQvLzY1IC0gMjYgPVxyXG5cdFx0fVxyXG5cdFx0LFxyXG5cdFx0dHJhbnNsYXRlQ29vcmRpbmF0ZSA9IChjKSA9PiB7XHJcblx0XHRcdGxldCByID0gYy5jaGFyQ29kZUF0KDApXHJcblx0XHRcdHJldHVybiByID49IDk3ID8gciAtIDk3IDogciAtIDI2XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiBUcmFuc2xhdGUgYWxwaGEgY29vcmRpbmF0ZXMgaW50byBhbiBhcnJheVxyXG5cdFx0ICogQHBhcmFtIHN0cmluZyBhbHBoYUNvb3JkaW5hdGVzXHJcblx0XHQgKiBAcmV0dXJuIGFycmF5IFt4LCB5XVxyXG5cdFx0ICoqL1xyXG5cdFx0dHJhbnNsYXRlQ29vcmRpbmF0ZXMgPSAoYWxwaGFDb29yZGluYXRlcykgPT4ge1xyXG5cdFx0XHRyZXR1cm4gW3RyYW5zbGF0ZUNvb3JkaW5hdGUoYWxwaGFDb29yZGluYXRlcy5zdWJzdHJpbmcoMCwgMSkpXHJcblx0XHRcdFx0LCB0cmFuc2xhdGVDb29yZGluYXRlKGFscGhhQ29vcmRpbmF0ZXMuc3Vic3RyaW5nKDEsIDIpKV1cclxuXHJcblx0XHR9XHJcblxyXG5cclxuXHQkLmNvb3JkaW5hdGVMYWJlbHMgPSBjb29yZGluYXRlTGFiZWxzXHJcblx0JC50cmFuc2xhdGVDb29yZGluYXRlcyA9IHRyYW5zbGF0ZUNvb3JkaW5hdGVzXHJcblx0LyoqXHJcblx0ICogQHB1YmxpY1xyXG5cdCAqL1xyXG5cdCQub3B0aW9ucyA9IG9wdGlvbnNcclxuXHJcblx0JC5wcm9qZWN0T25MaW5lID0gZnVuY3Rpb24gKGEsIGlzVmVydGljYWwpIHtcclxuXHRcdC8qXHJcblx0XHRtOiBib2FyZERpbWVuc2lvbnNbMF0gOiAxMVxyXG5cdFx0bjogd3JhcGFyb3VuZCA6IDRcclxuXHRcdGxpbmU6IDAsLi4uLChtLTEpXHJcblx0XHQ9PlxyXG5cdFx0MCwuLi4sKG4tMSksIChzdGFydCBsaW5lKSBuLCAuLi4gLCAobiArIG0gLSAxKSBlbmQgbGluZSwgIChuK20pLCAuLi4gLCAoMm4gKyBtIC0gMSlcclxuXHJcblx0XHRjb29yZGluYXRlIGEg4oiIIHswIC4uIG0tMX0gcHJvamVjdHMgdG8gbiArIGEgaW4gbWFpbiBhcmVhXHJcblx0XHRhbGwgcHJvamVjdGlvbnMgYXJlIG9mIHRoZSBmb3JtIG4gKyBhICsgeG0sIHgg4oiIIOKEpCBzLnQuIDAg4omkIG4gKyBhICsgeG0g4omkIDJuICsgbSAtMVxyXG5cdFx0LXhtIOKJpCBuICsgYVxyXG5cdFx0XHRzbWFsbGVzdCBzdWNoIHggPCAwIGlzIGNlaWwoLShuK2EpL20pXHJcblx0XHQgeG0g4omkIG4gKyBtIC0gMSAtYVxyXG5cdFx0XHRsYXJnZXN0IHN1Y2ggeCBpcyBmbG9vcigobiArIG0gLSAxIC1hKSAvIG0pXHJcblxyXG5cclxuXHRcdCovXHJcblxyXG5cdFx0Y29uc3QgbSAvLz0gb3B0aW9ucy5ib2FyZERpbWVuc2lvbnNbMF1cclxuXHRcdFx0PSBvcHRpb25zLmJvYXJkRGltZW5zaW9uc1tpc1ZlcnRpY2FsID8gMSA6IDBdXHJcblxyXG5cdFx0XHQsIHIgPSBbXVxyXG5cclxuXHRcdGZvciAobGV0IGkgPSBNYXRoLmNlaWwoLSh3cmFwYXJvdW5kICsgYSkgLyBtKTsgaSA8PSAod3JhcGFyb3VuZCArIG0gLSAxIC0gYSkgLyBtOyBpKyspXHJcblx0XHRcdHIucHVzaCh3cmFwYXJvdW5kICsgYSArIGkgKiBtKVxyXG5cclxuXHRcdGlmIChvcHRpb25zLm1vdmVUeXBlID09PSAyKSB7Ly9lbnN1cmUgdGhlIGxhc3QgaXRlbSBpbiB0aGUgcmVzdWx0IGlzIHRoZSBvbmUgaW5zaWRlIHRoZSBtYWluIGJvYXJkIGFyZWFcclxuXHRcdFx0ci5zb3J0KCh4LCB5KSA9PiB7XHJcblx0XHRcdFx0aWYgKHggPj0gd3JhcGFyb3VuZCAmJiB4IDwgd3JhcGFyb3VuZCArIG0pIHJldHVybiAxXHJcblx0XHRcdFx0aWYgKHkgPj0gd3JhcGFyb3VuZCAmJiB5IDwgd3JhcGFyb3VuZCArIG0pIHJldHVybiAtMVxyXG5cdFx0XHRcdHJldHVybiAwXHJcblx0XHRcdH0pXHJcblx0XHR9XHJcblx0XHRyZXR1cm4gclxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhpcyBpcyB0aGUgaW52ZXJzZSBmdW5jdGlvbiB0byB0aGUgZnVuY3Rpb24g4oCccHJvamVjdE9uRmxhdOKAnSDigJMgYXQgbGVhc3QgaXQgaXMgd2hlbiDigJxtdWx0aXBsZeKAnSBpcyBmYWxzZS5cclxuXHQgKiBAcGFyYW0ge0FycmF5fSBwb2ludHMgVGhlIHBvaW50IG9yIGFycmF5IG9mIHBvaW50cyBwcm9qZWN0ZWQgb250byB0aGUgZ3JpZC5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW49ZmFsc2V9IG11bHRpcGxlIFdoZXRoZXIgdGhlIGFyZ3VtZW50IOKAnHBvaW50c+KAnSBpcyB0aGUgaW1hZ2Ugb2YgYSBzaW5nbGUgcG9pbnQgKOKAnG11bHRpcGxlPWZhbHNl4oCdKSBvciBvZiBtdWx0aXBsZSBwb2ludHMuXHJcblx0ICogQHJldHVybnMge0FycmF5fSBXaGVuIHRoZSBmbGFnIOKAnG11bHRpcGxl4oCdIGlzIGZsYWdnZWQsIHJldHVybnMgYW4gYXJyYXkgb2YgcG9pbnRzOyBvdGhlcndpc2UgcmV0dXJucyBhIHNpbmdsZSBwb2ludCAoaS5lLiBhbiBhcnJheSBvZiB0d28gaW50ZWdlcnMpLlxyXG5cdCAqL1xyXG5cdGZ1bmN0aW9uIGludmVyc2VQcm9qZWN0T25GbGF0KHBvaW50cywgbXVsdGlwbGUpIHtcclxuXHRcdGlmICghQXJyYXkuaXNBcnJheShwb2ludHNbMF0pKSBwb2ludHMgPSBbcG9pbnRzXVxyXG5cdFx0aWYgKCFtdWx0aXBsZSlcclxuXHRcdFx0cmV0dXJuIFttb2R1bG8ocG9pbnRzWzBdWzBdIC0gb3B0aW9ucy5wcm9qZWN0aW9uU2V0dGluZ3Mub2Zmc2V0WzBdIC0gd3JhcGFyb3VuZCwgb3B0aW9ucy5ib2FyZERpbWVuc2lvbnNbMF0pXHJcblx0XHRcdFx0LCBtb2R1bG8ocG9pbnRzWzBdWzFdIC0gb3B0aW9ucy5wcm9qZWN0aW9uU2V0dGluZ3Mub2Zmc2V0WzFdIC0gd3JhcGFyb3VuZCwgb3B0aW9ucy5ib2FyZERpbWVuc2lvbnNbMV0pXVxyXG5cdFx0cmV0dXJuIF91bmlxQnkocG9pbnRzLm1hcCh4ID0+IGludmVyc2VQcm9qZWN0T25GbGF0KFt4XSkpLCAoeCkgPT4gYCR7eFswXX1fJHt4WzFdfWApXHJcblx0fVxyXG5cdCQuaW52ZXJzZVByb2plY3RPbkZsYXQgPSBpbnZlcnNlUHJvamVjdE9uRmxhdFxyXG5cclxuXHQvKipcclxuXHQgKiBQcm9qZWN0cyBhIHBvaW50IG9uIHRoZSB0LUdvIGJvYXJkIHRvIHRoZSBhcnJheSBvZiBwb2ludHMgb24gdGhlIHN0YW5kYXJkIGdyaWQvYm9hcmQuXHJcblx0ICogQHBhcmFtIHtBcnJheX0gcCBUaGUgcG9pbnQgaW4gdGhlIHQtR28gYm9hcmQgdG8gYmUgcHJvamVjdGVkIG9uIHRvIHRoZSBncmlkLlxyXG5cdCAqIEByZXR1cm5zIHtBcnJheX1cclxuXHQgKi9cclxuXHRmdW5jdGlvbiBwcm9qZWN0T25GbGF0KHApIHtcclxuXHRcdGNvbnN0IGEgPSAkLnByb2plY3RPbkxpbmUocFswXSArIG9wdGlvbnMucHJvamVjdGlvblNldHRpbmdzLm9mZnNldFswXSlcclxuXHRcdFx0LCBiID0gJC5wcm9qZWN0T25MaW5lKHBbMV0gKyBvcHRpb25zLnByb2plY3Rpb25TZXR0aW5ncy5vZmZzZXRbMV0sIHRydWUpXHJcblx0XHRcdCwgciA9IFtdXHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXHJcblx0XHRcdGZvciAobGV0IGogPSAwOyBqIDwgYi5sZW5ndGg7IGorKylcclxuXHRcdFx0XHRyLnB1c2goW2FbaV0sIGJbal1dKVxyXG5cdFx0cmV0dXJuIHJcclxuXHR9XHJcblx0JC5wcm9qZWN0T25GbGF0ID0gcHJvamVjdE9uRmxhdFxyXG5cclxuXHQkLm1vZFggPSAoeCkgPT4gbW9kdWxvKHgsIG9wdGlvbnMuYm9hcmREaW1lbnNpb25zWzBdKVxyXG5cdCQubW9kWSA9ICh5KSA9PiBtb2R1bG8oeSwgb3B0aW9ucy5ib2FyZERpbWVuc2lvbnNbMV0pXHJcblxyXG5cdGxldCBzZXRVcE1hcmtlcnMgPSAoKSA9PiB7XHJcblx0XHQkLndyYXBhcm91bmRBbmRDb29yZHMgPSBbXVxyXG5cclxuXHRcdC8vICQuZ2V0TWFya2Vyc0ZvcldyYXBhcm91bmQgPSBmdW5jdGlvbiAoKXtcclxuXHRcdGlmIChvcHRpb25zLnByb2plY3Rpb25TZXR0aW5ncy53cmFwYXJvdW5kID4gMCkge1xyXG5cdFx0XHRjb25zdCBtID0gb3B0aW9ucy5ib2FyZERpbWVuc2lvbnNbMF0sXHJcblx0XHRcdFx0biA9IG9wdGlvbnMuYm9hcmREaW1lbnNpb25zWzFdXHJcblxyXG5cdFx0XHQvKlxyXG5cdFx0XHRtOiBib2FyZERpbWVuc2lvbnNbMF0gOiAxMVxyXG5cdFx0XHR3OiB3cmFwYXJvdW5kIDogNFxyXG5cdFx0XHRsaW5lOiAwLC4uLiwobS0xKVxyXG5cdFx0XHQ9PlxyXG5cdFx0XHQwLC4uLiwody0xKSwgKHN0YXJ0IGxpbmUpIHcsIC4uLiAsICh3ICsgbSAtIDEpIGVuZCBsaW5lLCAodyttKSwgLi4uICwgKDJ3ICsgbSAtIDEpXHJcblx0XHRcdCovXHJcblxyXG5cdFx0XHRsZXQgYm9hcmQgPSBbXVxyXG5cdFx0XHRpZiAoWzEsIDIsIDRdLmluZGV4T2Yob3B0aW9ucy53cmFwYXJvdW5kTWFya2Vyc1R5cGUpID4gLTEpIHtcclxuXHRcdFx0XHRsZXQgbWlkZGxlcyA9IG9wdGlvbnMud3JhcGFyb3VuZE1hcmtlcnNUeXBlID4gMSA/XHJcblx0XHRcdFx0XHRbTWF0aC5mbG9vcigobSAtIDEpIC8gMikgKyAxLCBNYXRoLmNlaWwoKG0gLSAxKSAvIDIpICsgMSxcclxuXHRcdFx0XHRcdE1hdGguZmxvb3IoKG4gLSAxKSAvIDIpICsgMSwgTWF0aC5jZWlsKChuIC0gMSkgLyAyKSArIDFdXHJcblx0XHRcdFx0XHQ6IFstMSwgOTksIC0xLCA5OV1cclxuXHRcdFx0XHRmb3IgKGxldCBpID0gMTsgaSA8PSBtOyBpKyspIHtcclxuXHRcdFx0XHRcdGlmIChpIDwgbWlkZGxlc1swXSB8fCBpID4gbWlkZGxlc1sxXSkge1xyXG5cdFx0XHRcdFx0XHRjb250aW51ZVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0bGV0IGxhYmVsID0gJ+KUgCcvL1UrMjUwMCBCb3ggRHJhd2luZ3MgTGlnaHQgSG9yaXpvbnRhbFxyXG5cclxuXHRcdFx0XHRcdGJvYXJkLnB1c2goY29vcmRpbmF0ZUxhYmVscyh3cmFwYXJvdW5kIC0gMSArIGkpICsgY29vcmRpbmF0ZUxhYmVscyh3cmFwYXJvdW5kIC0gMSkgKyBcIjpcIiArIGxhYmVsKVxyXG5cdFx0XHRcdFx0Ym9hcmQucHVzaChjb29yZGluYXRlTGFiZWxzKHdyYXBhcm91bmQgLSAxICsgaSkgKyBjb29yZGluYXRlTGFiZWxzKHdyYXBhcm91bmQgKyBtKSArIFwiOlwiICsgbGFiZWwpXHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGZvciAobGV0IGkgPSAxOyBpIDw9IG47IGkrKykge1xyXG5cdFx0XHRcdFx0aWYgKGkgPCBtaWRkbGVzWzJdIHx8IGkgPiBtaWRkbGVzWzNdKSB7XHJcblx0XHRcdFx0XHRcdGNvbnRpbnVlXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRsZXQgbGFiZWwgPSAn4pSCJy8vdW5pY29kZSB0b29cclxuXHRcdFx0XHRcdGJvYXJkLnB1c2goY29vcmRpbmF0ZUxhYmVscyh3cmFwYXJvdW5kIC0gMSkgKyBjb29yZGluYXRlTGFiZWxzKHdyYXBhcm91bmQgLSAxICsgaSkgKyBcIjpcIiArIGxhYmVsKVxyXG5cdFx0XHRcdFx0Ym9hcmQucHVzaChjb29yZGluYXRlTGFiZWxzKHdyYXBhcm91bmQgKyBuKSArIGNvb3JkaW5hdGVMYWJlbHMod3JhcGFyb3VuZCAtIDEgKyBpKSArIFwiOlwiICsgbGFiZWwpXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChbMSwgMiwgM10uaW5kZXhPZihvcHRpb25zLndyYXBhcm91bmRNYXJrZXJzVHlwZSkgPiAtMSkge1xyXG5cdFx0XHRcdC8v4pSYICDilIwgIOKUlCDilJBcclxuXHRcdFx0XHRib2FyZC5wdXNoKGNvb3JkaW5hdGVMYWJlbHMod3JhcGFyb3VuZCAtIDEpICsgY29vcmRpbmF0ZUxhYmVscyh3cmFwYXJvdW5kICsgbikgKyBcIjrilJRcIilcclxuXHRcdFx0XHRib2FyZC5wdXNoKGNvb3JkaW5hdGVMYWJlbHMod3JhcGFyb3VuZCArIG0pICsgY29vcmRpbmF0ZUxhYmVscyh3cmFwYXJvdW5kICsgbikgKyBcIjrilJhcIilcclxuXHRcdFx0XHRib2FyZC5wdXNoKGNvb3JkaW5hdGVMYWJlbHMod3JhcGFyb3VuZCAtIDEpICsgY29vcmRpbmF0ZUxhYmVscyh3cmFwYXJvdW5kIC0gMSkgKyBcIjrilIxcIilcclxuXHRcdFx0XHRib2FyZC5wdXNoKGNvb3JkaW5hdGVMYWJlbHMod3JhcGFyb3VuZCArIG0pICsgY29vcmRpbmF0ZUxhYmVscyh3cmFwYXJvdW5kIC0gMSkgKyBcIjrilJBcIilcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKG9wdGlvbnMuY29vcmRpbmF0ZXNUeXBlID4gMCAmJiB3cmFwYXJvdW5kID4gMSkge1xyXG5cdFx0XHRcdGZvciAobGV0IGkgPSAxOyBpIDwgMiAqIHdyYXBhcm91bmQgKyBtIC0gMTsgaSsrKSB7XHJcblxyXG5cdFx0XHRcdFx0bGV0IGNvb3JkSW5kZXggPSAkLm1vZFgoLW9wdGlvbnMucHJvamVjdGlvblNldHRpbmdzLm9mZnNldFswXSAtIHdyYXBhcm91bmQgKyBpKVxyXG5cclxuXHRcdFx0XHRcdGlmIChvcHRpb25zLmNvb3JkaW5hdGVzVHlwZSA9PT0gMiAmJiBjb29yZEluZGV4ID49IDgpIHtcclxuXHRcdFx0XHRcdFx0Ly9vbWl0IHRoZSBJIC0gaGlzdG9yaWNhbCBjb29yZGluYXRlcyBmb3IgR28uLi5cclxuXHRcdFx0XHRcdFx0Ly9JOiA5dGggbGV0dGVyXHJcblx0XHRcdFx0XHRcdGNvb3JkSW5kZXgrK1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0bGV0IGxhYmVsID1cclxuXHRcdFx0XHRcdFx0b3B0aW9ucy5jb29yZGluYXRlc1R5cGUgPCAzXHJcblx0XHRcdFx0XHRcdFx0PyBjb29yZGluYXRlTGFiZWxzKGNvb3JkSW5kZXgpLnRvVXBwZXJDYXNlKClcclxuXHRcdFx0XHRcdFx0XHQ6ICcnICsgKGNvb3JkSW5kZXggKyAxKVxyXG5cdFx0XHRcdFx0Ym9hcmQucHVzaChjb29yZGluYXRlTGFiZWxzKGkpICsgY29vcmRpbmF0ZUxhYmVscygwKSArIFwiOlwiICsgbGFiZWwpXHJcblx0XHRcdFx0XHRib2FyZC5wdXNoKGNvb3JkaW5hdGVMYWJlbHMoaSkgKyBjb29yZGluYXRlTGFiZWxzKDIgKiB3cmFwYXJvdW5kICsgbiAtIDEpICsgXCI6XCIgKyBsYWJlbClcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0bGV0IGNqa051bWJlcnMgPSAn5LiA5LqM5LiJ5Zub5LqU5YWt5LiD5YWr5LmdJ1xyXG5cdFx0XHRcdGZvciAobGV0IGkgPSAxOyBpIDwgMiAqIHdyYXBhcm91bmQgKyBuIC0gMTsgaSsrKSB7XHJcblx0XHRcdFx0XHQvKlxyXG5cdFx0XHRcdFx0MFx0XHQtd1xyXG5cdFx0XHRcdFx0Li4uXHJcblx0XHRcdFx0XHR3LTFcdC0xXHJcblx0XHRcdFx0XHR3XHRcdDBcclxuXHRcdFx0XHRcdC4uLlxyXG5cdFx0XHRcdFx0dyArIG4gLTFcclxuXHRcdFx0XHRcdFxyXG5cdFx0XHRcdFx0Ki9cclxuXHRcdFx0XHRcdGxldCBjb29yZEluZGV4ID1cclxuXHRcdFx0XHRcdFx0b3B0aW9ucy5jb29yZGluYXRlc1R5cGUgPCAzXHJcblx0XHRcdFx0XHRcdFx0PyAkLm1vZFkobiArIG9wdGlvbnMucHJvamVjdGlvblNldHRpbmdzLm9mZnNldFsxXSArIHdyYXBhcm91bmQgLSBpIC0gMSlcclxuXHRcdFx0XHRcdFx0XHQ6ICQubW9kWShpIC0gd3JhcGFyb3VuZCAtIG9wdGlvbnMucHJvamVjdGlvblNldHRpbmdzLm9mZnNldFsxXSlcclxuXHRcdFx0XHRcdGxldCBsYWJlbCA9ICcnXHJcblx0XHRcdFx0XHRzd2l0Y2ggKG9wdGlvbnMuY29vcmRpbmF0ZXNUeXBlKSB7XHJcblx0XHRcdFx0XHRcdGNhc2UgMTpcclxuXHRcdFx0XHRcdFx0Y2FzZSAyOlxyXG5cdFx0XHRcdFx0XHRjYXNlIDM6XHJcblx0XHRcdFx0XHRcdFx0bGFiZWwgPSAnJyArIChjb29yZEluZGV4ICsgMSlcclxuXHRcdFx0XHRcdFx0XHRicmVha1xyXG5cdFx0XHRcdFx0XHRjYXNlIDQ6XHJcblx0XHRcdFx0XHRcdFx0bGFiZWwgPSBtb2R1bG8oY29vcmRJbmRleCwgMTApID09PSA5ID8gJycgOiBjamtOdW1iZXJzW21vZHVsbyhjb29yZEluZGV4LCAxMCldXHJcblxyXG5cdFx0XHRcdFx0XHRcdGlmIChjb29yZEluZGV4ID4gOCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0bGFiZWwgPSAoY29vcmRJbmRleCA+IDE4ID8gY2prTnVtYmVyc1tNYXRoLmZsb29yKChjb29yZEluZGV4ICsgMSkgLyAxMCkgLSAxXSA6ICcnKSArICfljYEnICsgbGFiZWxcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0YnJlYWtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGJvYXJkLnB1c2goY29vcmRpbmF0ZUxhYmVscygwKSArIGNvb3JkaW5hdGVMYWJlbHMoaSkgKyBcIjpcIiArIGxhYmVsKVxyXG5cdFx0XHRcdFx0Ym9hcmQucHVzaChjb29yZGluYXRlTGFiZWxzKDIgKiB3cmFwYXJvdW5kICsgbSAtIDEpICsgY29vcmRpbmF0ZUxhYmVscyhpKSArIFwiOlwiICsgbGFiZWwpXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQkLndyYXBhcm91bmRBbmRDb29yZHMgPSBib2FyZFxyXG5cdFx0fVxyXG5cdH1cclxuXHRzZXRVcE1hcmtlcnMoKVxyXG5cclxuXHJcblx0JC5jb29yZHMyU3RyaW5nID1cclxuXHRcdC8qKlxyXG5cdFx0ICogY29udmVydHMgY29vcmRpbmF0ZXMgdG8gYSBzdHJpbmdcclxuXHRcdCAqL1xyXG5cdFx0ZnVuY3Rpb24gY29vcmRzMlN0cmluZyhjb29yZHMpIHtcclxuXHRcdFx0cmV0dXJuIGNvb3JkaW5hdGVMYWJlbHMoY29vcmRzWzBdKSArIGNvb3JkaW5hdGVMYWJlbHMoY29vcmRzWzFdKVxyXG5cdFx0fVxyXG5cclxuXHRmdW5jdGlvbiBnb1Rocm91Z2hUcmVlKHN0YXRlKSB7XHJcblx0XHRsZXQgeyB3cmFwcGVkR2FtZSwgbm9kZSwgcGVuZGluZywgY3VycmVudFBhdGgsIHRHbyB9ID0gc3RhdGVcclxuXHRcdFx0LCBuYlZhcmlhdGlvbnMgPSB3cmFwcGVkR2FtZS52YXJpYXRpb25zKCkubGVuZ3RoXHJcblx0XHRpZiAoY3VycmVudFBhdGgubSA+IDEwMDApIHRocm93IG5ldyBFcnJvcignc2VlbSB0byBiZSBzdHVjayEnKTtcclxuXHRcdHN0YXRlLmhhc1NpYmxpbmdzID0gbmJWYXJpYXRpb25zID4gMFxyXG5cdFx0aWYgKHN0YXRlLmhhc1NpYmxpbmdzKSB7XHJcblx0XHRcdC8vIGlmKGN1cnJlbnRQYXRoW21dID09PSB1bmRlZmluZWQpXHJcblx0XHRcdC8vIGN1cnJlbnRQYXRoW21dID0gMFxyXG5cdFx0XHQvLyBlbHNlXHJcblx0XHRcdC8vIGN1cnJlbnRQYXRoW21dICs9IDFcclxuXHRcdFx0Ly8gY3VycmVudFBhdGgubSArPSAxXHJcblx0XHRcdGZvciAobGV0IGkgPSBuYlZhcmlhdGlvbnMgLSAxOyBpID4gMDsgaS0tKVxyXG5cdFx0XHQvL3BpbGUgdXAgaW4gdGhpcyBvcmRlciwgYXMgaXQncyBGSUxPIGFuZCB3ZSB3YW50IHRoZSBsYXN0IHZhcmlhdGlvbiwgd2hpY2ggbWF5IGNvbnRhaW4gYSBtb2RlIGFkZGVkIGJ5IENHb2JvYXJkIHRvIGdvIGxhc3RcclxuXHRcdFx0e1xyXG5cdFx0XHRcdGxldCBwYXRoRm9yTGF0ZXIgPSB7IC4uLmN1cnJlbnRQYXRoIH0vL09iamVjdC5hc3NpZ24oe30sIGN1cnJlbnRQYXRoKVxyXG5cdFx0XHRcdHBhdGhGb3JMYXRlcltjdXJyZW50UGF0aC5tICsgMV0gPSBpXHJcblx0XHRcdFx0cGF0aEZvckxhdGVyLm0gKz0gMVxyXG5cclxuXHRcdFx0XHRpZiAodEdvICE9PSB1bmRlZmluZWQpXHJcblx0XHRcdFx0XHRwZW5kaW5nLnB1c2goeyBwYXRoOiBwYXRoRm9yTGF0ZXIsIHRHb0RhdGE6IHRHby5leHBvcnREYXRhKCkgfSlcclxuXHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHRwZW5kaW5nLnB1c2goeyBwYXRoOiBwYXRoRm9yTGF0ZXIgfSlcclxuXHJcblx0XHRcdH1cclxuXHRcdFx0c3RhdGUubm9kZSA9IHdyYXBwZWRHYW1lLm5leHQoKS5ub2RlKClcclxuXHRcdFx0Y3VycmVudFBhdGhbY3VycmVudFBhdGgubSArIDFdID0gMFxyXG5cdFx0XHRjdXJyZW50UGF0aC5tICs9IDFcclxuXHRcdFx0cmV0dXJuIHN0YXRlLm5vZGVcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgbmV4dE5vZGUgPSB3cmFwcGVkR2FtZS5uZXh0KCkubm9kZSgpXHJcblx0XHRpZiAobm9kZSA9PT0gbmV4dE5vZGUpIHsvL2F0IGEgbGVhZjpcclxuXHRcdFx0aWYgKHBlbmRpbmcubGVuZ3RoID09PSAwKSB7XHJcblx0XHRcdFx0c3RhdGUubm9kZSA9IG51bGxcclxuXHRcdFx0XHRyZXR1cm4gc3RhdGUubm9kZS8vZmluaXNoZWRcclxuXHRcdFx0fVxyXG5cdFx0XHRsZXQgZnJvbVN0YWNrID0gcGVuZGluZy5wb3AoKVxyXG5cdFx0XHRzdGF0ZS5oYXNTaWJsaW5ncyA9IHRydWVcclxuXHRcdFx0Ly8gaWYgKGZyb21TdGFjayA9PT0gbnVsbCkge1xyXG5cdFx0XHQvLyBcdG5vZGUgPSBudWxsXHJcblx0XHRcdC8vIFx0cmV0dXJuLy9maW5pc2hlZCFcclxuXHRcdFx0Ly8gfVxyXG5cdFx0XHRpZiAodEdvICE9PSB1bmRlZmluZWQpIHRHby5sb2FkRGF0YShmcm9tU3RhY2sudEdvRGF0YSlcclxuXHRcdFx0c3RhdGUubm9kZSA9IHdyYXBwZWRHYW1lLmdvVG8oZnJvbVN0YWNrLnBhdGgpLm5vZGUoKVxyXG5cdFx0XHRzdGF0ZS5jdXJyZW50UGF0aCA9IGZyb21TdGFjay5wYXRoXHJcblx0XHRcdHJldHVybiBzdGF0ZS5ub2RlXHJcblx0XHR9XHJcblx0XHRlbHNlIHtcclxuXHRcdFx0Y3VycmVudFBhdGgubSArPSAxXHJcblx0XHRcdHN0YXRlLm5vZGUgPSBuZXh0Tm9kZVxyXG5cdFx0XHRyZXR1cm4gc3RhdGUubm9kZVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQXBhcnQgZnJvbSBhIGZldyBkZXRhaWxzLCB0aGlzIGlzIGFuIGludmVyc2Ugb2YgdGhlIHRyYW5zZm9ybSBmdW5jdGlvbi5cclxuXHQgKiBAcGFyYW0ge3NtYXJ0Z2FtZXxzdHJpbmd9IHdyYXBwZWRHYW1lXHJcblx0ICogQHBhcmFtIHtzbWFydGdhbWV9IHNtYXJ0Z2FtZVxyXG5cdCAqIEBwdWJsaWNcclxuXHQgKi9cclxuXHRmdW5jdGlvbiBpbnZlcnNlVHJhbnNmb3JtKFxyXG5cdFx0d3JhcHBlZEdhbWUsIHNtYXJ0Z2FtZSkge1xyXG5cclxuXHRcdGlmIChzbWFydGdhbWUgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRzbWFydGdhbWUgPSByZXF1aXJlKCdzbWFydGdhbWUnKVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0eXBlb2Ygd3JhcHBlZEdhbWUgPT09ICdzdHJpbmcnKSB7XHJcblx0XHRcdHZhciBzbWFydGdhbWVyID0gcmVxdWlyZSgnc21hcnRnYW1lcicpXHJcblx0XHRcdHdyYXBwZWRHYW1lID0gc21hcnRnYW1lcihzbWFydGdhbWUucGFyc2Uod3JhcHBlZEdhbWUpKVxyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBub2RlID0gd3JhcHBlZEdhbWUuZmlyc3QoKS5ub2RlKClcclxuXHRcdFx0LCBwZW5kaW5nID0gW11cclxuXHRcdFx0LCBjdXJyZW50UGF0aCA9IHsgbTogMCB9XHJcblx0XHRcdCwgY2xlYW5lclJlZ0V4ID0gL15bYS16QS1aIDowLTlcXC0oXFxyXFxuXStHb1ZhcmlhbnRzVHJhbnNmb3JtZXJcXCktLVtcXHJcXG5dKi9cclxuXHRcdFx0LCBjbGVhbkNvbW1lbnRzID0gKCkgPT4ge1xyXG5cdFx0XHRcdGlmIChub2RlLkMgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdFx0bm9kZS5DID0gbm9kZS5DLnJlcGxhY2UoY2xlYW5lclJlZ0V4LCAnJylcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKG5vZGUuQyA9PT0gJycpXHJcblx0XHRcdFx0XHRkZWxldGUgbm9kZS5DXHJcblx0XHRcdH1cclxuXHRcdFx0LFxyXG5cdFx0XHQvKipcclxuXHRcdFx0ICogRnVuY3Rpb24gdG86XHJcblx0XHRcdCAqIFx0LSByZW1vdmUgdGhlIOKAnGJvcmRlcuKAnSAodW5pY29kZSBzeW1ib2xzIGFkZGVkIGJ5IHRoZSB0cmFuc2Zvcm0gdG8gaW5kaWNhdGUgd2hlcmUgdGhlIHdyYXBhcm91bmQgYXJlYSBtZWV0cyB0aGUgbWFpbiBncmlkKS5cclxuXHRcdFx0ICogXHQtIHJlbW92ZSBDTSAoY29sb3VyIG1hcCkgYW5kIENUIChjb2xvdXIgdGFibGUpIHdoaWNoIGFyZSBub25zdGFuZGFyZCBTR0YgYWRkZWQgYnkgQ0dvYm9hcmQgZm9yIGJhY2tncm91bmQgY29sb3VyIChjb3VsZCBiZSBpbnRlcmVzdGluZyB0byB1c2UgdGhpcyBmZWF0dXJlIGxhdGVyIG9uKS5cclxuXHRcdFx0ICovXHJcblx0XHRcdGNsZWFuTGFiZWxzID0gKCkgPT4ge1xyXG5cclxuXHRcdFx0XHRsZXQgbGFiZWxzID0gW11cclxuXHRcdFx0XHRpZiAobm9kZS5MQiAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHRsYWJlbHMgPSBub2RlLkxCXHJcblx0XHRcdFx0XHRpZiAoIUFycmF5LmlzQXJyYXkobGFiZWxzKSlcclxuXHRcdFx0XHRcdFx0bGFiZWxzID0gW2xhYmVsc11cclxuXHRcdFx0XHRcdGxhYmVscyA9IGxhYmVscy5maWx0ZXIoaSA9PiAhJC53cmFwYXJvdW5kQW5kQ29vcmRzLmluY2x1ZGVzKGkpKVxyXG5cdFx0XHRcdFx0LyoganNoaW50IGxvb3BmdW5jOiB0cnVlICovXHJcblx0XHRcdFx0XHRsYWJlbHMgPVxyXG5cdFx0XHRcdFx0XHRfdW5pcUJ5KFxyXG5cdFx0XHRcdFx0XHRcdGxhYmVsc1xyXG5cdFx0XHRcdFx0XHRcdFx0Lm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5zcGxpdCgnOicsIDIpIH0pLy9hc3N1bWUgdGhlIGxhYmVsIGRvZXNu4oCZdCBjb250YWluIOKAnDrigJ1cclxuXHRcdFx0XHRcdFx0XHRcdC5tYXAoKHgpID0+IFskLmNvb3JkczJTdHJpbmcoJC5pbnZlcnNlUHJvamVjdE9uRmxhdCh0cmFuc2xhdGVDb29yZGluYXRlcyh4WzBdKSkpLCB4WzFdXSlcclxuXHRcdFx0XHRcdFx0XHQsICh4KSA9PiB4WzBdKVxyXG5cdFx0XHRcdFx0XHRcdC5tYXAoKHgpID0+IGAke3hbMF19OiR7eFsxXX1gKVxyXG5cclxuXHJcblx0XHRcdFx0XHQvLyBsYWJlbHMgPSBbXVxyXG5cdFx0XHRcdFx0Ly8gZm9yIChsZXQgaSA9IDA7IGkgPCBsYWJlbHMyLmxlbmd0aDsgaSsrKVxyXG5cdFx0XHRcdFx0Ly8gXHRsYWJlbHMgPSBsYWJlbHMuY29uY2F0KGxhYmVsczIpXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRub2RlLkxCID0gbGFiZWxzXHJcblx0XHRcdFx0aWYgKG5vZGUuTEIubGVuZ3RoID09PSAwKVxyXG5cdFx0XHRcdFx0ZGVsZXRlIG5vZGUuTEJcclxuXHJcblx0XHRcdFx0aWYgKG5vZGUuQ00pXHJcblx0XHRcdFx0XHRkZWxldGUgbm9kZS5DTVxyXG5cdFx0XHRcdGlmIChub2RlLkNUKVxyXG5cdFx0XHRcdFx0ZGVsZXRlIG5vZGUuQ1RcclxuXHRcdFx0fVxyXG5cclxuXHRcdGNsZWFuTGFiZWxzKClcclxuXHRcdG5vZGUuU1ogPSBvcHRpb25zLmJvYXJkRGltZW5zaW9uc1swXVxyXG5cdFx0bm9kZS5BUCA9IFwiZ28tdmFyaWFudHMtdHJhbnNmb3JtZXJcIlxyXG5cclxuXHRcdGlmIChub2RlLlNPICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0bGV0IGNsZWFuU291cmNlUmVnZXggPSBuZXcgUmVnRXhwKGAgXFxcXCgke3NvdXJjZVNnZk1lc3NhZ2V9XFxcXClgKVxyXG5cdFx0XHRub2RlLlNPID0gbm9kZS5TTy5yZXBsYWNlKGNsZWFuU291cmNlUmVnZXgsICcnKVxyXG5cdFx0XHQvLyBpZiAobm9kZS5TTyA9PT0gJycpXHJcblx0XHRcdC8vIFx0ZGVsZXRlIG5vZGUuU09cclxuXHRcdH1cclxuXHJcblx0XHRsZXQgc3RhdGUgPSB7XHJcblx0XHRcdHdyYXBwZWRHYW1lLCBub2RlLCBwZW5kaW5nLCBjdXJyZW50UGF0aCwgc2libGluZ01vdmVzOiB7fS8vLCBwYXJlbnRzV2l0aENoaWxkVG9EZWxldGU6IFtdIFxyXG5cdFx0fVxyXG5cclxuXHRcdG5vZGUgPSBnb1Rocm91Z2hUcmVlKHN0YXRlKVxyXG5cdFx0d2hpbGUgKG5vZGUgIT09IG51bGwpIHtcclxuXHRcdFx0Y2xlYW5MYWJlbHMoKVxyXG5cdFx0XHRjbGVhbkNvbW1lbnRzKClcclxuXHJcblx0XHRcdGNvbnN0XHJcblx0XHRcdFx0aXNCbGFjayA9IG5vZGUuQUIgIT09IHVuZGVmaW5lZCB8fCBub2RlLkIgIT09IHVuZGVmaW5lZFxyXG5cdFx0XHRcdCwgYWRkZWRTdG9uZXMgPSBpc0JsYWNrID8gbm9kZS5BQiA6IG5vZGUuQVdcclxuXHRcdFx0XHQsIHBsYXllZFN0b25lID0gaXNCbGFjayA/IG5vZGUuQiA6IG5vZGUuV1xyXG5cdFx0XHRcdCwgbW92ZSA9IGFkZGVkU3RvbmVzID8gYWRkZWRTdG9uZXMgOiBwbGF5ZWRTdG9uZVxyXG5cdFx0XHRcdCwgbW92ZUFzQXJyYXkgPSBBcnJheS5pc0FycmF5KG1vdmUpID8gbW92ZSA6IFttb3ZlXVxyXG5cdFx0XHRcdCwgaXNBUGFzcyA9IGlzQmxhY2sgPyBub2RlLkIgPT09ICcnIDogbm9kZS5XID09PSAnJ1xyXG5cdFx0XHRcdCwgbW92ZUhhc0Nvb3JkcyA9IG1vdmUgIT09IHVuZGVmaW5lZCAmJiBtb3ZlICE9PSAnJ1xyXG5cdFx0XHRcdCwgY29vcmRzID0gIW1vdmVIYXNDb29yZHMgPyB1bmRlZmluZWQgOiAkLmNvb3JkczJTdHJpbmcoJC5pbnZlcnNlUHJvamVjdE9uRmxhdChtb3ZlQXNBcnJheS5tYXAodHJhbnNsYXRlQ29vcmRpbmF0ZXMpKSlcclxuXHJcblx0XHRcdC8vYWx0ZXIgdGhlIG5vZGVcclxuXHJcblx0XHRcdC8qXHJcblx0XHRcdGxvZ2ljIHJlbW92aW5nIGEgbm9kZSBhZGRlZCBieSBDR29ib2FyZCwgaWYgdGhlcmUgYWxyZWFkeSBpcyB0aGUgc2FtZSBtb3ZlIGFzIEFCIG9yIEFXIGluIGEgcHJpb3IgdmFyaWF0aW9uOyBhc3N1bWluZyBcclxuXHRcdFx0dGhlIHZhcmlhdGlvbiB0byBiZSByZW1vdmVkIGlzIHRoZSBsYXN0IG9mIHRoZSBzaWJsaW5ncyAtIHdoaWNoIGRvZXMgc2VlbSB0byBiZSB0aGUgd2F5IENHb2JvYXJkIGJlaGF2ZXMgd2hlbiBhIGNsaWNrIFxyXG5cdFx0XHRpcyBtYWRlIG9uIGEgcG9pbnQgd2hlcmUgdGhlIG5leHQgbm9kZSBpcyBBQiBvciBBVy4gIFxyXG5cdFx0XHQqL1xyXG5cdFx0XHRpZiAoc3RhdGUuaGFzU2libGluZ3MpIHtcclxuXHRcdFx0XHRsZXQgcGF0aEZvclBhcmVudCA9IHsgLi4ud3JhcHBlZEdhbWUucGF0aCB9IC8vT2JqZWN0LmFzc2lnbih7fSwgd3JhcHBlZEdhbWUucGF0aClcclxuXHRcdFx0XHRwYXRoRm9yUGFyZW50Lm0tLVxyXG5cdFx0XHRcdGRlbGV0ZSBwYXRoRm9yUGFyZW50W3BhdGhGb3JQYXJlbnQubV1cclxuXHRcdFx0XHRwYXRoRm9yUGFyZW50ID0gd3JhcHBlZEdhbWUucGF0aFRyYW5zZm9ybShwYXRoRm9yUGFyZW50KVxyXG5cdFx0XHRcdC8vIHdyYXBwZWRHYW1lLnByZXZpb3VzKClcclxuXHRcdFx0XHRpZiAoc3RhdGUuc2libGluZ01vdmVzW3BhdGhGb3JQYXJlbnRdID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRcdHN0YXRlLnNpYmxpbmdNb3Zlc1twYXRoRm9yUGFyZW50XSA9IFtdXHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmIChhZGRlZFN0b25lcykge1xyXG5cdFx0XHRcdFx0c3RhdGUuc2libGluZ01vdmVzW3BhdGhGb3JQYXJlbnRdLnB1c2goY29vcmRzKVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHRpZiAocGxheWVkU3RvbmUgJiYgc3RhdGUuc2libGluZ01vdmVzW3BhdGhGb3JQYXJlbnRdLmluZGV4T2YoY29vcmRzKSA+IC0xKSB7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBzdGF0ZS5wYXJlbnRzV2l0aENoaWxkVG9EZWxldGUucHVzaChwYXRoRm9yUGFyZW50KVxyXG5cdFx0XHRcdFx0XHRub2RlLlhYID0gXCJpbnZlcnNlVHJhbnNmb3JtVG9EZWxldGVcIlxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdC8vIHdyYXBwZWRHYW1lLmdvVG8oY3VycmVudFBhdGgpXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGRlbGV0ZSBub2RlW2lzQmxhY2sgPyAnQUInIDogJ0FXJ11cclxuXHRcdFx0ZGVsZXRlIG5vZGVbaXNCbGFjayA/ICdCJyA6ICdXJ11cclxuXHRcdFx0ZGVsZXRlIG5vZGUuQ1JcclxuXHRcdFx0ZGVsZXRlIG5vZGUuQUVcclxuXHJcblx0XHRcdGlmIChpc0FQYXNzKSB7XHJcblx0XHRcdFx0bm9kZVtpc0JsYWNrID8gJ0InIDogJ1cnXSA9ICcnXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChtb3ZlSGFzQ29vcmRzKSB7XHJcblx0XHRcdFx0bm9kZVtpc0JsYWNrID8gJ0InIDogJ1cnXSA9IGNvb3Jkc1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQ7Lypub3RlOiB0aGlzIG5leHQgc2VtaWNvbG9uIGlzIG5lZWRlZCEgKi9bLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1leHRyYS1zZW1pXHJcblx0XHRcdFx0Ly8nQ1InLHRvZG86IGFkZCBpZiBub3QgbWFya2luZyB0aGUgbW92ZVxyXG5cdFx0XHRcdCdERCcsICdNQScsICdTTCcsICdTUScsICdUUiddLmZvckVhY2goZnVuY3Rpb24gKHNnZlByb3BlcnR5KSB7XHJcblx0XHRcdFx0XHQvLyBfLm1hcChbJ0REJywnTUEnLCdTTCcsJ1NRJywnVFInXSwgZnVuY3Rpb24oc2dmUHJvcGVydHkpe1xyXG5cdFx0XHRcdFx0aWYgKG5vZGVbc2dmUHJvcGVydHldID09PSB1bmRlZmluZWQpIHJldHVyblxyXG5cdFx0XHRcdFx0bGV0IHBvaW50cyA9IFtdXHJcblx0XHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheShub2RlW3NnZlByb3BlcnR5XSkpIHtcclxuXHRcdFx0XHRcdFx0cG9pbnRzID0gbm9kZVtzZ2ZQcm9wZXJ0eV1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRwb2ludHMgPSBbbm9kZVtzZ2ZQcm9wZXJ0eV1dXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRwb2ludHMgPVxyXG5cdFx0XHRcdFx0XHQkLmludmVyc2VQcm9qZWN0T25GbGF0KFxyXG5cdFx0XHRcdFx0XHRcdHBvaW50cy5tYXAodHJhbnNsYXRlQ29vcmRpbmF0ZXMpLCB0cnVlXHJcblx0XHRcdFx0XHRcdClcclxuXHRcdFx0XHRcdFx0XHQubWFwKCQuY29vcmRzMlN0cmluZylcclxuXHRcdFx0XHRcdG5vZGVbc2dmUHJvcGVydHldID0gcG9pbnRzXHJcblx0XHRcdFx0fSlcclxuXHRcdFx0Ly8gbW92ZSB0byBuZXh0IG5vZGVcclxuXHRcdFx0bm9kZSA9IGdvVGhyb3VnaFRyZWUoc3RhdGUpXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gc3RhdGUucGFyZW50c1dpdGhDaGlsZFRvRGVsZXRlLmZvckVhY2goKHBhdGgpID0+IHtcclxuXHRcdC8vIFx0Ly9yZW1vdmUgdGhlIHNnZiBub2RlXHJcblx0XHQvLyBcdHdyYXBwZWRHYW1lLmdvVG8ocGF0aClcclxuXHRcdC8vIFx0bGV0IHNlcXVlbmNlcyA9IHdyYXBwZWRHYW1lLmdhbWUuc2VxdWVuY2VzXHJcblx0XHQvLyBcdGxldCBpbmRleCA9IF9maShzZXF1ZW5jZXMsIChzZXEpID0+IHNlcS5ub2Rlc1swXS5pbnZlcnNlVHJhbnNmb3JtVG9EZWxldGUpXHJcblx0XHQvLyBcdFx0LCB0bXBJID0gMFxyXG5cdFx0Ly8gXHR3aGlsZSAoaW5kZXggPiAtMSkge1xyXG5cdFx0Ly8gXHRcdHNlcXVlbmNlcy5zcGxpY2UoaW5kZXgsIDEpXHJcblx0XHQvLyBcdFx0aW5kZXggPSBfZmkoc2VxdWVuY2VzLCAoc2VxKSA9PiBzZXEubm9kZXNbMF0uaW52ZXJzZVRyYW5zZm9ybVRvRGVsZXRlKVxyXG5cdFx0Ly8gXHRcdHRtcEkrK1xyXG5cdFx0Ly8gXHRcdGlmICh0bXBJID4gMTAwKSB0aHJvdyBuZXcgRXJyb3IoJ3NlZW0gdG8gYmUgc3R1Y2shJyk7XHJcblx0XHQvLyBcdH1cclxuXHJcblx0XHQvLyBcdC8vIGNvbnNvbGUubG9nKHBhdGgpXHJcblx0XHQvLyB9KVxyXG5cclxuXHRcdGxldCBkZWxldGVOb2RlcyA9IChzZXF1ZW5jZSkgPT4ge1xyXG5cdFx0XHRpZiAoc2VxdWVuY2Uuc2VxdWVuY2VzKSB7XHJcblxyXG5cdFx0XHRcdGxldFxyXG5cdFx0XHRcdFx0c2VxdWVuY2VzID0gc2VxdWVuY2Uuc2VxdWVuY2VzXHJcblx0XHRcdFx0XHQsIGluZGV4ID0gX2ZpKHNlcXVlbmNlcywgKHNlcSkgPT4gc2VxLm5vZGVzWzBdLlhYID09PSAnaW52ZXJzZVRyYW5zZm9ybVRvRGVsZXRlJylcclxuXHRcdFx0XHRcdCwgdG1wSSA9IDAsIG1heCA9IHNlcXVlbmNlcy5sZW5ndGhcclxuXHRcdFx0XHR3aGlsZSAoaW5kZXggPiAtMSkge1xyXG5cdFx0XHRcdFx0c2VxdWVuY2VzLnNwbGljZShpbmRleCwgMSlcclxuXHRcdFx0XHRcdGluZGV4ID0gX2ZpKHNlcXVlbmNlcywgKHNlcSkgPT4gc2VxLm5vZGVzWzBdLlhYID09PSAnaW52ZXJzZVRyYW5zZm9ybVRvRGVsZXRlJylcclxuXHRcdFx0XHRcdHRtcEkrK1xyXG5cdFx0XHRcdFx0aWYgKHRtcEkgPiBtYXgpIHRocm93IG5ldyBFcnJvcignc2VlbSB0byBiZSBzdHVjayEnKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Zm9yIChsZXQgaW5kZXgyID0gMDsgaW5kZXgyIDwgc2VxdWVuY2VzLmxlbmd0aDsgaW5kZXgyKyspIHtcclxuXHRcdFx0XHRcdC8vIGRlbGV0ZU5vZGVzKHNlcXVlbmNlc1tpbmRleDJdLm5vZGVzW3NlcXVlbmNlc1tpbmRleDJdLm5vZGVzLmxlbmd0aCAtIDFdKTtcclxuXHRcdFx0XHRcdGRlbGV0ZU5vZGVzKHNlcXVlbmNlc1tpbmRleDJdKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2UgaWYgKHNlcXVlbmNlLm5vZGVzKVxyXG5cdFx0XHRcdGRlbGV0ZU5vZGVzKHNlcXVlbmNlLm5vZGVzW3NlcXVlbmNlLm5vZGVzLmxlbmd0aCAtIDFdKVxyXG5cdFx0fVxyXG5cdFx0ZGVsZXRlTm9kZXMod3JhcHBlZEdhbWUuZ2FtZSlcclxuXHJcblx0XHRpZiAob3B0aW9ucy50cmFuc2Zvcm1Ub1N0cmluZylcclxuXHRcdFx0cmV0dXJuIHNtYXJ0Z2FtZS5nZW5lcmF0ZSh7IGdhbWVUcmVlczogW3dyYXBwZWRHYW1lLmdhbWVdIH0pO1xyXG5cdFx0ZWxzZSByZXR1cm4gd3JhcHBlZEdhbWVcclxuXHJcblx0fVxyXG5cdCQuaW52ZXJzZVRyYW5zZm9ybSA9IGludmVyc2VUcmFuc2Zvcm1cclxuXHJcblx0LyoqXHJcblx0ICogTWFpbiBmdW5jdGlvbjsgY29udmVydHMgU0dGIGZvciBhIEdvIHZhcmlhbnQgKHNvIGZhciwganVzdCB0b3JvaWRhbCBHbyBvciB0LUdvKS5cclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdFNnZlxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB0R28gRW5naW5lIGZvciBjb3VudGluZyBsaWJlcnRpZXMgaW4gdC1Hby4gQW4gaW5zdGFuY2Ugb2YgZ28tdmFyaWFudHMtZW5naW5lLlxyXG5cdCAqIEBwYXJhbSB7Kn0gc21hcnRnYW1lXHJcblx0ICogQHBhcmFtIHsqfSBzbWFydGdhbWVyXHJcblx0ICogQHJldHVybnMge3N0cmluZ3xvYmplY3R9IFNHRiB0aGF0IGNhbiBiZSB2aWV3ZWQgaW4gYSBzdGFuZGFyZCBTR0Ygdmlld2VyLiAoU2VlIGBvcHRpb25zLnRyYW5zZm9ybVRvU3RyaW5nYCBmb3IgdGhlIGRhdGEgdHlwZSBvZiB0aGUgdmFsdWUgcmV0dXJuZWQuKVxyXG5cdCAqIEBwdWJsaWNcclxuXHQgKi9cclxuXHRmdW5jdGlvbiB0cmFuc2Zvcm0oXHJcblx0XHR0U2dmIC8vZWcgMTF4MTEgc2dmIGZyb20gTGl0dGxlR29sZW1cclxuXHRcdCwgdEdvIC8vYXBwIGltcGxlbWVudGluZyB0LUdvXHJcblx0XHQsIHNtYXJ0Z2FtZVxyXG5cdFx0LCBzbWFydGdhbWVyKSB7XHJcblxyXG5cdFx0aWYgKHRHbyA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdC8vICB0R28gPSByZXF1aXJlKCcuLi9kaXN0L25vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvc3JjL2VuZ2luZS5taW4uanMnKSh7XHJcblx0XHRcdC8vICB0R28gPSByZXF1aXJlKCcuLi8uLi9lbmdpbmUvZGlzdC9lbmdpbmUubWluLmpzJykoe1xyXG5cdFx0XHR0R28gPSByZXF1aXJlKCdnby12YXJpYW50cy1lbmdpbmUnKSh7XHJcblx0XHRcdFx0Ly8gdEdvID0gcmVxdWlyZSgnLi4vbm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9zcmMvZW5naW5lJykoe1xyXG5cdFx0XHRcdC8vIGJvYXJkTW9kZTondCcsXHJcblx0XHRcdFx0Ym9hcmREaW1lbnNpb25zOiBvcHRpb25zLmJvYXJkRGltZW5zaW9uc1xyXG5cdFx0XHR9KVxyXG5cdFx0XHQvLyB0R28gPSByZXF1aXJlKCcuLi9ub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lJykoe2JvYXJkTW9kZTondCcsIGJvYXJkRGltZW5zaW9uczpvcHRpb25zLmJvYXJkRGltZW5zaW9uc30pXHJcblx0XHRcdC8vIHRHbyA9IHJlcXVpcmUoJy4uL25vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvc3JjL2VuZ2luZScpKHtib2FyZE1vZGU6J3QnLCBib2FyZERpbWVuc2lvbnM6b3B0aW9ucy5ib2FyZERpbWVuc2lvbnN9KVxyXG5cdFx0fVxyXG5cdFx0Ly8gZWxzZSB7XHJcblx0XHQvLyBcdHRHby5vcHRpb25zLmJvYXJkRGltZW5zaW9ucyA9IG9wdGlvbnMuYm9hcmREaW1lbnNpb25zXHJcblx0XHQvLyB9XHJcblxyXG5cdFx0aWYgKHNtYXJ0Z2FtZSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHNtYXJ0Z2FtZSA9IHJlcXVpcmUoJ3NtYXJ0Z2FtZScpXHJcblx0XHR9XHJcblx0XHRpZiAoc21hcnRnYW1lciA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHNtYXJ0Z2FtZXIgPSByZXF1aXJlKCdzbWFydGdhbWVyJylcclxuXHRcdH1cclxuXHRcdC8vIGNvbnNvbGUubG9nKHRHbylcclxuXHRcdGxldCBwYXJzZWQgPSBzbWFydGdhbWUucGFyc2UodFNnZilcclxuXHRcdFx0LCB3cmFwcGVkR2FtZSA9IHNtYXJ0Z2FtZXIocGFyc2VkKVxyXG5cdFx0XHQsIG5vZGUgPSB3cmFwcGVkR2FtZS5ub2RlKClcclxuXHRcdFx0LCBwYXNzZXMgPSAwXHJcblx0XHRcdCwgcGVuZGluZyA9IFtdXHJcblx0XHRcdCwgY3VycmVudFBhdGggPSB7IG06IDAgfVxyXG5cdFx0aWYgKG5vZGUuU1ogIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRsZXQgc3ogPSBOdW1iZXIobm9kZS5TWilcclxuXHRcdFx0Ly8gc3orPSAyKm9wdGlvbnMucHJvamVjdGlvblNldHRpbmdzLndyYXBhcm91bmRcclxuXHRcdFx0b3B0aW9ucy5ib2FyZERpbWVuc2lvbnMgPSBbc3osIHN6XVxyXG5cdFx0XHR0R28ub3B0aW9ucy5ib2FyZERpbWVuc2lvbnMgPSBvcHRpb25zLmJvYXJkRGltZW5zaW9uc1xyXG5cdFx0XHRzZXRVcE1hcmtlcnMoKVxyXG5cdFx0fVxyXG5cdFx0aWYgKG5vZGUuS00gIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRvcHRpb25zLnJ1bGVzID0geyBrb21pOiBwYXJzZUZsb2F0KG5vZGUuS00pLCAuLi5vcHRpb25zLnJ1bGVzIH1cclxuXHRcdH1cclxuXHRcdG5vZGUuU1ogPSBcIlwiICsgKG9wdGlvbnMuYm9hcmREaW1lbnNpb25zWzBdICsgMiAqIG9wdGlvbnMucHJvamVjdGlvblNldHRpbmdzLndyYXBhcm91bmQpLy9ub3Qgc3VyZSBob3cgdG8gbWFrZSBhIHJlY3Rhbmd1bGFyIGdvYmFuIVxyXG5cdFx0Ly9vZmZzZXQgbW9kdWxvXHJcblx0XHRvcHRpb25zLnByb2plY3Rpb25TZXR0aW5ncy5vZmZzZXRbMF0gPSBtb2R1bG8ob3B0aW9ucy5wcm9qZWN0aW9uU2V0dGluZ3Mub2Zmc2V0WzBdLCBvcHRpb25zLmJvYXJkRGltZW5zaW9uc1swXSlcclxuXHRcdG9wdGlvbnMucHJvamVjdGlvblNldHRpbmdzLm9mZnNldFsxXSA9IG1vZHVsbyhvcHRpb25zLnByb2plY3Rpb25TZXR0aW5ncy5vZmZzZXRbMV0sIG9wdGlvbnMuYm9hcmREaW1lbnNpb25zWzFdKVxyXG5cdFx0bGV0IHNldExhYmVscyA9ICgpID0+IHtcclxuXHRcdFx0Ly9ub2RlLkxCID0gJC53cmFwYXJvdW5kQW5kQ29vcmRzXHJcblx0XHRcdGxldCBsYWJlbHMgPSBbXVxyXG5cdFx0XHRpZiAobm9kZS5MQiAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0bGFiZWxzID0gbm9kZS5MQlxyXG5cdFx0XHRcdGlmICghQXJyYXkuaXNBcnJheShsYWJlbHMpKVxyXG5cdFx0XHRcdFx0bGFiZWxzID0gW2xhYmVsc11cclxuXHJcblx0XHRcdFx0LyoganNoaW50IGxvb3BmdW5jOiB0cnVlICovXHJcblx0XHRcdFx0bGV0IGxhYmVsczIgPSBsYWJlbHMvL18uY2hhaW4obGFiZWxzKVxyXG5cdFx0XHRcdFx0Lm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5zcGxpdCgnOicsIDIpIH0pLy9hc3N1bWUgdGhlIGxhYmVsIGRvZXNu4oCZdCBjb250YWluIOKAnDrigJ1cclxuXHRcdFx0XHRcdC5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIFt0cmFuc2xhdGVDb29yZGluYXRlcyh4WzBdKSwgeFsxXV0gfSlcclxuXHRcdFx0XHRcdC5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIFskLnByb2plY3RPbkZsYXQoeFswXSksIHhbMV1dIH0pXHJcblx0XHRcdFx0Ly8gLnZhbHVlKClcclxuXHRcdFx0XHRsYWJlbHMgPSBbXVxyXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGFiZWxzMi5sZW5ndGg7IGkrKylcclxuXHRcdFx0XHRcdGxhYmVscyA9IGxhYmVscy5jb25jYXQoXHJcblx0XHRcdFx0XHRcdGxhYmVsczJbaV1bMF0ubWFwKGZ1bmN0aW9uICh4KSB7XHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuICQuY29vcmRzMlN0cmluZyh4KSArIFwiOlwiICsgbGFiZWxzMltpXVsxXVxyXG5cdFx0XHRcdFx0XHR9KVxyXG5cdFx0XHRcdFx0KVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRub2RlLkxCID0gJC53cmFwYXJvdW5kQW5kQ29vcmRzLmNvbmNhdChsYWJlbHMpXHJcblx0XHRcdGlmIChub2RlLkxCLmxlbmd0aCA9PT0gMClcclxuXHRcdFx0XHQvLyBkZWxldGUgbm9kZVsnTEInXVxyXG5cdFx0XHRcdGRlbGV0ZSBub2RlLkxCXHJcblx0XHR9XHJcblxyXG5cdFx0c2V0TGFiZWxzKClcclxuXHJcblx0XHRpZiAobm9kZS5TTyAhPT0gdW5kZWZpbmVkKVxyXG5cdFx0XHRub2RlLlNPID0gd3JhcHBlZEdhbWUuZ2FtZS5ub2Rlc1swXS5TTyArIGAgKCR7c291cmNlU2dmTWVzc2FnZX0pYFxyXG5cdFx0Ly9lbHNlIG5vZGUuU08gPSBzb3VyY2VTZ2ZNZXNzYWdlLy9wcmVmZXIgbm90IHRvIGFkZCB0aGUgbWVzc2FnZSB3aGVuIG9yaWdpbmFsIFNnZiBoYXMgbm8gU08gaW5mby5cclxuXHJcblx0XHRub2RlLkFQID0gXCJnby12YXJpYW50cy10cmFuc2Zvcm1lclwiXHJcblxyXG5cclxuXHRcdGxldCBzdGF0ZSA9IHsgd3JhcHBlZEdhbWUsIG5vZGUsIHBlbmRpbmcsIGN1cnJlbnRQYXRoLCB0R28gfVxyXG5cclxuXHRcdGZ1bmN0aW9uIGNvbW1lbnQoaXNQYXNzLCBpc0JsYWNrLCBzY29yZSkge1xyXG5cdFx0XHRpZiAoIW9wdGlvbnMuYWRkQ29tbWVudHMgJiYgIXNjb3JlKVxyXG5cdFx0XHRcdHJldHVyblxyXG5cclxuXHRcdFx0bGV0IHIgPSAhb3B0aW9ucy5hZGRDb21tZW50cyA/XHJcblx0XHRcdFx0JydcclxuXHRcdFx0XHQ6ICdtb3ZlICcgKyBzdGF0ZS5jdXJyZW50UGF0aC5tICsgJ1xcbicgKyAnV2hpdGUgc3RvbmVzIGNhcHR1cmVkIGJ5IEJsYWNrOiAnICsgdEdvLmJvYXJkLmNhcHR1cmVkWzFdICsgJ1xcbkJsYWNrIHN0b25lcyBjYXB0dXJlZCBieSBXaGl0ZTogJyArIHRHby5ib2FyZC5jYXB0dXJlZFswXVxyXG5cdFx0XHRcdC8vbGV0IHIgPSAgJ0JsYWNrIGNhcHR1cmVzOiAnICsgdEdvLmJvYXJkLmNhcHR1cmVkWzFdICsgJ1xcclxcbldoaXRlIGNhcHR1cmVzOiAnICsgdEdvLmJvYXJkLmNhcHR1cmVkWzBdXHJcblx0XHRcdFx0KyAoIWlzUGFzcyA/ICcnIDogJ1xcbicgKyAoaXNCbGFjayA/ICdCbGFjayBwYXNzZXMnIDogJ1doaXRlIHBhc3NlcycpKVxyXG5cdFx0XHRcdCsgKCFzY29yZSA/ICcnIDogJ1xcbicgKyBgcmVzdWx0OiAke3Njb3JlLmRpc3BsYXlSZXN1bHR9YClcclxuXHJcblx0XHRcdHIgKz0gJ1xcbi0tKHRoZSBjb250ZW50IGFib3ZlIHdhcyBnZW5lcmF0ZWQgYXV0b21hdGljYWxseSBieSBHb1ZhcmlhbnRzVHJhbnNmb3JtZXIpLS0nXHJcblx0XHRcdHIgKz0gKG5vZGUuQyA9PT0gdW5kZWZpbmVkID8gJycgOiAnXFxuJyArIG5vZGUuQylcclxuXHRcdFx0bm9kZS5DID0gclxyXG5cdFx0XHRyZXR1cm5cclxuXHRcdH1cclxuXHJcblx0XHRub2RlID0gZ29UaHJvdWdoVHJlZShzdGF0ZSlcclxuXHRcdHdoaWxlIChub2RlICE9PSBudWxsKSB7XHJcblxyXG5cclxuXHRcdFx0bGV0XHJcblx0XHRcdFx0aXNCbGFjayA9IG5vZGUuQiAhPT0gdW5kZWZpbmVkXHJcblx0XHRcdFx0LCBtb3ZlID0gaXNCbGFjayA/IG5vZGUuQiA6IG5vZGUuV1xyXG5cdFx0XHRcdCwgaXNBUGFzcyA9IG1vdmUgPT09IFwiXCIgfHwgKG9wdGlvbnMuYm9hcmREaW1lbnNpb25zWzBdID09PSBvcHRpb25zLmJvYXJkRGltZW5zaW9uc1sxXVxyXG5cdFx0XHRcdFx0JiYgb3B0aW9ucy5ib2FyZERpbWVuc2lvbnNbMF0gPD0gMTlcclxuXHRcdFx0XHRcdCYmIG1vdmUgPT09IFwidHRcIiAvL3dlaXJkIFNHRlszXSB3YXkgdG8gc2hvdyBhIHBhc3MgbW92ZSFcclxuXHRcdFx0XHQpXHJcblx0XHRcdFx0LCBzdG9uZXNNYXJrZWRGb3JTY29yaW5nID0gW11cclxuXHJcblx0XHRcdGlmIChtb3ZlID09PSB1bmRlZmluZWQgJiYgIWlzQVBhc3MpIHtcclxuXHRcdFx0XHRub2RlID0gZ29UaHJvdWdoVHJlZShzdGF0ZSlcclxuXHRcdFx0XHRjb250aW51ZVxyXG5cdFx0XHR9XHJcblx0XHRcdHNldExhYmVscygpXHJcblxyXG5cdFx0XHRpZiAoaXNBUGFzcykge1xyXG5cdFx0XHRcdGRlbGV0ZSBub2RlW2lzQmxhY2sgPyAnQicgOiAnVyddXHJcblx0XHRcdFx0Y29tbWVudChpc0FQYXNzLCBpc0JsYWNrKVxyXG5cdFx0XHRcdG5vZGVbaXNCbGFjayA/ICdBQicgOiAnQVcnXSA9IFtdXHJcblx0XHRcdFx0Ly8gaWYgKHBhc3NlcyA9PT0gMikge1xyXG5cdFx0XHRcdC8vIFx0Ly93cmFwcGVkR2FtZS5nYW1lLm5vZGVzLnNwbGljZShpKzEpLy9nZXQgcmlkIG9mIG5vZGVzIGFmdGVyd2FyZHMgLS0gbWF5IG5vdCB3b3JrIHdpdGggdmFyaWF0aW9ucyEgdG9kb1xyXG5cdFx0XHRcdC8vIFx0YnJlYWs7Ly9zdG9wIGFmdGVyIDMgc3VjY2Vzc2l2ZSBwYXNzZXMgZm9yIG5vd1xyXG5cdFx0XHRcdC8vIH1cclxuXHRcdFx0XHRwYXNzZXMrK1xyXG5cdFx0XHRcdGlmIChwYXNzZXMgPj0gMTAwMClcclxuXHRcdFx0XHRcdGJyZWFrLy9qdXN0IGluIGNhc2UhXHJcblx0XHRcdFx0bm9kZSA9IGdvVGhyb3VnaFRyZWUoc3RhdGUpXHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0Y29uc3QgY29vcmRzID0gdHJhbnNsYXRlQ29vcmRpbmF0ZXMobW92ZSlcclxuXHRcdFx0XHRsZXQgcGxheVJlc3VsdCA9IG51bGxcclxuXHRcdFx0XHQvLyBydW4gbW92ZSB0aHJvdWdoIHRHbyBhbmQgdXBkYXRlIGdhbWUgYWNjb3JkaW5nbHlcclxuXHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0cGxheVJlc3VsdCA9IHRHby5wbGF5KGlzQmxhY2sgPyAnYicgOiAndycsIGNvb3JkcylcclxuXHJcblx0XHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcclxuXHRcdFx0XHRcdGlmIChlcnJvci5tZXNzYWdlICE9PSAncG9pbnQgaXMgbm90IGVtcHR5JyAvKmlnbm9yZSB0aGlzIC0gaXQgaGFwcGVucyB3aXRoIHNvbWUgc2dmIGZyb20gbGl0dGxlR29sZW0uIFRvZG86IGxvb2sgaW50byBzY29yaW5nIHRoZSBwb3NpdGlvbiBoZXJlLiAqLylcclxuXHRcdFx0XHRcdFx0dGhyb3cgKGVycm9yKVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRjb25zdCBwcm9qZWN0ZWRDb29yZHMgPSAkLnByb2plY3RPbkZsYXQoY29vcmRzKVxyXG5cdFx0XHRcdGxldCB0b0FkZCA9IHBsYXlSZXN1bHQgPT09IG51bGwgPyBbXSA6IHByb2plY3RlZENvb3Jkcy5tYXAoJC5jb29yZHMyU3RyaW5nKVxyXG5cdFx0XHRcdFx0LCB0b1JlbW92ZSA9IHBsYXlSZXN1bHQgPT09IG51bGwgPyBbXSA6XHJcblx0XHRcdFx0XHRcdC8vIF8uY2hhaW4ocGxheVJlc3VsdC5yZW1vdmVkKVxyXG5cdFx0XHRcdFx0XHQvLyBcdC5mbGF0dGVuKHRydWUpXHJcblx0XHRcdFx0XHRcdC8vIFx0Lm1hcCgkLnByb2plY3RPbkZsYXQpXHJcblx0XHRcdFx0XHRcdC8vIFx0LmZsYXR0ZW4odHJ1ZSlcclxuXHRcdFx0XHRcdFx0Ly8gXHQubWFwKCQuY29vcmRzMlN0cmluZylcclxuXHRcdFx0XHRcdFx0Ly8gXHQudmFsdWUoKVxyXG5cdFx0XHRcdFx0XHRfZmxhdHRlbihcclxuXHRcdFx0XHRcdFx0XHRfZmxhdHRlbihwbGF5UmVzdWx0LnJlbW92ZWQpXHJcblx0XHRcdFx0XHRcdFx0XHQubWFwKCQucHJvamVjdE9uRmxhdCkpXHJcblx0XHRcdFx0XHRcdFx0Lm1hcCgkLmNvb3JkczJTdHJpbmcpXHJcblxyXG5cdFx0XHRcdC8vYWx0ZXIgdGhlIG5vZGVcclxuXHRcdFx0XHRpZiAob3B0aW9ucy5tb3ZlVHlwZSA9PT0gMikge1xyXG5cdFx0XHRcdFx0bGV0IG1vdmVNYXJrZXIgPSBgJHtpc0JsYWNrID8gJ0InIDogJ1cnfWBcclxuXHRcdFx0XHRcdG5vZGVbbW92ZU1hcmtlcl0gPSB0b0FkZC5wb3AoKVxyXG5cdFx0XHRcdFx0aWYgKHRvQWRkLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0XHRcdFx0bm9kZVsnQScgKyBtb3ZlTWFya2VyXSA9IHRvQWRkXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRsZXQgbW92ZU1hcmtlciA9IGAke29wdGlvbnMubW92ZVR5cGUgPCAzID8gJ0EnIDogJyd9JHtpc0JsYWNrID8gJ0InIDogJ1cnfWBcclxuXHJcblx0XHRcdFx0XHRub2RlW21vdmVNYXJrZXJdID0gdG9BZGRcclxuXHRcdFx0XHRcdGlmIChvcHRpb25zLm1hcmtMYXN0TW92ZSkge1xyXG5cdFx0XHRcdFx0XHRub2RlW29wdGlvbnMubWFya0xhc3RNb3ZlXSA9IHRvQWRkXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAob3B0aW9ucy5tb3ZlVHlwZSA9PT0gMSlcclxuXHRcdFx0XHRcdG5vZGVbaXNCbGFjayA/ICdCJyA6ICdXJ10gPSAnJ1xyXG5cclxuXHJcblx0XHRcdFx0aWYgKHRvUmVtb3ZlLmxlbmd0aCA+IDApXHJcblx0XHRcdFx0XHRub2RlLkFFID0gdG9SZW1vdmVcclxuXHJcblx0XHRcdFx0XHRcdC8qXHJcblx0XHRcdFx0XHRcdHRvZG86IG90aGVyIHByb3BlcnRpZXMgd2l0aCBib2FyZCBjb29yZGluYXRlc1xyXG5cdFx0XHRcdFx0XHRMZWF2ZSBmb3Igbm93OlxyXG5cdFx0XHRcdFx0XHRBUlxyXG5cdFx0XHRcdFx0XHRMTlxyXG5cdFx0XHRcdFx0XHQqL1xyXG5cclxuXHRcdFx0XHRcdFx0Oy8qbm90ZSB0aGlzIHNlbWljb2xvbiBpcyBuZWVkZWQhICovXHJcblx0XHRcdFx0W1xyXG5cdFx0XHRcdFx0Ly8nQ1InLHRvZG86IGFkZCBpZiBub3QgbWFya2luZyB0aGUgbW92ZVxyXG5cdFx0XHRcdFx0J0REJywgJ01BJywgJ1NMJywgJ1NRJywgJ1RSJ10uZm9yRWFjaChmdW5jdGlvbiAoc2dmUHJvcGVydHkpIHtcclxuXHRcdFx0XHRcdFx0Ly8gXy5tYXAoWydERCcsJ01BJywnU0wnLCdTUScsJ1RSJ10sIGZ1bmN0aW9uKHNnZlByb3BlcnR5KXtcclxuXHRcdFx0XHRcdFx0aWYgKG5vZGVbc2dmUHJvcGVydHldID09PSB1bmRlZmluZWQpIHJldHVyblxyXG5cdFx0XHRcdFx0XHRsZXQgcG9pbnRzID0gW11cclxuXHRcdFx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkobm9kZVtzZ2ZQcm9wZXJ0eV0pKSB7XHJcblx0XHRcdFx0XHRcdFx0cG9pbnRzID0gbm9kZVtzZ2ZQcm9wZXJ0eV1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRwb2ludHMgPSBbbm9kZVtzZ2ZQcm9wZXJ0eV1dXHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0aWYgKG5vZGUuU0MgJiYgc2dmUHJvcGVydHkgPT09ICdNQScpIHtcclxuXHRcdFx0XHRcdFx0XHRzdG9uZXNNYXJrZWRGb3JTY29yaW5nID0geyAuLi5wb2ludHMgfVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdHBvaW50cyA9XHJcblx0XHRcdFx0XHRcdFx0Ly8gXy5jaGFpbihwb2ludHMpXHJcblx0XHRcdFx0XHRcdFx0Ly8gXHQubWFwKHRyYW5zbGF0ZUNvb3JkaW5hdGVzKVxyXG5cdFx0XHRcdFx0XHRcdC8vIFx0Lm1hcCgkLnByb2plY3RPbkZsYXQpXHJcblx0XHRcdFx0XHRcdFx0Ly8gXHQuZmxhdHRlbih0cnVlKVxyXG5cdFx0XHRcdFx0XHRcdC8vIFx0Lm1hcCgkLmNvb3JkczJTdHJpbmcpXHJcblx0XHRcdFx0XHRcdFx0Ly8gXHQudmFsdWUoKVxyXG5cdFx0XHRcdFx0XHRcdF9mbGF0dGVuKFxyXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnRzXHJcblx0XHRcdFx0XHRcdFx0XHRcdC5tYXAodHJhbnNsYXRlQ29vcmRpbmF0ZXMpXHJcblx0XHRcdFx0XHRcdFx0XHRcdC5tYXAoJC5wcm9qZWN0T25GbGF0KVxyXG5cdFx0XHRcdFx0XHRcdClcclxuXHRcdFx0XHRcdFx0XHRcdC5tYXAoJC5jb29yZHMyU3RyaW5nKVxyXG5cdFx0XHRcdFx0XHRub2RlW3NnZlByb3BlcnR5XSA9IHBvaW50c1xyXG5cdFx0XHRcdFx0fSlcclxuXHRcdFx0XHRpZiAob3B0aW9ucy5hZGRNb3ZlTnVtYmVyKSBcclxuXHRcdFx0XHRcdG5vZGUuTU4gPSBjdXJyZW50UGF0aC5tXHJcblx0XHRcdFx0XHRcclxuXHRcdFx0XHQvKlxyXG5cdFx0XHRcdFVzZSBhIGN1c3RvbSwgbmV3IFNHRiBwcm9wZXJ0eSwgU0MsIGluIG9yZGVyIHRvIHNlZSBpZiB0aGUgY3VycmVudCBwb3NpdGlvbiBzaG91bGQgYmUgc2NvcmVkLCBhbmQgaWYgc28sIHdoYXQgdG8gZG8gd2l0aCB0aGUgc2NvcmUuXHJcblx0XHRcdFx0SXTigJlzIGEgYml0IGZsYWcuICBcclxuXHRcdFx0XHQxXHTih5IgdXBkYXRlIHRoZSBjb21tZW50cyBmb3IgdGhlIG5vZGUgKHN1Y2NpbnQpLiBXaGVuIGZsYWdnZWQsIHRoZSBuZXh0IG9wdGlvbiBpcyBub3QgYXZhaWxhYmxlLlxyXG5cdFx0XHRcdDJcdOKHkiB1cGRhdGUgdGhlIGNvbW1lbnRzIGZvciB0aGUgbm9kZSAodmVyYm9zZSlcclxuXHRcdFx0XHQ0XHTih5IgdXBkYXRlIHRoZSBnYW1lIHJlc3VsdCAoUkUpIGZvciB0aGUgcm9vdCBub2RlXHJcblx0XHRcdFx0VHlwaWNhbCB1c2FnZTogYWRkIOKAnFNDWzZd4oCdIHRvIHRoZSBsYXN0IG5vZGUsIGFuZCDigJxTQ1syXeKAnSB0byBzY29yZSBhIHZhcmlhdGlvbi5cclxuXHRcdFx0XHQqL1xyXG5cdFx0XHRcdGxldCB1cGRhdGVkQ29tbWVudCA9IGZhbHNlXHJcblx0XHRcdFx0aWYgKG5vZGUuU0MpIHtcclxuXHRcdFx0XHRcdGxldCBzY29yZSA9IGVuZ2luZS5zY29yZShzdG9uZXNNYXJrZWRGb3JTY29yaW5nKVxyXG5cdFx0XHRcdFx0aWYgKG5vZGUuU0MgJiAxID09PSAxKSB7XHJcblx0XHRcdFx0XHRcdHVwZGF0ZWRDb21tZW50ID0gdHJ1ZVxyXG5cdFx0XHRcdFx0XHRjb21tZW50KGlzQVBhc3MsIGlzQmxhY2ssIHNjb3JlLlJFKVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0ZWxzZSAvKmRvbid0IHdhbnQgdG8gdHJlYXQgc3VjY2ludCBhbmQgdmVyYm9zZSBhdCB0aGUgc2FtZSB0aW1lKi8gaWYgKG5vZGUuU0MgJiAyID09PSAyKSB7XHJcblx0XHRcdFx0XHRcdHVwZGF0ZWRDb21tZW50ID0gdHJ1ZVxyXG5cdFx0XHRcdFx0XHRjb21tZW50KGlzQVBhc3MsIGlzQmxhY2ssXHJcblx0XHRcdFx0XHRcdFx0YEJsYWNrOiAke3Njb3JlLnRvdGFsV2hpdGVEZWFkXHJcblx0XHRcdFx0XHRcdFx0KyBzY29yZS50b3RhbFdoaXRlQ2FwdHVyZWRcclxuXHRcdFx0XHRcdFx0XHQrIHNjb3JlLnRvdGFsQmxhY2tUZXJyaXRvcnl9ID0gJHtzY29yZS50b3RhbEJsYWNrVGVycml0b3J5fSB0ZXJyaXRvcnkgKyAke3Njb3JlLnRvdGFsV2hpdGVEZWFkICsgc2NvcmUudG90YWxXaGl0ZUNhcHR1cmVkfSBwcmlzb25lcnNcclxuV2hpdGU6ICR7c2NvcmUudG90YWxCbGFja0RlYWRcclxuXHRcdFx0XHRcdFx0XHQrIHNjb3JlLnRvdGFsQmxhY2tDYXB0dXJlZFxyXG5cdFx0XHRcdFx0XHRcdCsgc2NvcmUudG90YWxXaGl0ZVRlcnJpdG9yeX0gPSAke3Njb3JlLnRvdGFsV2hpdGVUZXJyaXRvcnl9IHRlcnJpdG9yeSArICR7c2NvcmUudG90YWxCbGFja0RlYWQgKyBzY29yZS50b3RhbEJsYWNrQ2FwdHVyZWR9IHByaXNvbmVycyArJHtlbmdpbmUucnVsZXMua29taX0ga29taWApXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiAobm9kZS5TQyAmIDQgPT09IDQpIHtcclxuXHRcdFx0XHRcdFx0d3JhcHBlZEdhbWUuZ2FtZS5ub2Rlc1swXS5SRSA9IHNjb3JlLlJFXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmICghdXBkYXRlZENvbW1lbnQpXHJcblx0XHRcdFx0XHRjb21tZW50KGlzQVBhc3MsIGlzQmxhY2spXHJcblxyXG5cdFx0XHRcdC8vIG1vdmUgdG8gbmV4dCBub2RlXHJcblx0XHRcdFx0bm9kZSA9IGdvVGhyb3VnaFRyZWUoc3RhdGUpXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGlmIChvcHRpb25zLnRyYW5zZm9ybVRvU3RyaW5nKVxyXG5cdFx0XHRyZXR1cm4gc21hcnRnYW1lLmdlbmVyYXRlKHsgZ2FtZVRyZWVzOiBbd3JhcHBlZEdhbWUuZ2FtZV0gfSk7XHJcblx0XHRlbHNlIHJldHVybiB3cmFwcGVkR2FtZVxyXG5cdH1cclxuXHQkLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxyXG5cdHJldHVybiAkXHJcblxyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gdHJhbnNmb3JtZXIiXX0="}