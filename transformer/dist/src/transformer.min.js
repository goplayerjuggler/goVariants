(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.go_variants_transformer = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;

},{"./_getNative":74,"./_root":115}],2:[function(require,module,exports){
var hashClear = require('./_hashClear'),
    hashDelete = require('./_hashDelete'),
    hashGet = require('./_hashGet'),
    hashHas = require('./_hashHas'),
    hashSet = require('./_hashSet');

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;

},{"./_hashClear":82,"./_hashDelete":83,"./_hashGet":84,"./_hashHas":85,"./_hashSet":86}],3:[function(require,module,exports){
var listCacheClear = require('./_listCacheClear'),
    listCacheDelete = require('./_listCacheDelete'),
    listCacheGet = require('./_listCacheGet'),
    listCacheHas = require('./_listCacheHas'),
    listCacheSet = require('./_listCacheSet');

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;

},{"./_listCacheClear":96,"./_listCacheDelete":97,"./_listCacheGet":98,"./_listCacheHas":99,"./_listCacheSet":100}],4:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;

},{"./_getNative":74,"./_root":115}],5:[function(require,module,exports){
var mapCacheClear = require('./_mapCacheClear'),
    mapCacheDelete = require('./_mapCacheDelete'),
    mapCacheGet = require('./_mapCacheGet'),
    mapCacheHas = require('./_mapCacheHas'),
    mapCacheSet = require('./_mapCacheSet');

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;

},{"./_mapCacheClear":101,"./_mapCacheDelete":102,"./_mapCacheGet":103,"./_mapCacheHas":104,"./_mapCacheSet":105}],6:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;

},{"./_getNative":74,"./_root":115}],7:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;

},{"./_getNative":74,"./_root":115}],8:[function(require,module,exports){
var MapCache = require('./_MapCache'),
    setCacheAdd = require('./_setCacheAdd'),
    setCacheHas = require('./_setCacheHas');

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

module.exports = SetCache;

},{"./_MapCache":5,"./_setCacheAdd":116,"./_setCacheHas":117}],9:[function(require,module,exports){
var ListCache = require('./_ListCache'),
    stackClear = require('./_stackClear'),
    stackDelete = require('./_stackDelete'),
    stackGet = require('./_stackGet'),
    stackHas = require('./_stackHas'),
    stackSet = require('./_stackSet');

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;

},{"./_ListCache":3,"./_stackClear":119,"./_stackDelete":120,"./_stackGet":121,"./_stackHas":122,"./_stackSet":123}],10:[function(require,module,exports){
var root = require('./_root');

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;

},{"./_root":115}],11:[function(require,module,exports){
var root = require('./_root');

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;

},{"./_root":115}],12:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;

},{"./_getNative":74,"./_root":115}],13:[function(require,module,exports){
/**
 * Adds the key-value `pair` to `map`.
 *
 * @private
 * @param {Object} map The map to modify.
 * @param {Array} pair The key-value pair to add.
 * @returns {Object} Returns `map`.
 */
function addMapEntry(map, pair) {
  // Don't return `map.set` because it's not chainable in IE 11.
  map.set(pair[0], pair[1]);
  return map;
}

module.exports = addMapEntry;

},{}],14:[function(require,module,exports){
/**
 * Adds `value` to `set`.
 *
 * @private
 * @param {Object} set The set to modify.
 * @param {*} value The value to add.
 * @returns {Object} Returns `set`.
 */
function addSetEntry(set, value) {
  // Don't return `set.add` because it's not chainable in IE 11.
  set.add(value);
  return set;
}

module.exports = addSetEntry;

},{}],15:[function(require,module,exports){
/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;

},{}],16:[function(require,module,exports){
/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;

},{}],17:[function(require,module,exports){
var baseTimes = require('./_baseTimes'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isBuffer = require('./isBuffer'),
    isIndex = require('./_isIndex'),
    isTypedArray = require('./isTypedArray');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;

},{"./_baseTimes":47,"./_isIndex":90,"./isArguments":133,"./isArray":134,"./isBuffer":136,"./isTypedArray":142}],18:[function(require,module,exports){
/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;

},{}],19:[function(require,module,exports){
/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;

},{}],20:[function(require,module,exports){
/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array == null ? 0 : array.length;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

module.exports = arrayReduce;

},{}],21:[function(require,module,exports){
/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

module.exports = arraySome;

},{}],22:[function(require,module,exports){
var baseAssignValue = require('./_baseAssignValue'),
    eq = require('./eq');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;

},{"./_baseAssignValue":26,"./eq":128}],23:[function(require,module,exports){
var eq = require('./eq');

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;

},{"./eq":128}],24:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    keys = require('./keys');

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;

},{"./_copyObject":61,"./keys":143}],25:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    keysIn = require('./keysIn');

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;

},{"./_copyObject":61,"./keysIn":144}],26:[function(require,module,exports){
var defineProperty = require('./_defineProperty');

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;

},{"./_defineProperty":65}],27:[function(require,module,exports){
var Stack = require('./_Stack'),
    arrayEach = require('./_arrayEach'),
    assignValue = require('./_assignValue'),
    baseAssign = require('./_baseAssign'),
    baseAssignIn = require('./_baseAssignIn'),
    cloneBuffer = require('./_cloneBuffer'),
    copyArray = require('./_copyArray'),
    copySymbols = require('./_copySymbols'),
    copySymbolsIn = require('./_copySymbolsIn'),
    getAllKeys = require('./_getAllKeys'),
    getAllKeysIn = require('./_getAllKeysIn'),
    getTag = require('./_getTag'),
    initCloneArray = require('./_initCloneArray'),
    initCloneByTag = require('./_initCloneByTag'),
    initCloneObject = require('./_initCloneObject'),
    isArray = require('./isArray'),
    isBuffer = require('./isBuffer'),
    isObject = require('./isObject'),
    keys = require('./keys');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, baseClone, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;

},{"./_Stack":9,"./_arrayEach":15,"./_assignValue":22,"./_baseAssign":24,"./_baseAssignIn":25,"./_cloneBuffer":53,"./_copyArray":60,"./_copySymbols":62,"./_copySymbolsIn":63,"./_getAllKeys":70,"./_getAllKeysIn":71,"./_getTag":79,"./_initCloneArray":87,"./_initCloneByTag":88,"./_initCloneObject":89,"./isArray":134,"./isBuffer":136,"./isObject":139,"./keys":143}],28:[function(require,module,exports){
var isObject = require('./isObject');

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;

},{"./isObject":139}],29:[function(require,module,exports){
/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

module.exports = baseFindIndex;

},{}],30:[function(require,module,exports){
var castPath = require('./_castPath'),
    toKey = require('./_toKey');

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

module.exports = baseGet;

},{"./_castPath":51,"./_toKey":125}],31:[function(require,module,exports){
var arrayPush = require('./_arrayPush'),
    isArray = require('./isArray');

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;

},{"./_arrayPush":19,"./isArray":134}],32:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    getRawTag = require('./_getRawTag'),
    objectToString = require('./_objectToString');

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;

},{"./_Symbol":10,"./_getRawTag":76,"./_objectToString":113}],33:[function(require,module,exports){
/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;

},{}],34:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;

},{"./_baseGetTag":32,"./isObjectLike":140}],35:[function(require,module,exports){
var baseIsEqualDeep = require('./_baseIsEqualDeep'),
    isObjectLike = require('./isObjectLike');

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

module.exports = baseIsEqual;

},{"./_baseIsEqualDeep":36,"./isObjectLike":140}],36:[function(require,module,exports){
var Stack = require('./_Stack'),
    equalArrays = require('./_equalArrays'),
    equalByTag = require('./_equalByTag'),
    equalObjects = require('./_equalObjects'),
    getTag = require('./_getTag'),
    isArray = require('./isArray'),
    isBuffer = require('./isBuffer'),
    isTypedArray = require('./isTypedArray');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

module.exports = baseIsEqualDeep;

},{"./_Stack":9,"./_equalArrays":66,"./_equalByTag":67,"./_equalObjects":68,"./_getTag":79,"./isArray":134,"./isBuffer":136,"./isTypedArray":142}],37:[function(require,module,exports){
var Stack = require('./_Stack'),
    baseIsEqual = require('./_baseIsEqual');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack;
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

module.exports = baseIsMatch;

},{"./_Stack":9,"./_baseIsEqual":35}],38:[function(require,module,exports){
var isFunction = require('./isFunction'),
    isMasked = require('./_isMasked'),
    isObject = require('./isObject'),
    toSource = require('./_toSource');

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;

},{"./_isMasked":93,"./_toSource":126,"./isFunction":137,"./isObject":139}],39:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isLength = require('./isLength'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;

},{"./_baseGetTag":32,"./isLength":138,"./isObjectLike":140}],40:[function(require,module,exports){
var baseMatches = require('./_baseMatches'),
    baseMatchesProperty = require('./_baseMatchesProperty'),
    identity = require('./identity'),
    isArray = require('./isArray'),
    property = require('./property');

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == 'object') {
    return isArray(value)
      ? baseMatchesProperty(value[0], value[1])
      : baseMatches(value);
  }
  return property(value);
}

module.exports = baseIteratee;

},{"./_baseMatches":43,"./_baseMatchesProperty":44,"./identity":132,"./isArray":134,"./property":146}],41:[function(require,module,exports){
var isPrototype = require('./_isPrototype'),
    nativeKeys = require('./_nativeKeys');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;

},{"./_isPrototype":94,"./_nativeKeys":110}],42:[function(require,module,exports){
var isObject = require('./isObject'),
    isPrototype = require('./_isPrototype'),
    nativeKeysIn = require('./_nativeKeysIn');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;

},{"./_isPrototype":94,"./_nativeKeysIn":111,"./isObject":139}],43:[function(require,module,exports){
var baseIsMatch = require('./_baseIsMatch'),
    getMatchData = require('./_getMatchData'),
    matchesStrictComparable = require('./_matchesStrictComparable');

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

module.exports = baseMatches;

},{"./_baseIsMatch":37,"./_getMatchData":73,"./_matchesStrictComparable":107}],44:[function(require,module,exports){
var baseIsEqual = require('./_baseIsEqual'),
    get = require('./get'),
    hasIn = require('./hasIn'),
    isKey = require('./_isKey'),
    isStrictComparable = require('./_isStrictComparable'),
    matchesStrictComparable = require('./_matchesStrictComparable'),
    toKey = require('./_toKey');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? hasIn(object, path)
      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

module.exports = baseMatchesProperty;

},{"./_baseIsEqual":35,"./_isKey":91,"./_isStrictComparable":95,"./_matchesStrictComparable":107,"./_toKey":125,"./get":130,"./hasIn":131}],45:[function(require,module,exports){
/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

module.exports = baseProperty;

},{}],46:[function(require,module,exports){
var baseGet = require('./_baseGet');

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}

module.exports = basePropertyDeep;

},{"./_baseGet":30}],47:[function(require,module,exports){
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;

},{}],48:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    arrayMap = require('./_arrayMap'),
    isArray = require('./isArray'),
    isSymbol = require('./isSymbol');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = baseToString;

},{"./_Symbol":10,"./_arrayMap":18,"./isArray":134,"./isSymbol":141}],49:[function(require,module,exports){
/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;

},{}],50:[function(require,module,exports){
/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;

},{}],51:[function(require,module,exports){
var isArray = require('./isArray'),
    isKey = require('./_isKey'),
    stringToPath = require('./_stringToPath'),
    toString = require('./toString');

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;

},{"./_isKey":91,"./_stringToPath":124,"./isArray":134,"./toString":152}],52:[function(require,module,exports){
var Uint8Array = require('./_Uint8Array');

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;

},{"./_Uint8Array":11}],53:[function(require,module,exports){
var root = require('./_root');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;

},{"./_root":115}],54:[function(require,module,exports){
var cloneArrayBuffer = require('./_cloneArrayBuffer');

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;

},{"./_cloneArrayBuffer":52}],55:[function(require,module,exports){
var addMapEntry = require('./_addMapEntry'),
    arrayReduce = require('./_arrayReduce'),
    mapToArray = require('./_mapToArray');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1;

/**
 * Creates a clone of `map`.
 *
 * @private
 * @param {Object} map The map to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned map.
 */
function cloneMap(map, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(mapToArray(map), CLONE_DEEP_FLAG) : mapToArray(map);
  return arrayReduce(array, addMapEntry, new map.constructor);
}

module.exports = cloneMap;

},{"./_addMapEntry":13,"./_arrayReduce":20,"./_mapToArray":106}],56:[function(require,module,exports){
/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;

},{}],57:[function(require,module,exports){
var addSetEntry = require('./_addSetEntry'),
    arrayReduce = require('./_arrayReduce'),
    setToArray = require('./_setToArray');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1;

/**
 * Creates a clone of `set`.
 *
 * @private
 * @param {Object} set The set to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned set.
 */
function cloneSet(set, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(setToArray(set), CLONE_DEEP_FLAG) : setToArray(set);
  return arrayReduce(array, addSetEntry, new set.constructor);
}

module.exports = cloneSet;

},{"./_addSetEntry":14,"./_arrayReduce":20,"./_setToArray":118}],58:[function(require,module,exports){
var Symbol = require('./_Symbol');

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;

},{"./_Symbol":10}],59:[function(require,module,exports){
var cloneArrayBuffer = require('./_cloneArrayBuffer');

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;

},{"./_cloneArrayBuffer":52}],60:[function(require,module,exports){
/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;

},{}],61:[function(require,module,exports){
var assignValue = require('./_assignValue'),
    baseAssignValue = require('./_baseAssignValue');

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;

},{"./_assignValue":22,"./_baseAssignValue":26}],62:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    getSymbols = require('./_getSymbols');

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;

},{"./_copyObject":61,"./_getSymbols":77}],63:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    getSymbolsIn = require('./_getSymbolsIn');

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;

},{"./_copyObject":61,"./_getSymbolsIn":78}],64:[function(require,module,exports){
var root = require('./_root');

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;

},{"./_root":115}],65:[function(require,module,exports){
var getNative = require('./_getNative');

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;

},{"./_getNative":74}],66:[function(require,module,exports){
var SetCache = require('./_SetCache'),
    arraySome = require('./_arraySome'),
    cacheHas = require('./_cacheHas');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

module.exports = equalArrays;

},{"./_SetCache":8,"./_arraySome":21,"./_cacheHas":50}],67:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    Uint8Array = require('./_Uint8Array'),
    eq = require('./eq'),
    equalArrays = require('./_equalArrays'),
    mapToArray = require('./_mapToArray'),
    setToArray = require('./_setToArray');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

module.exports = equalByTag;

},{"./_Symbol":10,"./_Uint8Array":11,"./_equalArrays":66,"./_mapToArray":106,"./_setToArray":118,"./eq":128}],68:[function(require,module,exports){
var getAllKeys = require('./_getAllKeys');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

module.exports = equalObjects;

},{"./_getAllKeys":70}],69:[function(require,module,exports){
(function (global){
/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],70:[function(require,module,exports){
var baseGetAllKeys = require('./_baseGetAllKeys'),
    getSymbols = require('./_getSymbols'),
    keys = require('./keys');

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;

},{"./_baseGetAllKeys":31,"./_getSymbols":77,"./keys":143}],71:[function(require,module,exports){
var baseGetAllKeys = require('./_baseGetAllKeys'),
    getSymbolsIn = require('./_getSymbolsIn'),
    keysIn = require('./keysIn');

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;

},{"./_baseGetAllKeys":31,"./_getSymbolsIn":78,"./keysIn":144}],72:[function(require,module,exports){
var isKeyable = require('./_isKeyable');

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;

},{"./_isKeyable":92}],73:[function(require,module,exports){
var isStrictComparable = require('./_isStrictComparable'),
    keys = require('./keys');

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}

module.exports = getMatchData;

},{"./_isStrictComparable":95,"./keys":143}],74:[function(require,module,exports){
var baseIsNative = require('./_baseIsNative'),
    getValue = require('./_getValue');

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;

},{"./_baseIsNative":38,"./_getValue":80}],75:[function(require,module,exports){
var overArg = require('./_overArg');

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;

},{"./_overArg":114}],76:[function(require,module,exports){
var Symbol = require('./_Symbol');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;

},{"./_Symbol":10}],77:[function(require,module,exports){
var arrayFilter = require('./_arrayFilter'),
    stubArray = require('./stubArray');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;

},{"./_arrayFilter":16,"./stubArray":147}],78:[function(require,module,exports){
var arrayPush = require('./_arrayPush'),
    getPrototype = require('./_getPrototype'),
    getSymbols = require('./_getSymbols'),
    stubArray = require('./stubArray');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

module.exports = getSymbolsIn;

},{"./_arrayPush":19,"./_getPrototype":75,"./_getSymbols":77,"./stubArray":147}],79:[function(require,module,exports){
var DataView = require('./_DataView'),
    Map = require('./_Map'),
    Promise = require('./_Promise'),
    Set = require('./_Set'),
    WeakMap = require('./_WeakMap'),
    baseGetTag = require('./_baseGetTag'),
    toSource = require('./_toSource');

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;

},{"./_DataView":1,"./_Map":4,"./_Promise":6,"./_Set":7,"./_WeakMap":12,"./_baseGetTag":32,"./_toSource":126}],80:[function(require,module,exports){
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;

},{}],81:[function(require,module,exports){
var castPath = require('./_castPath'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isIndex = require('./_isIndex'),
    isLength = require('./isLength'),
    toKey = require('./_toKey');

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray(object) || isArguments(object));
}

module.exports = hasPath;

},{"./_castPath":51,"./_isIndex":90,"./_toKey":125,"./isArguments":133,"./isArray":134,"./isLength":138}],82:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;

},{"./_nativeCreate":109}],83:[function(require,module,exports){
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;

},{}],84:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;

},{"./_nativeCreate":109}],85:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;

},{"./_nativeCreate":109}],86:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;

},{"./_nativeCreate":109}],87:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

module.exports = initCloneArray;

},{}],88:[function(require,module,exports){
var cloneArrayBuffer = require('./_cloneArrayBuffer'),
    cloneDataView = require('./_cloneDataView'),
    cloneMap = require('./_cloneMap'),
    cloneRegExp = require('./_cloneRegExp'),
    cloneSet = require('./_cloneSet'),
    cloneSymbol = require('./_cloneSymbol'),
    cloneTypedArray = require('./_cloneTypedArray');

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, cloneFunc, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return cloneMap(object, isDeep, cloneFunc);

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return cloneSet(object, isDeep, cloneFunc);

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;

},{"./_cloneArrayBuffer":52,"./_cloneDataView":54,"./_cloneMap":55,"./_cloneRegExp":56,"./_cloneSet":57,"./_cloneSymbol":58,"./_cloneTypedArray":59}],89:[function(require,module,exports){
var baseCreate = require('./_baseCreate'),
    getPrototype = require('./_getPrototype'),
    isPrototype = require('./_isPrototype');

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;

},{"./_baseCreate":28,"./_getPrototype":75,"./_isPrototype":94}],90:[function(require,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;

},{}],91:[function(require,module,exports){
var isArray = require('./isArray'),
    isSymbol = require('./isSymbol');

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

module.exports = isKey;

},{"./isArray":134,"./isSymbol":141}],92:[function(require,module,exports){
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;

},{}],93:[function(require,module,exports){
var coreJsData = require('./_coreJsData');

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;

},{"./_coreJsData":64}],94:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;

},{}],95:[function(require,module,exports){
var isObject = require('./isObject');

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

module.exports = isStrictComparable;

},{"./isObject":139}],96:[function(require,module,exports){
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;

},{}],97:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;

},{"./_assocIndexOf":23}],98:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;

},{"./_assocIndexOf":23}],99:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;

},{"./_assocIndexOf":23}],100:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;

},{"./_assocIndexOf":23}],101:[function(require,module,exports){
var Hash = require('./_Hash'),
    ListCache = require('./_ListCache'),
    Map = require('./_Map');

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;

},{"./_Hash":2,"./_ListCache":3,"./_Map":4}],102:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;

},{"./_getMapData":72}],103:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;

},{"./_getMapData":72}],104:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;

},{"./_getMapData":72}],105:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;

},{"./_getMapData":72}],106:[function(require,module,exports){
/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;

},{}],107:[function(require,module,exports){
/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

module.exports = matchesStrictComparable;

},{}],108:[function(require,module,exports){
var memoize = require('./memoize');

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;

},{"./memoize":145}],109:[function(require,module,exports){
var getNative = require('./_getNative');

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;

},{"./_getNative":74}],110:[function(require,module,exports){
var overArg = require('./_overArg');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;

},{"./_overArg":114}],111:[function(require,module,exports){
/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;

},{}],112:[function(require,module,exports){
var freeGlobal = require('./_freeGlobal');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;

},{"./_freeGlobal":69}],113:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;

},{}],114:[function(require,module,exports){
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;

},{}],115:[function(require,module,exports){
var freeGlobal = require('./_freeGlobal');

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;

},{"./_freeGlobal":69}],116:[function(require,module,exports){
/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

module.exports = setCacheAdd;

},{}],117:[function(require,module,exports){
/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;

},{}],118:[function(require,module,exports){
/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;

},{}],119:[function(require,module,exports){
var ListCache = require('./_ListCache');

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;

},{"./_ListCache":3}],120:[function(require,module,exports){
/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;

},{}],121:[function(require,module,exports){
/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;

},{}],122:[function(require,module,exports){
/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;

},{}],123:[function(require,module,exports){
var ListCache = require('./_ListCache'),
    Map = require('./_Map'),
    MapCache = require('./_MapCache');

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;

},{"./_ListCache":3,"./_Map":4,"./_MapCache":5}],124:[function(require,module,exports){
var memoizeCapped = require('./_memoizeCapped');

/** Used to match property names within property paths. */
var reLeadingDot = /^\./,
    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (reLeadingDot.test(string)) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

module.exports = stringToPath;

},{"./_memoizeCapped":108}],125:[function(require,module,exports){
var isSymbol = require('./isSymbol');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = toKey;

},{"./isSymbol":141}],126:[function(require,module,exports){
/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;

},{}],127:[function(require,module,exports){
var baseClone = require('./_baseClone');

/** Used to compose bitmasks for cloning. */
var CLONE_SYMBOLS_FLAG = 4;

/**
 * Creates a shallow clone of `value`.
 *
 * **Note:** This method is loosely based on the
 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
 * and supports cloning arrays, array buffers, booleans, date objects, maps,
 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
 * arrays. The own enumerable properties of `arguments` objects are cloned
 * as plain objects. An empty object is returned for uncloneable values such
 * as error objects, functions, DOM nodes, and WeakMaps.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to clone.
 * @returns {*} Returns the cloned value.
 * @see _.cloneDeep
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var shallow = _.clone(objects);
 * console.log(shallow[0] === objects[0]);
 * // => true
 */
function clone(value) {
  return baseClone(value, CLONE_SYMBOLS_FLAG);
}

module.exports = clone;

},{"./_baseClone":27}],128:[function(require,module,exports){
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;

},{}],129:[function(require,module,exports){
var baseFindIndex = require('./_baseFindIndex'),
    baseIteratee = require('./_baseIteratee'),
    toInteger = require('./toInteger');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * This method is like `_.find` except that it returns the index of the first
 * element `predicate` returns truthy for instead of the element itself.
 *
 * @static
 * @memberOf _
 * @since 1.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {number} Returns the index of the found element, else `-1`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': false },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': true }
 * ];
 *
 * _.findIndex(users, function(o) { return o.user == 'barney'; });
 * // => 0
 *
 * // The `_.matches` iteratee shorthand.
 * _.findIndex(users, { 'user': 'fred', 'active': false });
 * // => 1
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.findIndex(users, ['active', false]);
 * // => 0
 *
 * // The `_.property` iteratee shorthand.
 * _.findIndex(users, 'active');
 * // => 2
 */
function findIndex(array, predicate, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index = fromIndex == null ? 0 : toInteger(fromIndex);
  if (index < 0) {
    index = nativeMax(length + index, 0);
  }
  return baseFindIndex(array, baseIteratee(predicate, 3), index);
}

module.exports = findIndex;

},{"./_baseFindIndex":29,"./_baseIteratee":40,"./toInteger":150}],130:[function(require,module,exports){
var baseGet = require('./_baseGet');

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;

},{"./_baseGet":30}],131:[function(require,module,exports){
var baseHasIn = require('./_baseHasIn'),
    hasPath = require('./_hasPath');

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;

},{"./_baseHasIn":33,"./_hasPath":81}],132:[function(require,module,exports){
/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;

},{}],133:[function(require,module,exports){
var baseIsArguments = require('./_baseIsArguments'),
    isObjectLike = require('./isObjectLike');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;

},{"./_baseIsArguments":34,"./isObjectLike":140}],134:[function(require,module,exports){
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;

},{}],135:[function(require,module,exports){
var isFunction = require('./isFunction'),
    isLength = require('./isLength');

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;

},{"./isFunction":137,"./isLength":138}],136:[function(require,module,exports){
var root = require('./_root'),
    stubFalse = require('./stubFalse');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;

},{"./_root":115,"./stubFalse":148}],137:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObject = require('./isObject');

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;

},{"./_baseGetTag":32,"./isObject":139}],138:[function(require,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

},{}],139:[function(require,module,exports){
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;

},{}],140:[function(require,module,exports){
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;

},{}],141:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;

},{"./_baseGetTag":32,"./isObjectLike":140}],142:[function(require,module,exports){
var baseIsTypedArray = require('./_baseIsTypedArray'),
    baseUnary = require('./_baseUnary'),
    nodeUtil = require('./_nodeUtil');

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;

},{"./_baseIsTypedArray":39,"./_baseUnary":49,"./_nodeUtil":112}],143:[function(require,module,exports){
var arrayLikeKeys = require('./_arrayLikeKeys'),
    baseKeys = require('./_baseKeys'),
    isArrayLike = require('./isArrayLike');

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;

},{"./_arrayLikeKeys":17,"./_baseKeys":41,"./isArrayLike":135}],144:[function(require,module,exports){
var arrayLikeKeys = require('./_arrayLikeKeys'),
    baseKeysIn = require('./_baseKeysIn'),
    isArrayLike = require('./isArrayLike');

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;

},{"./_arrayLikeKeys":17,"./_baseKeysIn":42,"./isArrayLike":135}],145:[function(require,module,exports){
var MapCache = require('./_MapCache');

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

module.exports = memoize;

},{"./_MapCache":5}],146:[function(require,module,exports){
var baseProperty = require('./_baseProperty'),
    basePropertyDeep = require('./_basePropertyDeep'),
    isKey = require('./_isKey'),
    toKey = require('./_toKey');

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

module.exports = property;

},{"./_baseProperty":45,"./_basePropertyDeep":46,"./_isKey":91,"./_toKey":125}],147:[function(require,module,exports){
/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;

},{}],148:[function(require,module,exports){
/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;

},{}],149:[function(require,module,exports){
var toNumber = require('./toNumber');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

module.exports = toFinite;

},{"./toNumber":151}],150:[function(require,module,exports){
var toFinite = require('./toFinite');

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

module.exports = toInteger;

},{"./toFinite":149}],151:[function(require,module,exports){
var isObject = require('./isObject'),
    isSymbol = require('./isSymbol');

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = toNumber;

},{"./isObject":139,"./isSymbol":141}],152:[function(require,module,exports){
var baseToString = require('./_baseToString');

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;

},{"./_baseToString":48}],153:[function(require,module,exports){
/* globals module: false, require: false */
module.exports = function (options) {
	'use strict';
	let _fi = require('lodash/findIndex')
		// , _iseq = require('lodash/isEqual')
		, _clone = require('lodash/clone')
		//utilities
		// const

		, _iseq = (x, y) => {

			if (!Array.isArray(x) || !Array.isArray(y)) {
				return x == y// eslint-disable-line eqeqeq
				// return x === y
			}
			if (x.length !== y.length) return false
			for (let index = 0; index < x.length; index++) {
				if (!_iseq(x[index], y[index])) {
					return false
				}
			}
			return true

		}
		, myIndexOf = (a, b) => {
			return _fi(a, function (x) { return _iseq(x, b) });
		}
	// this version, without the _fi dependency, doesn't work!todo
	//  , myIndexOf = (array, item) => {
	// 		for (let index = 0; index < array.length; index++) {
	// 			if (_iseq(array[index], item)) {
	// 				return index;

	// 			}
	// 			return -1;
	// 		}

	// 	}

	// 	, _clone = require('lodash/clone')


	options = options || {}
	// boardMode = options.boardMode || 't'/*t:toroid; c:classic */
	// , boardDimensions = options.boardDimensions || [11, 11]/*move later*/
	// , rules = options.rules || {
	// suicide: true,
	// superko: false
	// }
	let $ = {}
	////problem with the object spread operator and the build so using Object.assign instead.
	// $.rules = {
	// 		suicide: true,
	// 		// superko: false /*todo: enforce when true?*/,
	// 		komi: 7.5,
	// 		... options.rules
	// 	}
	$.rules = Object.assign({}, {
		suicide: true,
		// superko: false /*todo: enforce when true?*/,
		komi: 7.5,
	}, options.rules)

	// $.moves = options.moves || []
	$.options = options
	options.boardDimensions = options.boardDimensions || [11, 11]
	options.boardMode = options.boardMode || 't'/*t:toroid; c:classic */
	$.board = {}
	$.board.blackStones = options.blackStones || []
	$.board.whiteStones = options.whiteStones || []

	$.board.nextPlayer = options.nextPlayer || "b"
	$.board.captured = options.captured || [0, 0]

	$.exportData = function () {
		return {
			blackStones: $.board.blackStones.map(_clone),

			whiteStones: $.board.whiteStones.map(_clone),
			captured: _clone($.board.captured),
			nextPlayer: $.board.nextPlayer
		}
	}

	$.loadData = function (data) {
		$.board.blackStones = data.blackStones
		$.board.whiteStones = data.whiteStones
		$.board.captured = data.captured
		$.board.nextPlayer = data.nextPlayer
	}

	//toroid
	if (options.boardMode === 't') $.board.getNeighbours =
		function (point) {
			let result = []
			for (let i = 0; i < 4; i++) {
				let newPoint
				switch (i) {
					case 0:
						newPoint = [point[0] + 1, point[1]]
						break
					case 1:
						newPoint = [point[0] - 1, point[1]]
						break
					case 2:
						newPoint = [point[0], point[1] + 1]
						break
					case 3:
						newPoint = [point[0], point[1] - 1]
						break
				}
				result.push([(newPoint[0] + options.boardDimensions[0]) % options.boardDimensions[0], (newPoint[1] + options.boardDimensions[1]) % options.boardDimensions[1]])
			}
			return result
		}
	if (options.boardMode === 'c') $.board.getNeighbours =
		function (point) {
			let result = []
			for (let i = 0; i < 4; i++) {
				let newPoint
				switch (i) {
					case 0:
						newPoint = [point[0] + 1, point[1]]
						break
					case 1:
						newPoint = [point[0] - 1, point[1]]
						break
					case 2:
						newPoint = [point[0], point[1] + 1]
						break
					case 3:
						newPoint = [point[0], point[1] - 1]
						break
				}
				if (newPoint[0] >= 0 && newPoint[0] < options.boardDimensions[0]
					&& newPoint[1] >= 0 && newPoint[1] < options.boardDimensions[1]
				)
					result.push(newPoint)
			}
			return result
		}
	//todo: klein, projective plane, 

	$.board.isEmpty = function (point) {
		return myIndexOf($.board.blackStones, point) < 0
			&& myIndexOf($.board.whiteStones, point) < 0
	}
	$.board.getColour = function (point) {
		if (myIndexOf($.board.blackStones, point) >= 0) return 'b'
		if (myIndexOf($.board.whiteStones, point) >= 0) return 'w'
		return 'e'
	}
	/**
	 * Determines if a point is part of a chain with a liberty; if there are no liberties then it returns the chain of stones of the same colour that are connected to `startPoint`. Also used for counting to return connected components of same colour (black, white or empty).
	 * @param {*} startPoint 
	 * @param {string|null} chainColour indicates the colour of the starting point.
	 * @param {*} [stopColour='e'] stop working if the chain meets this colour
	 * @param {Function} [getColour=$.board.getColour] Function used to determine the colour of a point.
	 * @returns {bool|array} Returns `true` if the the component meets `stopColour`, and an array containing connected component of points linked to `startPoint` otherwise. 
	 */	
	function chainHasLiberty (startPoint, chainColour, stopColour, getColour) {
		if (stopColour === undefined)
			stopColour = 'e'//by default, stop getting the chain when there is a liberty.
		if (getColour === undefined)
			getColour = $.board.getColour//by default, use the usual board colour function

		if (chainColour === null)
			chainColour = getColour(startPoint)
		let
			chain = [startPoint]
			, toExplore = []
			, point = startPoint //assumed to be of colour chainColour

		while (point !== undefined) {

			let neighbours = $.board.getNeighbours(point)
			for (let i = 0; i < neighbours.length; i++) {
				let newPoint = neighbours[i],
					newColour = getColour(newPoint)
				if (newColour === stopColour) return true;
				if (newColour === chainColour) {
					if (myIndexOf(chain, newPoint) < 0) {
						chain.push(newPoint)
						// if (myIndexOf(toExplore, newPoint) < 0)
						toExplore.push(newPoint)
					}
				}
			}
			point = toExplore.pop()
		}

		return chain;
	}

	$.board.chainHasLiberty = chainHasLiberty 

	$.board.score = function (deadStones) {
		/*
		go through the whole board 
		*/
		if (deadStones === undefined) {
			deadStones = []
		}

		let result = {
			blackEmpty: []
			, whiteEmpty: []
			, dame: []
			, blackAlive: []
			, whiteAlive: []
			, blackDead: []
			, whiteDead: []
			, totalBlackCaptured: $.board.captured[0] //nb B stones removed by W during the game
			, totalWhiteCaptured: $.board.captured[1] //nb W stones removed by B during the game
			//todo:could replace by an class. data stored in a big array of pairs [point, status]
		}

		for (let index = 0; index < deadStones.length; index++) {
			const deadStone = deadStones[index];
			let deadColour = $.board.getColour(deadStone)
			if (deadColour === 'e') throw new Error('invalid marked dead stone')
			let
				deadToFill = deadColour === 'b' ? result.blackDead : result.whiteDead
				, emptyToFill = deadColour === 'b' ? result.whiteEmpty : result.blackEmpty
				, aliveToFill = deadColour === 'b' ? result.whiteAlive : result.blackAlive
				, processPoint = (point, colour) => {
					if (colour === deadColour && myIndexOf(deadToFill, point) < 0) {
						deadToFill.push(point)
						emptyToFill.push(point)
					}
					if ((colour === deadColour || colour === 'e') && myIndexOf(emptyToFill, point) < 0) {
						emptyToFill.push(point)
					}
					if (colour !== deadColour && colour !== 'e' && myIndexOf(aliveToFill, point) < 0) {
						aliveToFill.push(point)
					}
				}
				, getColourForDeadComponent = (point) => {
					let colour = $.board.getColour(point)
					processPoint(point, colour)
					return colour === deadColour ? 'e' : colour
				}
			processPoint(deadStone, deadColour)
			$.board.chainHasLiberty(deadStone, 'e', '', getColourForDeadComponent)
		}

		for (let i = 0,exitLoop = false; i < options.boardDimensions[0]; i++) {
			if (exitLoop) {
				break
			}
			for (let j = 0; j < options.boardDimensions[1]; j++) {
				if (result.blackEmpty.length
					+ result.whiteEmpty.length
					+ result.dame.length
					+ result.blackAlive.length
					+ result.whiteAlive.length
					// + result.blackDead.length
					// + result.whiteDead.length
					=== options.boardDimensions[0] * options.boardDimensions[1]
				) {
					exitLoop = true
					break
				}
				const point = [i, j], colour = $.board.getColour(point)

				if (colour === 'b'
				) {
					if (myIndexOf(result.blackAlive, point) < 0
						&& myIndexOf(result.blackDead, point) < 0) {
						result.blackAlive.push(point)
					} else continue
				}
				if (colour === 'w') {
					if (myIndexOf(result.whiteAlive, point) < 0
						&& myIndexOf(result.whiteDead, point) < 0) {
						result.whiteAlive.push(point)
					} else continue
				}

				if (colour === 'e') {
					if (myIndexOf(result.blackEmpty, point) >= 0
						|| myIndexOf(result.whiteEmpty, point) >= 0
						|| myIndexOf(result.dame, point) >= 0) {
						continue
					}

					let
						meetsBlack = false
						, meetsWhite = false
						, isBlackTerritory = false
						, isWhiteTerritory = false
						, getColourForScoring = (point) => {

							let colour = $.board.getColour(point)
							switch (colour) {
								case 'b':
									if (myIndexOf(result.blackDead, point) >= 0) {
										colour = 'e'
										isWhiteTerritory = true
									}
									else {
										meetsBlack = true
										if (myIndexOf(result.blackAlive, point) < 0) {
											result.blackAlive.push(point)
										}
									}
									break;
								case 'w':
									if (myIndexOf(result.whiteDead, point) >= 0) {
										colour = 'e'
										isBlackTerritory = true
									}
									else {
										meetsWhite = true
										if (myIndexOf(result.whiteAlive, point) < 0) {
											result.whiteAlive.push(point)
										}
									}
									break;

								default://nothing needed for 'e'
									break;
							}
							return colour
						}
					let emptyComponent = $.board.chainHasLiberty(point, 'e', '', getColourForScoring)
					if (!meetsBlack && !meetsWhite) {
						throw new Error('counting an empty board!')
					}
					if (isBlackTerritory && isWhiteTerritory) {
						throw new Error('too many stones marked as dead')
					}
					//could store the different empty components: V2 
					if (meetsBlack && meetsWhite) {
						result.dame = result.dame.concat(emptyComponent)
						continue
					}
					if (meetsBlack) {
						result.blackEmpty = result.blackEmpty.concat(emptyComponent)
						continue
					}
					if (meetsWhite) {
						result.whiteEmpty = result.whiteEmpty.concat(emptyComponent)
						continue
					}
				}
			}
		}
		//totals
		result.totalBlackDead = result.blackDead.length
		result.totalWhiteDead = result.whiteDead.length
		result.totalBlackTerritory = result.blackEmpty.length
		result.totalWhiteTerritory = result.whiteEmpty.length


		//todo: implement other rulesets. For now, just do territory + prisoners (Japanese style counting)
		result.blackScore =
			result.totalWhiteDead
			+ result.totalWhiteCaptured
			+ result.totalBlackTerritory
		result.whiteScore =
			result.totalBlackDead
			+ result.totalBlackCaptured
			+ result.totalWhiteTerritory
			+ $.rules.komi
		let r = result.blackScore - result.whiteScore
		if (r === 0) result.RE = '0'
		else if (r > 0) result.RE = 'B+' + r
		else result.RE = 'W+' + (-r)
		return result
	}

	$.board.empty = function () {
		$.board.whiteStones = []
		$.board.blackStones = []
		$.board.captured = [0, 0]

	}

	$.removeChain = function (chain, colour) {
		let toRemoveFrom = colour === 'w' ? $.board.whiteStones : $.board.blackStones
		for (let j = 0; j < chain.length; j++) {
			let index = myIndexOf(toRemoveFrom, chain[j])
			toRemoveFrom.splice(index, 1)
			if (colour === 'w') $.board.captured[1] = $.board.captured[1] + 1
			else $.board.captured[0] = $.board.captured[0] + 1
		}
	}
	$.play = function (playerColour, point) {



		// let result = "ok"
		if (!$.board.isEmpty(point))
			throw new Error('point is not empty')
		// console.log('point is not empty' + point)

		if (playerColour === 'b') $.board.blackStones.push(point)
		else $.board.whiteStones.push(point)

		let neighbours = $.board.getNeighbours(point)
			, removed = []//chains removed

		for (let i = 0; i < neighbours.length; i++) {
			let neighbour = neighbours[i], colour = $.board.getColour(neighbour)
			if (colour === playerColour || colour === 'e') continue
			let oppColour = $.getOppositeColour(playerColour),
				r = $.board.chainHasLiberty(neighbour, oppColour)
			if (r === true) continue
			////remove - no liberties
			removed[removed.length] = r

			$.removeChain(r, oppColour)

			// let chainToRemove = r[1],
			// toRemoveFrom = playerColour === 'b' ? $.board.whiteStones : $.board.blackStones
			// for (let j = 0; j<chainToRemove.length; j++)
			// {
			// let index = myIndexOf(toRemoveFrom,chainToRemove[j])
			// toRemoveFrom.splice(index, 1)
			// if (playerColour === 'b') $.board.captured[1] = $.board.captured[1] + 1
			// else $.board.captured[0] = $.board.captured[0] + 1
			// }
			// removed = true
		}
		let suicide = false
		if (removed.length === 0) {
			let s = $.board.chainHasLiberty(point, playerColour)
			if (s !== true) {
				if ($.rules.suicide) {
					$.removeChain(s, playerColour)
					suicide = s
				}
				else {
					throw new Error('suicide')//isnt allowed
					//todo: remove point from whiteStones or blackStones
				}
			}
		}

		/*
			storing the situation in memory - would be useful when implementing going back a move, superko, 
			not needed for now
		*/
		//$.moves.push([playerColour,point,_.clone($.board.whiteStones),_.clone($.board.blackStones)])
		// $.moves.push([playerColour,point])

		// getNeighbours[i] = [getNeighbours[i], $.board.getColour[getNeighbours[i]]
		// //


		return { removed, suicide }
	}
	$.getOppositeColour = function (colour) {
		switch (colour) {
			case 'b':
				return 'w'
			case 'w':
				return 'b'
		}
		return null
	}
	return $

}
},{"lodash/clone":127,"lodash/findIndex":129}],154:[function(require,module,exports){
arguments[4][1][0].apply(exports,arguments)
},{"./_getNative":209,"./_root":245,"dup":1}],155:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"./_hashClear":215,"./_hashDelete":216,"./_hashGet":217,"./_hashHas":218,"./_hashSet":219,"dup":2}],156:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./_listCacheClear":227,"./_listCacheDelete":228,"./_listCacheGet":229,"./_listCacheHas":230,"./_listCacheSet":231,"dup":3}],157:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"./_getNative":209,"./_root":245,"dup":4}],158:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"./_mapCacheClear":232,"./_mapCacheDelete":233,"./_mapCacheGet":234,"./_mapCacheHas":235,"./_mapCacheSet":236,"dup":5}],159:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"./_getNative":209,"./_root":245,"dup":6}],160:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"./_getNative":209,"./_root":245,"dup":7}],161:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"./_MapCache":158,"./_setCacheAdd":246,"./_setCacheHas":247,"dup":8}],162:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"./_ListCache":156,"./_stackClear":249,"./_stackDelete":250,"./_stackGet":251,"./_stackHas":252,"./_stackSet":253,"dup":9}],163:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"./_root":245,"dup":10}],164:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"./_root":245,"dup":11}],165:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./_getNative":209,"./_root":245,"dup":12}],166:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"dup":16}],167:[function(require,module,exports){
var baseIndexOf = require('./_baseIndexOf');

/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludes(array, value) {
  var length = array == null ? 0 : array.length;
  return !!length && baseIndexOf(array, value, 0) > -1;
}

module.exports = arrayIncludes;

},{"./_baseIndexOf":180}],168:[function(require,module,exports){
/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}

module.exports = arrayIncludesWith;

},{}],169:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./_baseTimes":194,"./_isIndex":221,"./isArguments":264,"./isArray":265,"./isBuffer":267,"./isTypedArray":273,"dup":17}],170:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],171:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],172:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],173:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"./eq":258,"dup":23}],174:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"dup":29}],175:[function(require,module,exports){
var arrayPush = require('./_arrayPush'),
    isFlattenable = require('./_isFlattenable');

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

module.exports = baseFlatten;

},{"./_arrayPush":171,"./_isFlattenable":220}],176:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"./_castPath":199,"./_toKey":256,"dup":30}],177:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"./_arrayPush":171,"./isArray":265,"dup":31}],178:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"./_Symbol":163,"./_getRawTag":210,"./_objectToString":243,"dup":32}],179:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],180:[function(require,module,exports){
var baseFindIndex = require('./_baseFindIndex'),
    baseIsNaN = require('./_baseIsNaN'),
    strictIndexOf = require('./_strictIndexOf');

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  return value === value
    ? strictIndexOf(array, value, fromIndex)
    : baseFindIndex(array, baseIsNaN, fromIndex);
}

module.exports = baseIndexOf;

},{"./_baseFindIndex":174,"./_baseIsNaN":185,"./_strictIndexOf":254}],181:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"./_baseGetTag":178,"./isObjectLike":271,"dup":34}],182:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"./_baseIsEqualDeep":183,"./isObjectLike":271,"dup":35}],183:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"./_Stack":162,"./_equalArrays":202,"./_equalByTag":203,"./_equalObjects":204,"./_getTag":212,"./isArray":265,"./isBuffer":267,"./isTypedArray":273,"dup":36}],184:[function(require,module,exports){
arguments[4][37][0].apply(exports,arguments)
},{"./_Stack":162,"./_baseIsEqual":182,"dup":37}],185:[function(require,module,exports){
/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

module.exports = baseIsNaN;

},{}],186:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"./_isMasked":224,"./_toSource":257,"./isFunction":268,"./isObject":270,"dup":38}],187:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"./_baseGetTag":178,"./isLength":269,"./isObjectLike":271,"dup":39}],188:[function(require,module,exports){
arguments[4][40][0].apply(exports,arguments)
},{"./_baseMatches":190,"./_baseMatchesProperty":191,"./identity":263,"./isArray":265,"./property":277,"dup":40}],189:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"./_isPrototype":225,"./_nativeKeys":241,"dup":41}],190:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"./_baseIsMatch":184,"./_getMatchData":208,"./_matchesStrictComparable":238,"dup":43}],191:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"./_baseIsEqual":182,"./_isKey":222,"./_isStrictComparable":226,"./_matchesStrictComparable":238,"./_toKey":256,"./get":261,"./hasIn":262,"dup":44}],192:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45}],193:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"./_baseGet":176,"dup":46}],194:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"dup":47}],195:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"./_Symbol":163,"./_arrayMap":170,"./isArray":265,"./isSymbol":272,"dup":48}],196:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],197:[function(require,module,exports){
var SetCache = require('./_SetCache'),
    arrayIncludes = require('./_arrayIncludes'),
    arrayIncludesWith = require('./_arrayIncludesWith'),
    cacheHas = require('./_cacheHas'),
    createSet = require('./_createSet'),
    setToArray = require('./_setToArray');

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */
function baseUniq(array, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      length = array.length,
      isCommon = true,
      result = [],
      seen = result;

  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  }
  else if (length >= LARGE_ARRAY_SIZE) {
    var set = iteratee ? null : createSet(array);
    if (set) {
      return setToArray(set);
    }
    isCommon = false;
    includes = cacheHas;
    seen = new SetCache;
  }
  else {
    seen = iteratee ? [] : result;
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }
      if (iteratee) {
        seen.push(computed);
      }
      result.push(value);
    }
    else if (!includes(seen, computed, comparator)) {
      if (seen !== result) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

module.exports = baseUniq;

},{"./_SetCache":161,"./_arrayIncludes":167,"./_arrayIncludesWith":168,"./_cacheHas":198,"./_createSet":201,"./_setToArray":248}],198:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}],199:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"./_isKey":222,"./_stringToPath":255,"./isArray":265,"./toString":283,"dup":51}],200:[function(require,module,exports){
arguments[4][64][0].apply(exports,arguments)
},{"./_root":245,"dup":64}],201:[function(require,module,exports){
var Set = require('./_Set'),
    noop = require('./noop'),
    setToArray = require('./_setToArray');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */
var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
  return new Set(values);
};

module.exports = createSet;

},{"./_Set":160,"./_setToArray":248,"./noop":276}],202:[function(require,module,exports){
arguments[4][66][0].apply(exports,arguments)
},{"./_SetCache":161,"./_arraySome":172,"./_cacheHas":198,"dup":66}],203:[function(require,module,exports){
arguments[4][67][0].apply(exports,arguments)
},{"./_Symbol":163,"./_Uint8Array":164,"./_equalArrays":202,"./_mapToArray":237,"./_setToArray":248,"./eq":258,"dup":67}],204:[function(require,module,exports){
arguments[4][68][0].apply(exports,arguments)
},{"./_getAllKeys":206,"dup":68}],205:[function(require,module,exports){
(function (global){
/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],206:[function(require,module,exports){
arguments[4][70][0].apply(exports,arguments)
},{"./_baseGetAllKeys":177,"./_getSymbols":211,"./keys":274,"dup":70}],207:[function(require,module,exports){
arguments[4][72][0].apply(exports,arguments)
},{"./_isKeyable":223,"dup":72}],208:[function(require,module,exports){
arguments[4][73][0].apply(exports,arguments)
},{"./_isStrictComparable":226,"./keys":274,"dup":73}],209:[function(require,module,exports){
arguments[4][74][0].apply(exports,arguments)
},{"./_baseIsNative":186,"./_getValue":213,"dup":74}],210:[function(require,module,exports){
arguments[4][76][0].apply(exports,arguments)
},{"./_Symbol":163,"dup":76}],211:[function(require,module,exports){
arguments[4][77][0].apply(exports,arguments)
},{"./_arrayFilter":166,"./stubArray":278,"dup":77}],212:[function(require,module,exports){
arguments[4][79][0].apply(exports,arguments)
},{"./_DataView":154,"./_Map":157,"./_Promise":159,"./_Set":160,"./_WeakMap":165,"./_baseGetTag":178,"./_toSource":257,"dup":79}],213:[function(require,module,exports){
arguments[4][80][0].apply(exports,arguments)
},{"dup":80}],214:[function(require,module,exports){
arguments[4][81][0].apply(exports,arguments)
},{"./_castPath":199,"./_isIndex":221,"./_toKey":256,"./isArguments":264,"./isArray":265,"./isLength":269,"dup":81}],215:[function(require,module,exports){
arguments[4][82][0].apply(exports,arguments)
},{"./_nativeCreate":240,"dup":82}],216:[function(require,module,exports){
arguments[4][83][0].apply(exports,arguments)
},{"dup":83}],217:[function(require,module,exports){
arguments[4][84][0].apply(exports,arguments)
},{"./_nativeCreate":240,"dup":84}],218:[function(require,module,exports){
arguments[4][85][0].apply(exports,arguments)
},{"./_nativeCreate":240,"dup":85}],219:[function(require,module,exports){
arguments[4][86][0].apply(exports,arguments)
},{"./_nativeCreate":240,"dup":86}],220:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray');

/** Built-in value references. */
var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray(value) || isArguments(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

module.exports = isFlattenable;

},{"./_Symbol":163,"./isArguments":264,"./isArray":265}],221:[function(require,module,exports){
arguments[4][90][0].apply(exports,arguments)
},{"dup":90}],222:[function(require,module,exports){
arguments[4][91][0].apply(exports,arguments)
},{"./isArray":265,"./isSymbol":272,"dup":91}],223:[function(require,module,exports){
arguments[4][92][0].apply(exports,arguments)
},{"dup":92}],224:[function(require,module,exports){
arguments[4][93][0].apply(exports,arguments)
},{"./_coreJsData":200,"dup":93}],225:[function(require,module,exports){
arguments[4][94][0].apply(exports,arguments)
},{"dup":94}],226:[function(require,module,exports){
arguments[4][95][0].apply(exports,arguments)
},{"./isObject":270,"dup":95}],227:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],228:[function(require,module,exports){
arguments[4][97][0].apply(exports,arguments)
},{"./_assocIndexOf":173,"dup":97}],229:[function(require,module,exports){
arguments[4][98][0].apply(exports,arguments)
},{"./_assocIndexOf":173,"dup":98}],230:[function(require,module,exports){
arguments[4][99][0].apply(exports,arguments)
},{"./_assocIndexOf":173,"dup":99}],231:[function(require,module,exports){
arguments[4][100][0].apply(exports,arguments)
},{"./_assocIndexOf":173,"dup":100}],232:[function(require,module,exports){
arguments[4][101][0].apply(exports,arguments)
},{"./_Hash":155,"./_ListCache":156,"./_Map":157,"dup":101}],233:[function(require,module,exports){
arguments[4][102][0].apply(exports,arguments)
},{"./_getMapData":207,"dup":102}],234:[function(require,module,exports){
arguments[4][103][0].apply(exports,arguments)
},{"./_getMapData":207,"dup":103}],235:[function(require,module,exports){
arguments[4][104][0].apply(exports,arguments)
},{"./_getMapData":207,"dup":104}],236:[function(require,module,exports){
arguments[4][105][0].apply(exports,arguments)
},{"./_getMapData":207,"dup":105}],237:[function(require,module,exports){
arguments[4][106][0].apply(exports,arguments)
},{"dup":106}],238:[function(require,module,exports){
arguments[4][107][0].apply(exports,arguments)
},{"dup":107}],239:[function(require,module,exports){
arguments[4][108][0].apply(exports,arguments)
},{"./memoize":275,"dup":108}],240:[function(require,module,exports){
arguments[4][109][0].apply(exports,arguments)
},{"./_getNative":209,"dup":109}],241:[function(require,module,exports){
arguments[4][110][0].apply(exports,arguments)
},{"./_overArg":244,"dup":110}],242:[function(require,module,exports){
arguments[4][112][0].apply(exports,arguments)
},{"./_freeGlobal":205,"dup":112}],243:[function(require,module,exports){
arguments[4][113][0].apply(exports,arguments)
},{"dup":113}],244:[function(require,module,exports){
arguments[4][114][0].apply(exports,arguments)
},{"dup":114}],245:[function(require,module,exports){
arguments[4][115][0].apply(exports,arguments)
},{"./_freeGlobal":205,"dup":115}],246:[function(require,module,exports){
arguments[4][116][0].apply(exports,arguments)
},{"dup":116}],247:[function(require,module,exports){
arguments[4][117][0].apply(exports,arguments)
},{"dup":117}],248:[function(require,module,exports){
arguments[4][118][0].apply(exports,arguments)
},{"dup":118}],249:[function(require,module,exports){
arguments[4][119][0].apply(exports,arguments)
},{"./_ListCache":156,"dup":119}],250:[function(require,module,exports){
arguments[4][120][0].apply(exports,arguments)
},{"dup":120}],251:[function(require,module,exports){
arguments[4][121][0].apply(exports,arguments)
},{"dup":121}],252:[function(require,module,exports){
arguments[4][122][0].apply(exports,arguments)
},{"dup":122}],253:[function(require,module,exports){
arguments[4][123][0].apply(exports,arguments)
},{"./_ListCache":156,"./_Map":157,"./_MapCache":158,"dup":123}],254:[function(require,module,exports){
/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

module.exports = strictIndexOf;

},{}],255:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"./_memoizeCapped":239,"dup":124}],256:[function(require,module,exports){
arguments[4][125][0].apply(exports,arguments)
},{"./isSymbol":272,"dup":125}],257:[function(require,module,exports){
arguments[4][126][0].apply(exports,arguments)
},{"dup":126}],258:[function(require,module,exports){
arguments[4][128][0].apply(exports,arguments)
},{"dup":128}],259:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"./_baseFindIndex":174,"./_baseIteratee":188,"./toInteger":281,"dup":129}],260:[function(require,module,exports){
var baseFlatten = require('./_baseFlatten');

/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */
function flatten(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten(array, 1) : [];
}

module.exports = flatten;

},{"./_baseFlatten":175}],261:[function(require,module,exports){
arguments[4][130][0].apply(exports,arguments)
},{"./_baseGet":176,"dup":130}],262:[function(require,module,exports){
arguments[4][131][0].apply(exports,arguments)
},{"./_baseHasIn":179,"./_hasPath":214,"dup":131}],263:[function(require,module,exports){
arguments[4][132][0].apply(exports,arguments)
},{"dup":132}],264:[function(require,module,exports){
arguments[4][133][0].apply(exports,arguments)
},{"./_baseIsArguments":181,"./isObjectLike":271,"dup":133}],265:[function(require,module,exports){
arguments[4][134][0].apply(exports,arguments)
},{"dup":134}],266:[function(require,module,exports){
arguments[4][135][0].apply(exports,arguments)
},{"./isFunction":268,"./isLength":269,"dup":135}],267:[function(require,module,exports){
arguments[4][136][0].apply(exports,arguments)
},{"./_root":245,"./stubFalse":279,"dup":136}],268:[function(require,module,exports){
arguments[4][137][0].apply(exports,arguments)
},{"./_baseGetTag":178,"./isObject":270,"dup":137}],269:[function(require,module,exports){
arguments[4][138][0].apply(exports,arguments)
},{"dup":138}],270:[function(require,module,exports){
arguments[4][139][0].apply(exports,arguments)
},{"dup":139}],271:[function(require,module,exports){
arguments[4][140][0].apply(exports,arguments)
},{"dup":140}],272:[function(require,module,exports){
arguments[4][141][0].apply(exports,arguments)
},{"./_baseGetTag":178,"./isObjectLike":271,"dup":141}],273:[function(require,module,exports){
arguments[4][142][0].apply(exports,arguments)
},{"./_baseIsTypedArray":187,"./_baseUnary":196,"./_nodeUtil":242,"dup":142}],274:[function(require,module,exports){
arguments[4][143][0].apply(exports,arguments)
},{"./_arrayLikeKeys":169,"./_baseKeys":189,"./isArrayLike":266,"dup":143}],275:[function(require,module,exports){
arguments[4][145][0].apply(exports,arguments)
},{"./_MapCache":158,"dup":145}],276:[function(require,module,exports){
/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {
  // No operation performed.
}

module.exports = noop;

},{}],277:[function(require,module,exports){
arguments[4][146][0].apply(exports,arguments)
},{"./_baseProperty":192,"./_basePropertyDeep":193,"./_isKey":222,"./_toKey":256,"dup":146}],278:[function(require,module,exports){
arguments[4][147][0].apply(exports,arguments)
},{"dup":147}],279:[function(require,module,exports){
arguments[4][148][0].apply(exports,arguments)
},{"dup":148}],280:[function(require,module,exports){
arguments[4][149][0].apply(exports,arguments)
},{"./toNumber":282,"dup":149}],281:[function(require,module,exports){
arguments[4][150][0].apply(exports,arguments)
},{"./toFinite":280,"dup":150}],282:[function(require,module,exports){
arguments[4][151][0].apply(exports,arguments)
},{"./isObject":270,"./isSymbol":272,"dup":151}],283:[function(require,module,exports){
arguments[4][152][0].apply(exports,arguments)
},{"./_baseToString":195,"dup":152}],284:[function(require,module,exports){
var baseIteratee = require('./_baseIteratee'),
    baseUniq = require('./_baseUniq');

/**
 * This method is like `_.uniq` except that it accepts `iteratee` which is
 * invoked for each element in `array` to generate the criterion by which
 * uniqueness is computed. The order of result values is determined by the
 * order they occur in the array. The iteratee is invoked with one argument:
 * (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
 * // => [2.1, 1.2]
 *
 * // The `_.property` iteratee shorthand.
 * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
 * // => [{ 'x': 1 }, { 'x': 2 }]
 */
function uniqBy(array, iteratee) {
  return (array && array.length) ? baseUniq(array, baseIteratee(iteratee, 2)) : [];
}

module.exports = uniqBy;

},{"./_baseIteratee":188,"./_baseUniq":197}],285:[function(require,module,exports){
/**
 * Convert SGF files to a JS object
 * @param {string} sgf A valid SGF file.
 * @see http://www.red-bean.com/sgf/sgf4.html
 * @return {object} The SGF file represented as a JS object
 */
exports.parse = function (sgf) {
	'use strict';

	var parse;
	var parser;
	var collection = {};

	// tracks the current sequence
	var sequence;

	// tracks the current node
	var node;

	// tracks the last PropIdent
	var lastPropIdent;

	// A map of functions to parse the different components of an SGF file
	parser = {

		beginSequence: function (sgf) {
			var key = 'sequences';

			// Top-level sequences are gameTrees
			if (!sequence) {
				sequence = collection;
				key = 'gameTrees';
			}

			if (sequence.gameTrees) {
				key = 'gameTrees';
			}

			var newSequence = {
				parent: sequence
			};

			sequence[key] = sequence[key] || [];
			sequence[key].push(newSequence);
			sequence = newSequence;

			return sgf.substring(1);
		},

		endSequence: function (sgf) {
			if (sequence.parent) {
				sequence = sequence.parent;
			} else {
				sequence = null;
			}
			return sgf.substring(1);
		},

		node: function (sgf) {
			node = {};
			sequence.nodes = sequence.nodes || [];
			sequence.nodes.push(node);
			return sgf.substring(1);
		},

		property: function (sgf) {
			var propValue;

			// Search for the first unescaped ]
			var firstPropEnd = sgf.match(/([^\\\]]|\\(.|\n|\r))*\]/);

			if (!firstPropEnd.length) {
				throw new Error('malformed sgf');
			}

			firstPropEnd = firstPropEnd[0].length;

			var property = sgf.substring(0, firstPropEnd);
			var propValueBegin = property.indexOf('[');
			var propIdent = property.substring(0, propValueBegin);

			// Point lists don't declare a PropIdent for each PropValue
			// Instead, they should use the last declared property
			// See: http://www.red-bean.com/sgf/sgf4.html#move/pos
			if (!propIdent) {
				propIdent = lastPropIdent;

				// If this is the first property in a list of multiple
				// properties, we need to wrap the PropValue in an array
				if (!Array.isArray(node[propIdent])) {
					node[propIdent] = [node[propIdent]];
				}
			}

			lastPropIdent = propIdent;

			propValue = property.substring(propValueBegin + 1, property.length - 1);

			// We have no problem parsing PropIdents of any length, but the spec
			// says they should be no longer than two characters.
			//
			// http://www.red-bean.com/sgf/sgf4.html#2.2
			if (propIdent.length > 2) {
				// TODO: What's the best way to issue a warning?
				console.warn(
					'SGF PropIdents should be no longer than two characters:', propIdent
				);
			}

			if (Array.isArray(node[propIdent])) {
				node[propIdent].push(propValue);
			} else {
				node[propIdent] = propValue;
			}

			return sgf.substring(firstPropEnd);
		},

		// Whitespace, tabs, or anything else we don't recognize
		unrecognized: function (sgf) {

			// March ahead to the next character
			return sgf.substring(1);
		}
	};

	// Processes an SGF file character by character
	parse = function (sgf) {
		while (sgf) {
			var initial = sgf.substring(0, 1);
			var type;

			// Use the initial (the first character in the remaining sgf file) to
			// decide which parser function to use
			if (initial === '(') {
				type = 'beginSequence';
			} else if (initial === ')') {
				type = 'endSequence';
			} else if (initial === ';') {
				type = 'node';
			} else if (initial.search(/[A-Z\[]/) !== -1) {
				type = 'property';
			} else {
				type = 'unrecognized';
			}

			sgf = parser[type](sgf);
		}

		return collection;
	};

	// Begin parsing the SGF file
	return parse(sgf);
};

/**
 * Generate an SGF file from a SmartGame Record JavaScript Object
 * @param {object} record A record object.
 * @return {string} The record as a string suitable for saving as an SGF file
 */
exports.generate = function (record) {
	'use strict';

	function stringifySequences(sequences) {
		var contents = '';

		sequences.forEach(function (sequence) {
			contents += '(';

			// Parse all nodes in this sequence
			if (sequence.nodes) {
				sequence.nodes.forEach(function (node) {
					var nodeString = ';';
					for (var property in node) {
						if (node.hasOwnProperty(property)) {
							var prop = node[property];
							if (Array.isArray(prop)) {
								prop = prop.join('][');
							}
							nodeString += property + '[' + prop + ']';
						}
					}
					contents += nodeString;
				});
			}

			// Call the function we're in recursively for any child sequences
			if (sequence.sequences) {
				contents += stringifySequences(sequence.sequences);
			}

			contents += ')';
		});

		return contents;
	}

	return stringifySequences(record.gameTrees);
};


},{}],286:[function(require,module,exports){
/**
 * Interact with smartgame objects.
 * @param {object} smartgame A JS Object representing a smartgame
 * @see http://www.red-bean.com/sgf/sgf4.html
 * @return {object} An object with methods for navigating and manipulating a
 * smartgame
 */
module.exports = function (smartgame) {
	'use strict';

	var sequence;
	var node;

	var Smartgamer = function () {
		this.init();
	};

	Smartgamer.prototype = {
		init: function () {
			if (smartgame) {
				this.game = smartgame.gameTrees[0];
				this.reset();
			}
		},

		// Load a smartgame to make it possible to load new games or add one after
		// initialization, if desired
		load: function (newSmartgame) {
			smartgame = newSmartgame;
			this.init();
		},

		// Having multiple games in a collection is not common, but it's part of
		// the spec
		games: function () {
			return smartgame.gameTrees;
		},

		selectGame: function (i) {
			if (i < smartgame.gameTrees.length) {
				this.game = smartgame.gameTrees[i];
				this.reset();
			} else {
				throw new Error('the collection doesn\'t contain that many games');
			}

			return this;
		},

		reset: function () {
			sequence = this.game;
			node = sequence.nodes[0];
			this.path = { m: 0 };

			return this;
		},

		getSmartgame: function () {
			return smartgame;
		},

		/**
		 * Return any variations available at the current move
		 **/
		variations: function () {
			if (sequence) {
				var localNodes = sequence.nodes;
				var localIndex = (localNodes) ? localNodes.indexOf(node) : null;

				if (localNodes) {
					if (localIndex === (localNodes.length - 1)) {
						return sequence.sequences || [];
					} else {
						return [];
					}
				}
			}
		},

		/**
		 * Go to the next move
		 **/
		next: function (variation) {
			variation = variation || 0;

			var localNodes = sequence.nodes;
			var localIndex = (localNodes) ? localNodes.indexOf(node) : null;

			// If there are no additional nodes in this sequence,
			// advance to the next one
			if (localIndex === null || localIndex >= (localNodes.length - 1)) {
				if (sequence.sequences) {
					if (sequence.sequences[variation]) {
						sequence = sequence.sequences[variation];
					} else {
						sequence = sequence.sequences[0];
					}

					node = sequence.nodes[0];

					// Note the fork chosen for this variation in the path
					this.path[this.path.m] = variation;
					this.path.m += 1;
				} else {
					// End of sequence / game
					return this;
				}
			} else {
				node = localNodes[localIndex + 1];
				this.path.m += 1;
			}

			return this;
		},

		/**
		 * Go to the previous move
		 **/
		previous: function () {
			var localNodes = sequence.nodes;
			var localIndex = (localNodes) ? localNodes.indexOf(node) : null;

			// Delete any variation forks at this point
			// TODO: Make this configurable... we should keep this if we're
			// remembering chosen paths
			delete this.path[this.path.m];

			if (!localIndex || localIndex === 0) {
				if (sequence.parent && !sequence.parent.gameTrees) {
					sequence = sequence.parent;
					if (sequence.nodes) {
						node = sequence.nodes[sequence.nodes.length - 1];
						this.path.m -= 1;
					} else {
						node = null;
					}
				} else {
					// Already at the beginning
					return this;
				}
			} else {
				node = localNodes[localIndex - 1];
				this.path.m -= 1;
			}

			return this;
		},

		// Go to the last move of the game
		last: function () {
			var totalMoves = this.totalMoves();

			while(this.path.m < totalMoves) {
				this.next();
			}

			return this;
		},

		// Go to the first move of the game
		first: function () {
			this.reset();
			return this;
		},

		/**
		 * Go to a particular move, specified as a
		 * a) number
		 * b) path string
		 * c) path object
		 **/
		goTo: function (path) {
			if (typeof path === 'string') {
				path = this.pathTransform(path, 'object');
			} else if (typeof path === 'number') {
				path = { m: path };
			}

			this.reset();

			var n = node;

			for (var i = 0; i < path.m && n; i += 1) {
				// Check for a variation in the path for the upcoming move
				var variation = path[i + 1] || 0;
				n = this.next(variation);
			}

			return this;
		},

		getGameInfo: function () {
			return this.game.nodes[0];
		},

		// Provide the current node
		node: function () {
			return node;
		},

		// Get the total number of moves in a game
		totalMoves: function () {
			var localSequence = this.game;
			var moves = 0;
			while(localSequence) {
				moves += localSequence.nodes.length;

				if (localSequence.sequences) {
					localSequence = localSequence.sequences[0];
				} else {
					localSequence = null;
				}
			}

			// TODO: Right now we're *assuming* that the root node doesn't have a
			// move in it, which is *recommended* but not required practice.
			// @see http://www.red-bean.com/sgf/sgf4.html
			// "Note: it's bad style to have move properties in root nodes.
			// (it isn't forbidden though)"
			return moves - 1;
		},

		// Get or set a comment on the current node
		// @see http://www.red-bean.com/sgf/sgf4.html#text
		comment: function (text) {
			if (typeof text === 'undefined') {
				// Unescape characters
				if (node.C) {
					return node.C.replace(/\\([\\:\]])/g, '$1');
				} else {
					return '';
				}
			} else {
				// Escape characters
				node.C = text.replace(/[\\:\]]/g, '\\$&');
			}
		},

		/**
		 * Translate alpha coordinates into an array
		 * @param string alphaCoordinates
		 * @return array [x, y]
		 **/
		translateCoordinates: function (alphaCoordinates) {
			var coordinateLabels = 'abcdefghijklmnopqrst';
			var intersection = [];

			intersection[0] = coordinateLabels.indexOf(alphaCoordinates.substring(0, 1));
			intersection[1] = coordinateLabels.indexOf(alphaCoordinates.substring(1, 2));

			return intersection;
		},

		/**
		 * Convert path objects to strings and path strings to objects
		 **/
		pathTransform: function (input, outputType, verbose) {
			var output;

			// If no output type has been specified, try to set it to the
			// opposite of the input
			if (typeof outputType === 'undefined') {
				outputType = (typeof input === 'string') ? 'object' : 'string';
			}

			/**
			 * Turn a path object into a string.
			 */
			function stringify(input) {
				if (typeof input === 'string') {
					return input;
				}

				if (!input) {
					return '';
				}

				output = input.m;

				var variations = [];
				for (var key in input) {
					if (input.hasOwnProperty(key) && key !== 'm') {
						// Only show variations that are not the primary one, since
						// primary variations are chosen by default
						if (input[key] > 0) {
							if (verbose) {
								variations.push(', variation ' + input[key] + ' at move ' + key);
							} else {
								variations.push('-' + key + ':' + input[key]);
							}
						}
					}
				}

				output += variations.join('');
				return output;
			}

			/**
			 * Turn a path string into an object.
			 */
			function parse(input) {
				if (typeof input === 'object') {
					input = stringify(input);
				}

				if (!input) {
					return { m: 0 };
				}

				var path = input.split('-');
				output = {
					m: Number(path.shift())
				};

				if (path.length) {
					path.forEach(function (variation, i) {
						variation = variation.split(':');
						output[Number(variation[0])] = parseInt(variation[1], 10);
					});
				}

				return output;
			}

			if (outputType === 'string') {
				output = stringify(input);
			} else if (outputType === 'object') {
				output = parse(input);
			} else {
				output = undefined;
			}

			return output;
		}
	};

	return new Smartgamer();
};

},{}],287:[function(require,module,exports){
'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

/* globals module: false, require: false

*/
/**
 * Provides a function for transforming SGF for a Go variant to SGF for a standard Go viewer; also provides a function for the inverse transformation.
 * @param {object} [options=] Defines various options for the output SGF. May be omitted, in which case the default options (see below) are used.
 * @param {boolean} [options.addComments = false] When flagged, comments are added to each node giving the move number and the number of stones captured by Black and White.
 * @param {boolean} [options.addMoveNumber = false] When flagged, `MN[<moveNumber>]` is added to each node.
 * @param {number} [options.moveType = 2] Controls how moves are represented in the transformed SGF. Examples given for black moves, so with option 2 a white move is represented by `W[point]AW[otherPoints]`. Options: 
 * 
 * - 0: `AB[points]`;
 * 
 * - 1: `AB[points]B[]` (same as for `moveType===0` but with the pass (B[]);
 * 
 * - 2: `B[point]AB[otherPoints]` where `point` is the coordinates of the move in the main board (a single point), and `otherPoints` is an array of the coordinates of the move in the wraparound area.;
 * 
 * - 3: `B[points]`;
 * 
 * @param {string} [options.markLastMove = null] Gives the SGF attribute to be created to mark each move. May be left empty/null/undefined. Or else a value like `"CR"`.
 * @param {array} [options.boardDimensions = [11, 11]] May be used for rectangular t-Go. Should be ommitted for [n, n] t-Go, where n is specified in the input SGF (@param variantSgf).
 * @param {number} [options.coordinatesType = 0] Options: 
 * 
 * - 0: none;
 * 
 * - 1: (;A|1-K|11): Western;
 * 
 * - 2: (;A|1-L|11): Western, no I;
 * 
 * - 3: (;1|1-11|11): Latin/Latin, top to bottom;
 * 
 * - 4: (;1|1-11|): Latin/Chinese, top to bottom;
 * 
 * @param {number} [options.wraparoundMarkersType = 1] Options:
 * 
 * - 0: none;
 * 
 * - 1: Full outline, using unicode Box Drawing symbols;
 * 
 * - 2: corners and middles, using unicode Box Drawing symbols;
 * 
 * - 3: just corners, using unicode Box Drawing symbols;
 * 
 * - 4: just middles, using unicode Box Drawing symbols;
 * 
 * @param {object} [options.projectionSettings=] Further optional settings for how the (toroidal, or other sort of) board is projected to a flat grid.
 * @param {number} [options.projectionSettings.wraparound = 4]  Number of lines to add for the wraparound.
 * @param {array} [options.projectionSettings.offset = [0,0]]  Translation to apply to all moves.
 * @param {boolean} [options.transformToString=true] When set to false, the output is an object (an instance of a Smartgame).
 * @public
 * @return {object} An object exposing functions for going back and forth between SGF for a standard viewer, and SGF for a game of toroidal Go
 */ /*todos:
    opions.placesToCount Default: undefined. May be: 'last'|[countInfo1, .. countInfo1]. countInfo is a path plus an array with a point for each chain to be considered as dead. {path, deadChains: [...]}
    options.projectionSettings.rotation {integer} Default value: 0. Allowed values: 0 .. 3
    options.projectionSettings.normalizePlace array, or one of: C, TL TR BL BR (centre, top left, top right, bottom left, bottom right)
    options.projectionSettings.normalize {boolean} 
    */
function transformer(options) {
	'use strict';

	var _flatten = require('lodash/flatten'),
	    _uniqBy = require('lodash/uniqBy'),
	    _fi = require('lodash/findIndex'),
	    modulo = function modulo(x, y) {
		return (x % y + y) % y;
	},
	    sourceSgfMessage = 'source sgf for toroidal Go has been adapted by go-variants-transformer so as to be rendered by any standard Go application';
	options = _extends({
		boardDimensions: [11, 11],
		transformToString: true,
		addComments: true,
		coordinatesType: 0,
		wraparoundMarkersType: 1,
		moveType: 2,
		markLastMove: null
		//above are the defaults
	}, options);
	options.projectionSettings = _extends({
		wraparound: 4,
		offset: [0, 0]
	}, options.projectionSettings);

	if (options.addPasses === undefined) options.addPasses = true;

	options.boardDimensions = options.boardDimensions || [11, 11];

	if (options.transformToString === undefined) options.transformToString = true;

	if (options.addComments === undefined) options.addComments = true;
	// options.projectionSettings = 

	var wraparound = options.projectionSettings.wraparound;

	var $ = {}
	// , _markersForWraparound = null
	,
	    coordinateLabels = function coordinateLabels(i) {
		// 97..122 and 65..90
		return String.fromCharCode(i < 26 ? i + 97 : i + 39);
		//65 - 26 =
	},
	    translateCoordinate = function translateCoordinate(c) {
		var r = c.charCodeAt(0);
		return r >= 97 ? r - 97 : r - 26;
	},

	/**
  * Translate alpha coordinates into an array
  * @param string alphaCoordinates
  * @return array [x, y]
  **/
	translateCoordinates = function translateCoordinates(alphaCoordinates) {
		return [translateCoordinate(alphaCoordinates.substring(0, 1)), translateCoordinate(alphaCoordinates.substring(1, 2))];
	};

	$.coordinateLabels = coordinateLabels;
	$.translateCoordinates = translateCoordinates;
	/**
  * @public
  */
	$.options = options;

	$.projectOnLine = function (a, isVertical) {
		/*
  m: boardDimensions[0] : 11
  n: wraparound : 4
  line: 0,...,(m-1)
  =>
  0,...,(n-1), (start line) n, ... , (n + m - 1) end line,  (n+m), ... , (2n + m - 1)
  		coordinate a  {0 .. m-1} projects to n + a in main area
  all projections are of the form n + a + xm, x   s.t. 0  n + a + xm  2n + m -1
  -xm  n + a
  	smallest such x < 0 is ceil(-(n+a)/m)
   xm  n + m - 1 -a
  	largest such x is floor((n + m - 1 -a) / m)
  
  */

		var m //= options.boardDimensions[0]
		= options.boardDimensions[isVertical ? 1 : 0],
		    r = [];

		for (var i = Math.ceil(-(wraparound + a) / m); i <= (wraparound + m - 1 - a) / m; i++) {
			r.push(wraparound + a + i * m);
		}if (options.moveType === 2) {
			//ensure the last item in the result is the one inside the main board area
			r.sort(function (x, y) {
				if (x >= wraparound && x < wraparound + m) return 1;
				if (y >= wraparound && y < wraparound + m) return -1;
				return 0;
			});
		}
		return r;
	};

	/**
  * This is the inverse function to the function projectOnFlat  at least it is when multiple is false.
  * @param {Array} points The point or array of points projected onto the grid.
  * @param {Boolean=false} multiple Whether the argument points is the image of a single point (multiple=false) or of multiple points.
  * @returns {Array} When the flag multiple is flagged, returns an array of points; otherwise returns a single point (i.e. an array of two integers).
  */
	function inverseProjectOnFlat(points, multiple) {
		if (!Array.isArray(points[0])) points = [points];
		if (!multiple) return [modulo(points[0][0] - options.projectionSettings.offset[0] - wraparound, options.boardDimensions[0]), modulo(points[0][1] - options.projectionSettings.offset[1] - wraparound, options.boardDimensions[1])];
		return _uniqBy(points.map(function (x) {
			return inverseProjectOnFlat([x]);
		}), function (x) {
			return x[0] + '_' + x[1];
		});
	}
	$.inverseProjectOnFlat = inverseProjectOnFlat;

	/**
  * Projects a point on the t-Go board to the array of points on the standard grid/board.
  * @param {Array} p The point in the t-Go board to be projected on to the grid.
  * @returns {Array}
  */
	function projectOnFlat(p) {
		var a = $.projectOnLine(p[0] + options.projectionSettings.offset[0]),
		    b = $.projectOnLine(p[1] + options.projectionSettings.offset[1], true),
		    r = [];
		for (var i = 0; i < a.length; i++) {
			for (var j = 0; j < b.length; j++) {
				r.push([a[i], b[j]]);
			}
		}return r;
	}
	$.projectOnFlat = projectOnFlat;

	$.modX = function (x) {
		return modulo(x, options.boardDimensions[0]);
	};
	$.modY = function (y) {
		return modulo(y, options.boardDimensions[1]);
	};

	var setUpMarkers = function setUpMarkers() {
		$.wraparoundAndCoords = [];

		// $.getMarkersForWraparound = function (){
		if (options.projectionSettings.wraparound > 0) {
			var m = options.boardDimensions[0],
			    n = options.boardDimensions[1];

			/*
   m: boardDimensions[0] : 11
   w: wraparound : 4
   line: 0,...,(m-1)
   =>
   0,...,(w-1), (start line) w, ... , (w + m - 1) end line, (w+m), ... , (2w + m - 1)
   */

			var board = [];
			if ([1, 2, 4].indexOf(options.wraparoundMarkersType) > -1) {
				var middles = options.wraparoundMarkersType > 1 ? [Math.floor((m - 1) / 2) + 1, Math.ceil((m - 1) / 2) + 1, Math.floor((n - 1) / 2) + 1, Math.ceil((n - 1) / 2) + 1] : [-1, 99, -1, 99];
				for (var i = 1; i <= m; i++) {
					if (i < middles[0] || i > middles[1]) {
						continue;
					}
					var label = ''; //U+2500 Box Drawings Light Horizontal

					board.push(coordinateLabels(wraparound - 1 + i) + coordinateLabels(wraparound - 1) + ":" + label);
					board.push(coordinateLabels(wraparound - 1 + i) + coordinateLabels(wraparound + m) + ":" + label);
				}
				for (var _i = 1; _i <= n; _i++) {
					if (_i < middles[2] || _i > middles[3]) {
						continue;
					}
					var _label = ''; //unicode too
					board.push(coordinateLabels(wraparound - 1) + coordinateLabels(wraparound - 1 + _i) + ":" + _label);
					board.push(coordinateLabels(wraparound + n) + coordinateLabels(wraparound - 1 + _i) + ":" + _label);
				}
			}
			if ([1, 2, 3].indexOf(options.wraparoundMarkersType) > -1) {
				//     
				board.push(coordinateLabels(wraparound - 1) + coordinateLabels(wraparound + n) + ":");
				board.push(coordinateLabels(wraparound + m) + coordinateLabels(wraparound + n) + ":");
				board.push(coordinateLabels(wraparound - 1) + coordinateLabels(wraparound - 1) + ":");
				board.push(coordinateLabels(wraparound + m) + coordinateLabels(wraparound - 1) + ":");
			}

			if (options.coordinatesType > 0 && wraparound > 1) {
				for (var _i2 = 1; _i2 < 2 * wraparound + m - 1; _i2++) {

					var coordIndex = $.modX(-options.projectionSettings.offset[0] - wraparound + _i2);

					if (options.coordinatesType === 2 && coordIndex >= 8) {
						//omit the I - historical coordinates for Go...
						//I: 9th letter
						coordIndex++;
					}
					var _label2 = options.coordinatesType < 3 ? coordinateLabels(coordIndex).toUpperCase() : '' + (coordIndex + 1);
					board.push(coordinateLabels(_i2) + coordinateLabels(0) + ":" + _label2);
					board.push(coordinateLabels(_i2) + coordinateLabels(2 * wraparound + n - 1) + ":" + _label2);
				}
				var cjkNumbers = '';
				for (var _i3 = 1; _i3 < 2 * wraparound + n - 1; _i3++) {
					/*
     0		-w
     ...
     w-1	-1
     w		0
     ...
     w + n -1
     
     */
					var _coordIndex = options.coordinatesType < 3 ? $.modY(n + options.projectionSettings.offset[1] + wraparound - _i3 - 1) : $.modY(_i3 - wraparound - options.projectionSettings.offset[1]);
					var _label3 = '';
					switch (options.coordinatesType) {
						case 1:
						case 2:
						case 3:
							_label3 = '' + (_coordIndex + 1);
							break;
						case 4:
							_label3 = modulo(_coordIndex, 10) === 9 ? '' : cjkNumbers[modulo(_coordIndex, 10)];

							if (_coordIndex > 8) {
								_label3 = (_coordIndex > 18 ? cjkNumbers[Math.floor((_coordIndex + 1) / 10) - 1] : '') + '' + _label3;
							}
							break;
					}
					board.push(coordinateLabels(0) + coordinateLabels(_i3) + ":" + _label3);
					board.push(coordinateLabels(2 * wraparound + m - 1) + coordinateLabels(_i3) + ":" + _label3);
				}
			}

			$.wraparoundAndCoords = board;
		}
	};
	setUpMarkers();

	$.coords2String =
	/**
  * converts coordinates to a string
  */
	function coords2String(coords) {
		return coordinateLabels(coords[0]) + coordinateLabels(coords[1]);
	};

	function goThroughTree(state) {
		var wrappedGame = state.wrappedGame,
		    node = state.node,
		    pending = state.pending,
		    currentPath = state.currentPath,
		    tGo = state.tGo,
		    nbVariations = wrappedGame.variations().length;

		if (currentPath.m > 1000) throw new Error('seem to be stuck!');
		state.hasSiblings = nbVariations > 0;
		if (state.hasSiblings) {
			// if(currentPath[m] === undefined)
			// currentPath[m] = 0
			// else
			// currentPath[m] += 1
			// currentPath.m += 1
			for (var i = nbVariations - 1; i > 0; i--)
			//pile up in this order, as it's FILO and we want the last variation, which may contain a mode added by CGoboard to go last
			{
				var pathForLater = _extends({}, currentPath); //Object.assign({}, currentPath)
				pathForLater[currentPath.m + 1] = i;
				pathForLater.m += 1;

				if (tGo !== undefined) pending.push({ path: pathForLater, tGoData: tGo.exportData() });else pending.push({ path: pathForLater });
			}
			state.node = wrappedGame.next().node();
			currentPath[currentPath.m + 1] = 0;
			currentPath.m += 1;
			return state.node;
		}

		var nextNode = wrappedGame.next().node();
		if (node === nextNode) {
			//at a leaf:
			if (pending.length === 0) {
				state.node = null;
				return state.node; //finished
			}
			var fromStack = pending.pop();
			state.hasSiblings = true;
			// if (fromStack === null) {
			// 	node = null
			// 	return//finished!
			// }
			if (tGo !== undefined) tGo.loadData(fromStack.tGoData);
			state.node = wrappedGame.goTo(fromStack.path).node();
			state.currentPath = fromStack.path;
			return state.node;
		} else {
			currentPath.m += 1;
			state.node = nextNode;
			return state.node;
		}
	}

	/**
  * Apart from a few details, this is an inverse of the transform function.
  * @param {smartgame|string} wrappedGame
  * @param {smartgame} smartgame
  * @public
  */
	function inverseTransform(wrappedGame, smartgame) {

		if (smartgame === undefined) {
			smartgame = require('smartgame');
		}

		if (typeof wrappedGame === 'string') {
			var smartgamer = require('smartgamer');
			wrappedGame = smartgamer(smartgame.parse(wrappedGame));
		}

		var node = wrappedGame.first().node(),
		    pending = [],
		    currentPath = { m: 0 },
		    cleanerRegEx = /^[a-zA-Z :0-9\-(\r\n]+GoVariantsTransformer\)--[\r\n]*/,
		    cleanComments = function cleanComments() {
			if (node.C !== undefined) {
				node.C = node.C.replace(cleanerRegEx, '');
			}
			if (node.C === '') delete node.C;
		},

		/**
   * Function to:
   * 	- remove the border (unicode symbols added by the transform to indicate where the wraparound area meets the main grid).
   * 	- remove CM (colour map) and CT (colour table) which are nonstandard SGF added by CGoboard for background colour (could be interesting to use this feature later on).
   */
		cleanLabels = function cleanLabels() {

			var labels = [];
			if (node.LB !== undefined) {
				labels = node.LB;
				if (!Array.isArray(labels)) labels = [labels];
				labels = labels.filter(function (i) {
					return !$.wraparoundAndCoords.includes(i);
				});
				/* jshint loopfunc: true */
				labels = _uniqBy(labels.map(function (x) {
					return x.split(':', 2);
				}) //assume the label doesnt contain :
				.map(function (x) {
					return [$.coords2String($.inverseProjectOnFlat(translateCoordinates(x[0]))), x[1]];
				}), function (x) {
					return x[0];
				}).map(function (x) {
					return x[0] + ':' + x[1];
				});

				// labels = []
				// for (let i = 0; i < labels2.length; i++)
				// 	labels = labels.concat(labels2)
			}

			node.LB = labels;
			if (node.LB.length === 0) delete node.LB;

			if (node.CM) delete node.CM;
			if (node.CT) delete node.CT;
		};

		cleanLabels();
		node.SZ = options.boardDimensions[0];
		node.AP = "go-variants-transformer";

		if (node.SO !== undefined) {
			var cleanSourceRegex = new RegExp(' \\(' + sourceSgfMessage + '\\)');
			node.SO = node.SO.replace(cleanSourceRegex, '');
			// if (node.SO === '')
			// 	delete node.SO
		}

		var state = {
			wrappedGame: wrappedGame, node: node, pending: pending, currentPath: currentPath, siblingMoves: {} //, parentsWithChildToDelete: [] 
		};

		node = goThroughTree(state);
		while (node !== null) {
			cleanLabels();
			cleanComments();

			var isBlack = node.AB !== undefined || node.B !== undefined,
			    addedStones = isBlack ? node.AB : node.AW,
			    playedStone = isBlack ? node.B : node.W,
			    move = addedStones ? addedStones : playedStone,
			    moveAsArray = Array.isArray(move) ? move : [move],
			    isAPass = isBlack ? node.B === '' : node.W === '',
			    moveHasCoords = move !== undefined && move !== '',
			    coords = !moveHasCoords ? undefined : $.coords2String($.inverseProjectOnFlat(moveAsArray.map(translateCoordinates)));

			//alter the node

			/*
   logic removing a node added by CGoboard, if there already is the same move as AB or AW in a prior variation; assuming 
   the variation to be removed is the last of the siblings - which does seem to be the way CGoboard behaves when a click 
   is made on a point where the next node is AB or AW.  
   */
			if (state.hasSiblings) {
				var pathForParent = _extends({}, wrappedGame.path); //Object.assign({}, wrappedGame.path)
				pathForParent.m--;
				delete pathForParent[pathForParent.m];
				pathForParent = wrappedGame.pathTransform(pathForParent);
				// wrappedGame.previous()
				if (state.siblingMoves[pathForParent] === undefined) {
					state.siblingMoves[pathForParent] = [];
				}
				if (addedStones) {
					state.siblingMoves[pathForParent].push(coords);
				} else if (playedStone && state.siblingMoves[pathForParent].indexOf(coords) > -1) {

					// state.parentsWithChildToDelete.push(pathForParent)
					node.XX = "inverseTransformToDelete";
				}
				// wrappedGame.goTo(currentPath)
			}

			delete node[isBlack ? 'AB' : 'AW'];
			delete node[isBlack ? 'B' : 'W'];
			delete node.CR;
			delete node.AE;

			if (isAPass) {
				node[isBlack ? 'B' : 'W'] = '';
			}

			if (moveHasCoords) {
				node[isBlack ? 'B' : 'W'] = coords;
			}

			; /*note: this next semicolon is needed! */[// eslint-disable-line no-extra-semi
			//'CR',todo: add if not marking the move
			'DD', 'MA', 'SL', 'SQ', 'TR'].forEach(function (sgfProperty) {
				// _.map(['DD','MA','SL','SQ','TR'], function(sgfProperty){
				if (node[sgfProperty] === undefined) return;
				var points = [];
				if (Array.isArray(node[sgfProperty])) {
					points = node[sgfProperty];
				} else {
					points = [node[sgfProperty]];
				}
				points = $.inverseProjectOnFlat(points.map(translateCoordinates), true).map($.coords2String);
				node[sgfProperty] = points;
			});
			// move to next node
			node = goThroughTree(state);
		}

		// state.parentsWithChildToDelete.forEach((path) => {
		// 	//remove the sgf node
		// 	wrappedGame.goTo(path)
		// 	let sequences = wrappedGame.game.sequences
		// 	let index = _fi(sequences, (seq) => seq.nodes[0].inverseTransformToDelete)
		// 		, tmpI = 0
		// 	while (index > -1) {
		// 		sequences.splice(index, 1)
		// 		index = _fi(sequences, (seq) => seq.nodes[0].inverseTransformToDelete)
		// 		tmpI++
		// 		if (tmpI > 100) throw new Error('seem to be stuck!');
		// 	}

		// 	// console.log(path)
		// })

		var deleteNodes = function deleteNodes(sequence) {
			if (sequence.sequences) {

				var sequences = sequence.sequences,
				    index = _fi(sequences, function (seq) {
					return seq.nodes[0].XX === 'inverseTransformToDelete';
				}),
				    tmpI = 0,
				    max = sequences.length;
				while (index > -1) {
					sequences.splice(index, 1);
					index = _fi(sequences, function (seq) {
						return seq.nodes[0].XX === 'inverseTransformToDelete';
					});
					tmpI++;
					if (tmpI > max) throw new Error('seem to be stuck!');
				}
				for (var index2 = 0; index2 < sequences.length; index2++) {
					// deleteNodes(sequences[index2].nodes[sequences[index2].nodes.length - 1]);
					deleteNodes(sequences[index2]);
				}
			} else if (sequence.nodes) deleteNodes(sequence.nodes[sequence.nodes.length - 1]);
		};
		deleteNodes(wrappedGame.game);

		if (options.transformToString) return smartgame.generate({ gameTrees: [wrappedGame.game] });else return wrappedGame;
	}
	$.inverseTransform = inverseTransform;

	/**
  * Main function; converts SGF for a Go variant (so far, just toroidal Go or t-Go).
  * @param {string} tSgf
  * @param {object} tGo Engine for counting liberties in t-Go. An instance of go-variants-engine.
  * @param {*} smartgame
  * @param {*} smartgamer
  * @returns {string|object} SGF that can be viewed in a standard SGF viewer. (See `options.transformToString` for the data type of the value returned.)
  * @public
  */
	function transform(tSgf //eg 11x11 sgf from LittleGolem
	, tGo //app implementing t-Go
	, smartgame, smartgamer) {

		if (tGo === undefined) {
			//  tGo = require('../dist/node_modules/go-variants-engine/src/engine.min.js')({
			//  tGo = require('../../engine/dist/engine.min.js')({
			tGo = require('go-variants-engine')({
				// tGo = require('../node_modules/go-variants-engine/src/engine')({
				// boardMode:'t',
				boardDimensions: options.boardDimensions
			});
			// tGo = require('../node_modules/go-variants-engine')({boardMode:'t', boardDimensions:options.boardDimensions})
			// tGo = require('../node_modules/go-variants-engine/src/engine')({boardMode:'t', boardDimensions:options.boardDimensions})
		}
		// else {
		// 	tGo.options.boardDimensions = options.boardDimensions
		// }

		if (smartgame === undefined) {
			smartgame = require('smartgame');
		}
		if (smartgamer === undefined) {
			smartgamer = require('smartgamer');
		}
		// console.log(tGo)
		var parsed = smartgame.parse(tSgf),
		    wrappedGame = smartgamer(parsed),
		    node = wrappedGame.node(),
		    passes = 0,
		    pending = [],
		    currentPath = { m: 0 };
		if (node.SZ !== undefined) {
			var sz = Number(node.SZ);
			// sz+= 2*options.projectionSettings.wraparound
			options.boardDimensions = [sz, sz];
			tGo.options.boardDimensions = options.boardDimensions;
			setUpMarkers();
		}
		if (node.KM !== undefined) {
			options.rules = _extends({ komi: parseFloat(node.KM) }, options.rules);
		}
		node.SZ = "" + (options.boardDimensions[0] + 2 * options.projectionSettings.wraparound); //not sure how to make a rectangular goban!
		//offset modulo
		options.projectionSettings.offset[0] = modulo(options.projectionSettings.offset[0], options.boardDimensions[0]);
		options.projectionSettings.offset[1] = modulo(options.projectionSettings.offset[1], options.boardDimensions[1]);
		var setLabels = function setLabels() {
			//node.LB = $.wraparoundAndCoords
			var labels = [];
			if (node.LB !== undefined) {
				(function () {
					labels = node.LB;
					if (!Array.isArray(labels)) labels = [labels];

					/* jshint loopfunc: true */
					var labels2 = labels //_.chain(labels)
					.map(function (x) {
						return x.split(':', 2);
					}) //assume the label doesnt contain :
					.map(function (x) {
						return [translateCoordinates(x[0]), x[1]];
					}).map(function (x) {
						return [$.projectOnFlat(x[0]), x[1]];
					});
					// .value()
					labels = [];

					var _loop = function _loop(i) {
						labels = labels.concat(labels2[i][0].map(function (x) {
							return $.coords2String(x) + ":" + labels2[i][1];
						}));
					};

					for (var i = 0; i < labels2.length; i++) {
						_loop(i);
					}
				})();
			}

			node.LB = $.wraparoundAndCoords.concat(labels);
			if (node.LB.length === 0)
				// delete node['LB']
				delete node.LB;
		};

		setLabels();

		if (node.SO !== undefined) node.SO = wrappedGame.game.nodes[0].SO + (' (' + sourceSgfMessage + ')');
		//else node.SO = sourceSgfMessage//prefer not to add the message when original Sgf has no SO info.

		node.AP = "go-variants-transformer";

		var state = { wrappedGame: wrappedGame, node: node, pending: pending, currentPath: currentPath, tGo: tGo };

		function comment(isPass, isBlack, score) {
			if (!options.addComments && !score) return;

			var r = !options.addComments ? '' : 'move ' + state.currentPath.m + '\n' + 'White stones captured by Black: ' + tGo.board.captured[1] + '\nBlack stones captured by White: ' + tGo.board.captured[0]
			//let r =  'Black captures: ' + tGo.board.captured[1] + '\r\nWhite captures: ' + tGo.board.captured[0]
			+ (!isPass ? '' : '\n' + (isBlack ? 'Black passes' : 'White passes')) + (!score ? '' : '\n' + ('result: ' + score.displayResult));

			r += '\n--(the content above was generated automatically by GoVariantsTransformer)--';
			r += node.C === undefined ? '' : '\n' + node.C;
			node.C = r;
			return;
		}

		node = goThroughTree(state);
		while (node !== null) {

			var isBlack = node.B !== undefined,
			    move = isBlack ? node.B : node.W,
			    isAPass = move === "" || options.boardDimensions[0] === options.boardDimensions[1] && options.boardDimensions[0] <= 19 && move === "tt" //weird SGF[3] way to show a pass move!
			,
			    stonesMarkedForScoring = [];

			if (move === undefined && !isAPass) {
				node = goThroughTree(state);
				continue;
			}
			setLabels();

			if (isAPass) {
				delete node[isBlack ? 'B' : 'W'];
				comment(isAPass, isBlack);
				node[isBlack ? 'AB' : 'AW'] = [];
				// if (passes === 2) {
				// 	//wrappedGame.game.nodes.splice(i+1)//get rid of nodes afterwards -- may not work with variations! todo
				// 	break;//stop after 3 successive passes for now
				// }
				passes++;
				if (passes >= 1000) break; //just in case!
				node = goThroughTree(state);
			} else {
				var coords = translateCoordinates(move);
				var playResult = null;
				// run move through tGo and update game accordingly
				try {
					playResult = tGo.play(isBlack ? 'b' : 'w', coords);
				} catch (error) {
					if (error.message !== 'point is not empty' /*ignore this - it happens with some sgf from littleGolem. Todo: look into scoring the position here. */) throw error;
				}
				var projectedCoords = $.projectOnFlat(coords);
				var toAdd = playResult === null ? [] : projectedCoords.map($.coords2String),
				    toRemove = playResult === null ? [] :
				// _.chain(playResult.removed)
				// 	.flatten(true)
				// 	.map($.projectOnFlat)
				// 	.flatten(true)
				// 	.map($.coords2String)
				// 	.value()
				_flatten(_flatten(playResult.removed).map($.projectOnFlat)).map($.coords2String);

				//alter the node
				if (options.moveType === 2) {
					var moveMarker = '' + (isBlack ? 'B' : 'W');
					node[moveMarker] = toAdd.pop();
					if (toAdd.length > 0) {
						node['A' + moveMarker] = toAdd;
					}
				} else {
					var _moveMarker = '' + (options.moveType < 3 ? 'A' : '') + (isBlack ? 'B' : 'W');

					node[_moveMarker] = toAdd;
					if (options.markLastMove) {
						node[options.markLastMove] = toAdd;
					}
				}

				if (options.moveType === 1) node[isBlack ? 'B' : 'W'] = '';

				if (toRemove.length > 0) node.AE = toRemove

				/*
    todo: other properties with board coordinates
    Leave for now:
    AR
    LN
    */

				; /*note this semicolon is needed! */
				[
				//'CR',todo: add if not marking the move
				'DD', 'MA', 'SL', 'SQ', 'TR'].forEach(function (sgfProperty) {
					// _.map(['DD','MA','SL','SQ','TR'], function(sgfProperty){
					if (node[sgfProperty] === undefined) return;
					var points = [];
					if (Array.isArray(node[sgfProperty])) {
						points = node[sgfProperty];
					} else {
						points = [node[sgfProperty]];
					}
					if (node.SC && sgfProperty === 'MA') {
						stonesMarkedForScoring = _extends({}, points);
					}
					points =
					// _.chain(points)
					// 	.map(translateCoordinates)
					// 	.map($.projectOnFlat)
					// 	.flatten(true)
					// 	.map($.coords2String)
					// 	.value()
					_flatten(points.map(translateCoordinates).map($.projectOnFlat)).map($.coords2String);
					node[sgfProperty] = points;
				});
				if (options.addMoveNumber) node.MN = currentPath.m;

				/*
    Use a custom, new SGF property, SC, in order to see if the current position should be scored, and if so, what to do with the score.
    Its a bit flag.  
    1	 update the comments for the node (succint). When flagged, the next option is not available.
    2	 update the comments for the node (verbose)
    4	 update the game result (RE) for the root node
    Typical usage: add SC[6] to the last node, and SC[2] to score a variation.
    */
				var updatedComment = false;
				if (node.SC) {
					var score = tGo.board.score(stonesMarkedForScoring),
					    scoreOption = parseInt(node.SC);
					if (scoreOption & 1 === 1) {
						updatedComment = true;
						comment(isAPass, isBlack, score.RE);
					} else /*don't want to treat succint and verbose at the same time*/
						if (scoreOption & 2 === 2) {
							updatedComment = true;
							comment(isAPass, isBlack, 'Black: ' + (score.totalWhiteDead + score.totalWhiteCaptured + score.totalBlackTerritory) + ' = ' + score.totalBlackTerritory + ' territory + ' + (score.totalWhiteDead + score.totalWhiteCaptured) + ' prisoners\nWhite: ' + (score.totalBlackDead + score.totalBlackCaptured + score.totalWhiteTerritory) + ' = ' + score.totalWhiteTerritory + ' territory + ' + (score.totalBlackDead + score.totalBlackCaptured) + ' prisoners +' + tGo.rules.komi + ' komi');
						}
					if (scoreOption & 4 === 4) {
						wrappedGame.game.nodes[0].RE = score.RE;
					}
				}
				if (!updatedComment) comment(isAPass, isBlack);

				// move to next node
				node = goThroughTree(state);
			}
		}
		if (options.transformToString) return smartgame.generate({ gameTrees: [wrappedGame.game] });else return wrappedGame;
	}
	$.transform = transform;
	return $;
}
module.exports = transformer;

},{"go-variants-engine":153,"lodash/findIndex":259,"lodash/flatten":260,"lodash/uniqBy":284,"smartgame":285,"smartgamer":286}]},{},[287])(287)
});

//# sourceMappingURL=transformer.min.js.map
