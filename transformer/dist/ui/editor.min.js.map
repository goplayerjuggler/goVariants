{"version":3,"sources":["ui/node_modules/browser-pack/_prelude.js","ui/node_modules/go-variants-engine/node_modules/lodash/_DataView.js","ui/node_modules/go-variants-engine/node_modules/lodash/_Hash.js","ui/node_modules/go-variants-engine/node_modules/lodash/_ListCache.js","ui/node_modules/go-variants-engine/node_modules/lodash/_Map.js","ui/node_modules/go-variants-engine/node_modules/lodash/_MapCache.js","ui/node_modules/go-variants-engine/node_modules/lodash/_Promise.js","ui/node_modules/go-variants-engine/node_modules/lodash/_Set.js","ui/node_modules/go-variants-engine/node_modules/lodash/_SetCache.js","ui/node_modules/go-variants-engine/node_modules/lodash/_Stack.js","ui/node_modules/go-variants-engine/node_modules/lodash/_Symbol.js","ui/node_modules/go-variants-engine/node_modules/lodash/_Uint8Array.js","ui/node_modules/go-variants-engine/node_modules/lodash/_WeakMap.js","ui/node_modules/go-variants-engine/node_modules/lodash/_addMapEntry.js","ui/node_modules/go-variants-engine/node_modules/lodash/_addSetEntry.js","ui/node_modules/go-variants-engine/node_modules/lodash/_arrayEach.js","ui/node_modules/go-variants-engine/node_modules/lodash/_arrayFilter.js","ui/node_modules/go-variants-engine/node_modules/lodash/_arrayLikeKeys.js","ui/node_modules/go-variants-engine/node_modules/lodash/_arrayMap.js","ui/node_modules/go-variants-engine/node_modules/lodash/_arrayPush.js","ui/node_modules/go-variants-engine/node_modules/lodash/_arrayReduce.js","ui/node_modules/go-variants-engine/node_modules/lodash/_arraySome.js","ui/node_modules/go-variants-engine/node_modules/lodash/_assignValue.js","ui/node_modules/go-variants-engine/node_modules/lodash/_assocIndexOf.js","ui/node_modules/go-variants-engine/node_modules/lodash/_baseAssign.js","ui/node_modules/go-variants-engine/node_modules/lodash/_baseAssignIn.js","ui/node_modules/go-variants-engine/node_modules/lodash/_baseAssignValue.js","ui/node_modules/go-variants-engine/node_modules/lodash/_baseClone.js","ui/node_modules/go-variants-engine/node_modules/lodash/_baseCreate.js","ui/node_modules/go-variants-engine/node_modules/lodash/_baseFindIndex.js","ui/node_modules/go-variants-engine/node_modules/lodash/_baseGet.js","ui/node_modules/go-variants-engine/node_modules/lodash/_baseGetAllKeys.js","ui/node_modules/go-variants-engine/node_modules/lodash/_baseGetTag.js","ui/node_modules/go-variants-engine/node_modules/lodash/_baseHasIn.js","ui/node_modules/go-variants-engine/node_modules/lodash/_baseIsArguments.js","ui/node_modules/go-variants-engine/node_modules/lodash/_baseIsEqual.js","ui/node_modules/go-variants-engine/node_modules/lodash/_baseIsEqualDeep.js","ui/node_modules/go-variants-engine/node_modules/lodash/_baseIsMatch.js","ui/node_modules/go-variants-engine/node_modules/lodash/_baseIsNative.js","ui/node_modules/go-variants-engine/node_modules/lodash/_baseIsTypedArray.js","ui/node_modules/go-variants-engine/node_modules/lodash/_baseIteratee.js","ui/node_modules/go-variants-engine/node_modules/lodash/_baseKeys.js","ui/node_modules/go-variants-engine/node_modules/lodash/_baseKeysIn.js","ui/node_modules/go-variants-engine/node_modules/lodash/_baseMatches.js","ui/node_modules/go-variants-engine/node_modules/lodash/_baseMatchesProperty.js","ui/node_modules/go-variants-engine/node_modules/lodash/_baseProperty.js","ui/node_modules/go-variants-engine/node_modules/lodash/_basePropertyDeep.js","ui/node_modules/go-variants-engine/node_modules/lodash/_baseTimes.js","ui/node_modules/go-variants-engine/node_modules/lodash/_baseToString.js","ui/node_modules/go-variants-engine/node_modules/lodash/_baseUnary.js","ui/node_modules/go-variants-engine/node_modules/lodash/_cacheHas.js","ui/node_modules/go-variants-engine/node_modules/lodash/_castPath.js","ui/node_modules/go-variants-engine/node_modules/lodash/_cloneArrayBuffer.js","ui/node_modules/go-variants-engine/node_modules/lodash/_cloneBuffer.js","ui/node_modules/go-variants-engine/node_modules/lodash/_cloneDataView.js","ui/node_modules/go-variants-engine/node_modules/lodash/_cloneMap.js","ui/node_modules/go-variants-engine/node_modules/lodash/_cloneRegExp.js","ui/node_modules/go-variants-engine/node_modules/lodash/_cloneSet.js","ui/node_modules/go-variants-engine/node_modules/lodash/_cloneSymbol.js","ui/node_modules/go-variants-engine/node_modules/lodash/_cloneTypedArray.js","ui/node_modules/go-variants-engine/node_modules/lodash/_copyArray.js","ui/node_modules/go-variants-engine/node_modules/lodash/_copyObject.js","ui/node_modules/go-variants-engine/node_modules/lodash/_copySymbols.js","ui/node_modules/go-variants-engine/node_modules/lodash/_copySymbolsIn.js","ui/node_modules/go-variants-engine/node_modules/lodash/_coreJsData.js","ui/node_modules/go-variants-engine/node_modules/lodash/_defineProperty.js","ui/node_modules/go-variants-engine/node_modules/lodash/_equalArrays.js","ui/node_modules/go-variants-engine/node_modules/lodash/_equalByTag.js","ui/node_modules/go-variants-engine/node_modules/lodash/_equalObjects.js","ui/node_modules/go-variants-engine/node_modules/lodash/_freeGlobal.js","ui/node_modules/go-variants-engine/node_modules/lodash/_getAllKeys.js","ui/node_modules/go-variants-engine/node_modules/lodash/_getAllKeysIn.js","ui/node_modules/go-variants-engine/node_modules/lodash/_getMapData.js","ui/node_modules/go-variants-engine/node_modules/lodash/_getMatchData.js","ui/node_modules/go-variants-engine/node_modules/lodash/_getNative.js","ui/node_modules/go-variants-engine/node_modules/lodash/_getPrototype.js","ui/node_modules/go-variants-engine/node_modules/lodash/_getRawTag.js","ui/node_modules/go-variants-engine/node_modules/lodash/_getSymbols.js","ui/node_modules/go-variants-engine/node_modules/lodash/_getSymbolsIn.js","ui/node_modules/go-variants-engine/node_modules/lodash/_getTag.js","ui/node_modules/go-variants-engine/node_modules/lodash/_getValue.js","ui/node_modules/go-variants-engine/node_modules/lodash/_hasPath.js","ui/node_modules/go-variants-engine/node_modules/lodash/_hashClear.js","ui/node_modules/go-variants-engine/node_modules/lodash/_hashDelete.js","ui/node_modules/go-variants-engine/node_modules/lodash/_hashGet.js","ui/node_modules/go-variants-engine/node_modules/lodash/_hashHas.js","ui/node_modules/go-variants-engine/node_modules/lodash/_hashSet.js","ui/node_modules/go-variants-engine/node_modules/lodash/_initCloneArray.js","ui/node_modules/go-variants-engine/node_modules/lodash/_initCloneByTag.js","ui/node_modules/go-variants-engine/node_modules/lodash/_initCloneObject.js","ui/node_modules/go-variants-engine/node_modules/lodash/_isIndex.js","ui/node_modules/go-variants-engine/node_modules/lodash/_isKey.js","ui/node_modules/go-variants-engine/node_modules/lodash/_isKeyable.js","ui/node_modules/go-variants-engine/node_modules/lodash/_isMasked.js","ui/node_modules/go-variants-engine/node_modules/lodash/_isPrototype.js","ui/node_modules/go-variants-engine/node_modules/lodash/_isStrictComparable.js","ui/node_modules/go-variants-engine/node_modules/lodash/_listCacheClear.js","ui/node_modules/go-variants-engine/node_modules/lodash/_listCacheDelete.js","ui/node_modules/go-variants-engine/node_modules/lodash/_listCacheGet.js","ui/node_modules/go-variants-engine/node_modules/lodash/_listCacheHas.js","ui/node_modules/go-variants-engine/node_modules/lodash/_listCacheSet.js","ui/node_modules/go-variants-engine/node_modules/lodash/_mapCacheClear.js","ui/node_modules/go-variants-engine/node_modules/lodash/_mapCacheDelete.js","ui/node_modules/go-variants-engine/node_modules/lodash/_mapCacheGet.js","ui/node_modules/go-variants-engine/node_modules/lodash/_mapCacheHas.js","ui/node_modules/go-variants-engine/node_modules/lodash/_mapCacheSet.js","ui/node_modules/go-variants-engine/node_modules/lodash/_mapToArray.js","ui/node_modules/go-variants-engine/node_modules/lodash/_matchesStrictComparable.js","ui/node_modules/go-variants-engine/node_modules/lodash/_memoizeCapped.js","ui/node_modules/go-variants-engine/node_modules/lodash/_nativeCreate.js","ui/node_modules/go-variants-engine/node_modules/lodash/_nativeKeys.js","ui/node_modules/go-variants-engine/node_modules/lodash/_nativeKeysIn.js","ui/node_modules/go-variants-engine/node_modules/lodash/_nodeUtil.js","ui/node_modules/go-variants-engine/node_modules/lodash/_objectToString.js","ui/node_modules/go-variants-engine/node_modules/lodash/_overArg.js","ui/node_modules/go-variants-engine/node_modules/lodash/_root.js","ui/node_modules/go-variants-engine/node_modules/lodash/_setCacheAdd.js","ui/node_modules/go-variants-engine/node_modules/lodash/_setCacheHas.js","ui/node_modules/go-variants-engine/node_modules/lodash/_setToArray.js","ui/node_modules/go-variants-engine/node_modules/lodash/_stackClear.js","ui/node_modules/go-variants-engine/node_modules/lodash/_stackDelete.js","ui/node_modules/go-variants-engine/node_modules/lodash/_stackGet.js","ui/node_modules/go-variants-engine/node_modules/lodash/_stackHas.js","ui/node_modules/go-variants-engine/node_modules/lodash/_stackSet.js","ui/node_modules/go-variants-engine/node_modules/lodash/_stringToPath.js","ui/node_modules/go-variants-engine/node_modules/lodash/_toKey.js","ui/node_modules/go-variants-engine/node_modules/lodash/_toSource.js","ui/node_modules/go-variants-engine/node_modules/lodash/clone.js","ui/node_modules/go-variants-engine/node_modules/lodash/eq.js","ui/node_modules/go-variants-engine/node_modules/lodash/findIndex.js","ui/node_modules/go-variants-engine/node_modules/lodash/get.js","ui/node_modules/go-variants-engine/node_modules/lodash/hasIn.js","ui/node_modules/go-variants-engine/node_modules/lodash/identity.js","ui/node_modules/go-variants-engine/node_modules/lodash/isArguments.js","ui/node_modules/go-variants-engine/node_modules/lodash/isArray.js","ui/node_modules/go-variants-engine/node_modules/lodash/isArrayLike.js","ui/node_modules/go-variants-engine/node_modules/lodash/isBuffer.js","ui/node_modules/go-variants-engine/node_modules/lodash/isFunction.js","ui/node_modules/go-variants-engine/node_modules/lodash/isLength.js","ui/node_modules/go-variants-engine/node_modules/lodash/isObject.js","ui/node_modules/go-variants-engine/node_modules/lodash/isObjectLike.js","ui/node_modules/go-variants-engine/node_modules/lodash/isSymbol.js","ui/node_modules/go-variants-engine/node_modules/lodash/isTypedArray.js","ui/node_modules/go-variants-engine/node_modules/lodash/keys.js","ui/node_modules/go-variants-engine/node_modules/lodash/keysIn.js","ui/node_modules/go-variants-engine/node_modules/lodash/memoize.js","ui/node_modules/go-variants-engine/node_modules/lodash/property.js","ui/node_modules/go-variants-engine/node_modules/lodash/stubArray.js","ui/node_modules/go-variants-engine/node_modules/lodash/stubFalse.js","ui/node_modules/go-variants-engine/node_modules/lodash/toFinite.js","ui/node_modules/go-variants-engine/node_modules/lodash/toInteger.js","ui/node_modules/go-variants-engine/node_modules/lodash/toNumber.js","ui/node_modules/go-variants-engine/node_modules/lodash/toString.js","ui/node_modules/go-variants-engine/src/engine.js","ui/node_modules/lodash/_arrayIncludes.js","ui/node_modules/lodash/_arrayIncludesWith.js","ui/node_modules/lodash/_baseFlatten.js","ui/node_modules/lodash/_baseIndexOf.js","ui/node_modules/lodash/_baseIsNaN.js","ui/node_modules/lodash/_baseUniq.js","ui/node_modules/lodash/_createSet.js","ui/node_modules/lodash/_freeGlobal.js","ui/node_modules/lodash/_isFlattenable.js","ui/node_modules/lodash/_strictIndexOf.js","ui/node_modules/lodash/flatten.js","ui/node_modules/lodash/noop.js","ui/node_modules/lodash/uniqBy.js","ui/node_modules/smartgame/index.js","ui/node_modules/smartgamer/index.js","ui/src/transformer.js","ui/ui/editor.js","ui/ui/editor.jsx"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACzFA;AACA;AACA;AACA;AACA;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACnVC;;;AAGD;;;;;;;;;;;;;;;;;;;;;;IAsBG;;;;;;;AAQH,SAAS,WAAT,CAAqB,OAArB,EACE;AACD;;AACA,KACC,WAAW,QAAQ,gBAAR,CADZ;AAAA,KAEG,UAAU,QAAQ,eAAR,CAFb;AAAA,KAGG,MAAM,QAAQ,kBAAR,CAHT;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","file":"editor.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView');\n\nmodule.exports = DataView;\n","var hashClear = require('./_hashClear'),\n    hashDelete = require('./_hashDelete'),\n    hashGet = require('./_hashGet'),\n    hashHas = require('./_hashHas'),\n    hashSet = require('./_hashSet');\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\nmodule.exports = Hash;\n","var listCacheClear = require('./_listCacheClear'),\n    listCacheDelete = require('./_listCacheDelete'),\n    listCacheGet = require('./_listCacheGet'),\n    listCacheHas = require('./_listCacheHas'),\n    listCacheSet = require('./_listCacheSet');\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\nmodule.exports = ListCache;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map');\n\nmodule.exports = Map;\n","var mapCacheClear = require('./_mapCacheClear'),\n    mapCacheDelete = require('./_mapCacheDelete'),\n    mapCacheGet = require('./_mapCacheGet'),\n    mapCacheHas = require('./_mapCacheHas'),\n    mapCacheSet = require('./_mapCacheSet');\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\nmodule.exports = MapCache;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Promise = getNative(root, 'Promise');\n\nmodule.exports = Promise;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Set = getNative(root, 'Set');\n\nmodule.exports = Set;\n","var MapCache = require('./_MapCache'),\n    setCacheAdd = require('./_setCacheAdd'),\n    setCacheHas = require('./_setCacheHas');\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values == null ? 0 : values.length;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\nmodule.exports = SetCache;\n","var ListCache = require('./_ListCache'),\n    stackClear = require('./_stackClear'),\n    stackDelete = require('./_stackDelete'),\n    stackGet = require('./_stackGet'),\n    stackHas = require('./_stackHas'),\n    stackSet = require('./_stackSet');\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\nmodule.exports = Stack;\n","var root = require('./_root');\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n","var root = require('./_root');\n\n/** Built-in value references. */\nvar Uint8Array = root.Uint8Array;\n\nmodule.exports = Uint8Array;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar WeakMap = getNative(root, 'WeakMap');\n\nmodule.exports = WeakMap;\n","/**\n * Adds the key-value `pair` to `map`.\n *\n * @private\n * @param {Object} map The map to modify.\n * @param {Array} pair The key-value pair to add.\n * @returns {Object} Returns `map`.\n */\nfunction addMapEntry(map, pair) {\n  // Don't return `map.set` because it's not chainable in IE 11.\n  map.set(pair[0], pair[1]);\n  return map;\n}\n\nmodule.exports = addMapEntry;\n","/**\n * Adds `value` to `set`.\n *\n * @private\n * @param {Object} set The set to modify.\n * @param {*} value The value to add.\n * @returns {Object} Returns `set`.\n */\nfunction addSetEntry(set, value) {\n  // Don't return `set.add` because it's not chainable in IE 11.\n  set.add(value);\n  return set;\n}\n\nmodule.exports = addSetEntry;\n","/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\nmodule.exports = arrayEach;\n","/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayFilter;\n","var baseTimes = require('./_baseTimes'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isIndex = require('./_isIndex'),\n    isTypedArray = require('./isTypedArray');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayLikeKeys;\n","/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\nmodule.exports = arrayMap;\n","/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\nmodule.exports = arrayPush;\n","/**\n * A specialized version of `_.reduce` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @param {boolean} [initAccum] Specify using the first element of `array` as\n *  the initial value.\n * @returns {*} Returns the accumulated value.\n */\nfunction arrayReduce(array, iteratee, accumulator, initAccum) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  if (initAccum && length) {\n    accumulator = array[++index];\n  }\n  while (++index < length) {\n    accumulator = iteratee(accumulator, array[index], index, array);\n  }\n  return accumulator;\n}\n\nmodule.exports = arrayReduce;\n","/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nmodule.exports = arraySome;\n","var baseAssignValue = require('./_baseAssignValue'),\n    eq = require('./eq');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    baseAssignValue(object, key, value);\n  }\n}\n\nmodule.exports = assignValue;\n","var eq = require('./eq');\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = assocIndexOf;\n","var copyObject = require('./_copyObject'),\n    keys = require('./keys');\n\n/**\n * The base implementation of `_.assign` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssign(object, source) {\n  return object && copyObject(source, keys(source), object);\n}\n\nmodule.exports = baseAssign;\n","var copyObject = require('./_copyObject'),\n    keysIn = require('./keysIn');\n\n/**\n * The base implementation of `_.assignIn` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssignIn(object, source) {\n  return object && copyObject(source, keysIn(source), object);\n}\n\nmodule.exports = baseAssignIn;\n","var defineProperty = require('./_defineProperty');\n\n/**\n * The base implementation of `assignValue` and `assignMergeValue` without\n * value checks.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction baseAssignValue(object, key, value) {\n  if (key == '__proto__' && defineProperty) {\n    defineProperty(object, key, {\n      'configurable': true,\n      'enumerable': true,\n      'value': value,\n      'writable': true\n    });\n  } else {\n    object[key] = value;\n  }\n}\n\nmodule.exports = baseAssignValue;\n","var Stack = require('./_Stack'),\n    arrayEach = require('./_arrayEach'),\n    assignValue = require('./_assignValue'),\n    baseAssign = require('./_baseAssign'),\n    baseAssignIn = require('./_baseAssignIn'),\n    cloneBuffer = require('./_cloneBuffer'),\n    copyArray = require('./_copyArray'),\n    copySymbols = require('./_copySymbols'),\n    copySymbolsIn = require('./_copySymbolsIn'),\n    getAllKeys = require('./_getAllKeys'),\n    getAllKeysIn = require('./_getAllKeysIn'),\n    getTag = require('./_getTag'),\n    initCloneArray = require('./_initCloneArray'),\n    initCloneByTag = require('./_initCloneByTag'),\n    initCloneObject = require('./_initCloneObject'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isObject = require('./isObject'),\n    keys = require('./keys');\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_DEEP_FLAG = 1,\n    CLONE_FLAT_FLAG = 2,\n    CLONE_SYMBOLS_FLAG = 4;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values supported by `_.clone`. */\nvar cloneableTags = {};\ncloneableTags[argsTag] = cloneableTags[arrayTag] =\ncloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\ncloneableTags[boolTag] = cloneableTags[dateTag] =\ncloneableTags[float32Tag] = cloneableTags[float64Tag] =\ncloneableTags[int8Tag] = cloneableTags[int16Tag] =\ncloneableTags[int32Tag] = cloneableTags[mapTag] =\ncloneableTags[numberTag] = cloneableTags[objectTag] =\ncloneableTags[regexpTag] = cloneableTags[setTag] =\ncloneableTags[stringTag] = cloneableTags[symbolTag] =\ncloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\ncloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\ncloneableTags[errorTag] = cloneableTags[funcTag] =\ncloneableTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n * traversed objects.\n *\n * @private\n * @param {*} value The value to clone.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Deep clone\n *  2 - Flatten inherited properties\n *  4 - Clone symbols\n * @param {Function} [customizer] The function to customize cloning.\n * @param {string} [key] The key of `value`.\n * @param {Object} [object] The parent object of `value`.\n * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n * @returns {*} Returns the cloned value.\n */\nfunction baseClone(value, bitmask, customizer, key, object, stack) {\n  var result,\n      isDeep = bitmask & CLONE_DEEP_FLAG,\n      isFlat = bitmask & CLONE_FLAT_FLAG,\n      isFull = bitmask & CLONE_SYMBOLS_FLAG;\n\n  if (customizer) {\n    result = object ? customizer(value, key, object, stack) : customizer(value);\n  }\n  if (result !== undefined) {\n    return result;\n  }\n  if (!isObject(value)) {\n    return value;\n  }\n  var isArr = isArray(value);\n  if (isArr) {\n    result = initCloneArray(value);\n    if (!isDeep) {\n      return copyArray(value, result);\n    }\n  } else {\n    var tag = getTag(value),\n        isFunc = tag == funcTag || tag == genTag;\n\n    if (isBuffer(value)) {\n      return cloneBuffer(value, isDeep);\n    }\n    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n      result = (isFlat || isFunc) ? {} : initCloneObject(value);\n      if (!isDeep) {\n        return isFlat\n          ? copySymbolsIn(value, baseAssignIn(result, value))\n          : copySymbols(value, baseAssign(result, value));\n      }\n    } else {\n      if (!cloneableTags[tag]) {\n        return object ? value : {};\n      }\n      result = initCloneByTag(value, tag, baseClone, isDeep);\n    }\n  }\n  // Check for circular references and return its corresponding clone.\n  stack || (stack = new Stack);\n  var stacked = stack.get(value);\n  if (stacked) {\n    return stacked;\n  }\n  stack.set(value, result);\n\n  var keysFunc = isFull\n    ? (isFlat ? getAllKeysIn : getAllKeys)\n    : (isFlat ? keysIn : keys);\n\n  var props = isArr ? undefined : keysFunc(value);\n  arrayEach(props || value, function(subValue, key) {\n    if (props) {\n      key = subValue;\n      subValue = value[key];\n    }\n    // Recursively populate clone (susceptible to call stack limits).\n    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));\n  });\n  return result;\n}\n\nmodule.exports = baseClone;\n","var isObject = require('./isObject');\n\n/** Built-in value references. */\nvar objectCreate = Object.create;\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} proto The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nvar baseCreate = (function() {\n  function object() {}\n  return function(proto) {\n    if (!isObject(proto)) {\n      return {};\n    }\n    if (objectCreate) {\n      return objectCreate(proto);\n    }\n    object.prototype = proto;\n    var result = new object;\n    object.prototype = undefined;\n    return result;\n  };\n}());\n\nmodule.exports = baseCreate;\n","/**\n * The base implementation of `_.findIndex` and `_.findLastIndex` without\n * support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} predicate The function invoked per iteration.\n * @param {number} fromIndex The index to search from.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseFindIndex(array, predicate, fromIndex, fromRight) {\n  var length = array.length,\n      index = fromIndex + (fromRight ? 1 : -1);\n\n  while ((fromRight ? index-- : ++index < length)) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = baseFindIndex;\n","var castPath = require('./_castPath'),\n    toKey = require('./_toKey');\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = castPath(path, object);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\nmodule.exports = baseGet;\n","var arrayPush = require('./_arrayPush'),\n    isArray = require('./isArray');\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\nmodule.exports = baseGetAllKeys;\n","var Symbol = require('./_Symbol'),\n    getRawTag = require('./_getRawTag'),\n    objectToString = require('./_objectToString');\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n","/**\n * The base implementation of `_.hasIn` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHasIn(object, key) {\n  return object != null && key in Object(object);\n}\n\nmodule.exports = baseHasIn;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]';\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\nmodule.exports = baseIsArguments;\n","var baseIsEqualDeep = require('./_baseIsEqualDeep'),\n    isObjectLike = require('./isObjectLike');\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n}\n\nmodule.exports = baseIsEqual;\n","var Stack = require('./_Stack'),\n    equalArrays = require('./_equalArrays'),\n    equalByTag = require('./_equalByTag'),\n    equalObjects = require('./_equalObjects'),\n    getTag = require('./_getTag'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isTypedArray = require('./isTypedArray');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = objIsArr ? arrayTag : getTag(object),\n      othTag = othIsArr ? arrayTag : getTag(other);\n\n  objTag = objTag == argsTag ? objectTag : objTag;\n  othTag = othTag == argsTag ? objectTag : othTag;\n\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && isBuffer(object)) {\n    if (!isBuffer(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\n\nmodule.exports = baseIsEqualDeep;\n","var Stack = require('./_Stack'),\n    baseIsEqual = require('./_baseIsEqual');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * The base implementation of `_.isMatch` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Object} source The object of property values to match.\n * @param {Array} matchData The property names, values, and compare flags to match.\n * @param {Function} [customizer] The function to customize comparisons.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */\nfunction baseIsMatch(object, source, matchData, customizer) {\n  var index = matchData.length,\n      length = index,\n      noCustomizer = !customizer;\n\n  if (object == null) {\n    return !length;\n  }\n  object = Object(object);\n  while (index--) {\n    var data = matchData[index];\n    if ((noCustomizer && data[2])\n          ? data[1] !== object[data[0]]\n          : !(data[0] in object)\n        ) {\n      return false;\n    }\n  }\n  while (++index < length) {\n    data = matchData[index];\n    var key = data[0],\n        objValue = object[key],\n        srcValue = data[1];\n\n    if (noCustomizer && data[2]) {\n      if (objValue === undefined && !(key in object)) {\n        return false;\n      }\n    } else {\n      var stack = new Stack;\n      if (customizer) {\n        var result = customizer(objValue, srcValue, key, object, source, stack);\n      }\n      if (!(result === undefined\n            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\n            : result\n          )) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nmodule.exports = baseIsMatch;\n","var isFunction = require('./isFunction'),\n    isMasked = require('./_isMasked'),\n    isObject = require('./isObject'),\n    toSource = require('./_toSource');\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\nmodule.exports = baseIsNative;\n","var baseGetTag = require('./_baseGetTag'),\n    isLength = require('./isLength'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\nmodule.exports = baseIsTypedArray;\n","var baseMatches = require('./_baseMatches'),\n    baseMatchesProperty = require('./_baseMatchesProperty'),\n    identity = require('./identity'),\n    isArray = require('./isArray'),\n    property = require('./property');\n\n/**\n * The base implementation of `_.iteratee`.\n *\n * @private\n * @param {*} [value=_.identity] The value to convert to an iteratee.\n * @returns {Function} Returns the iteratee.\n */\nfunction baseIteratee(value) {\n  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n  if (typeof value == 'function') {\n    return value;\n  }\n  if (value == null) {\n    return identity;\n  }\n  if (typeof value == 'object') {\n    return isArray(value)\n      ? baseMatchesProperty(value[0], value[1])\n      : baseMatches(value);\n  }\n  return property(value);\n}\n\nmodule.exports = baseIteratee;\n","var isPrototype = require('./_isPrototype'),\n    nativeKeys = require('./_nativeKeys');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseKeys;\n","var isObject = require('./isObject'),\n    isPrototype = require('./_isPrototype'),\n    nativeKeysIn = require('./_nativeKeysIn');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeysIn(object) {\n  if (!isObject(object)) {\n    return nativeKeysIn(object);\n  }\n  var isProto = isPrototype(object),\n      result = [];\n\n  for (var key in object) {\n    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseKeysIn;\n","var baseIsMatch = require('./_baseIsMatch'),\n    getMatchData = require('./_getMatchData'),\n    matchesStrictComparable = require('./_matchesStrictComparable');\n\n/**\n * The base implementation of `_.matches` which doesn't clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatches(source) {\n  var matchData = getMatchData(source);\n  if (matchData.length == 1 && matchData[0][2]) {\n    return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n  }\n  return function(object) {\n    return object === source || baseIsMatch(object, source, matchData);\n  };\n}\n\nmodule.exports = baseMatches;\n","var baseIsEqual = require('./_baseIsEqual'),\n    get = require('./get'),\n    hasIn = require('./hasIn'),\n    isKey = require('./_isKey'),\n    isStrictComparable = require('./_isStrictComparable'),\n    matchesStrictComparable = require('./_matchesStrictComparable'),\n    toKey = require('./_toKey');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n *\n * @private\n * @param {string} path The path of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatchesProperty(path, srcValue) {\n  if (isKey(path) && isStrictComparable(srcValue)) {\n    return matchesStrictComparable(toKey(path), srcValue);\n  }\n  return function(object) {\n    var objValue = get(object, path);\n    return (objValue === undefined && objValue === srcValue)\n      ? hasIn(object, path)\n      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n  };\n}\n\nmodule.exports = baseMatchesProperty;\n","/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\nmodule.exports = baseProperty;\n","var baseGet = require('./_baseGet');\n\n/**\n * A specialized version of `baseProperty` which supports deep paths.\n *\n * @private\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyDeep(path) {\n  return function(object) {\n    return baseGet(object, path);\n  };\n}\n\nmodule.exports = basePropertyDeep;\n","/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\nmodule.exports = baseTimes;\n","var Symbol = require('./_Symbol'),\n    arrayMap = require('./_arrayMap'),\n    isArray = require('./isArray'),\n    isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = baseToString;\n","/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\nmodule.exports = baseUnary;\n","/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\nmodule.exports = cacheHas;\n","var isArray = require('./isArray'),\n    isKey = require('./_isKey'),\n    stringToPath = require('./_stringToPath'),\n    toString = require('./toString');\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value, object) {\n  if (isArray(value)) {\n    return value;\n  }\n  return isKey(value, object) ? [value] : stringToPath(toString(value));\n}\n\nmodule.exports = castPath;\n","var Uint8Array = require('./_Uint8Array');\n\n/**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */\nfunction cloneArrayBuffer(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n  return result;\n}\n\nmodule.exports = cloneArrayBuffer;\n","var root = require('./_root');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;\n\n/**\n * Creates a clone of  `buffer`.\n *\n * @private\n * @param {Buffer} buffer The buffer to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Buffer} Returns the cloned buffer.\n */\nfunction cloneBuffer(buffer, isDeep) {\n  if (isDeep) {\n    return buffer.slice();\n  }\n  var length = buffer.length,\n      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n\n  buffer.copy(result);\n  return result;\n}\n\nmodule.exports = cloneBuffer;\n","var cloneArrayBuffer = require('./_cloneArrayBuffer');\n\n/**\n * Creates a clone of `dataView`.\n *\n * @private\n * @param {Object} dataView The data view to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned data view.\n */\nfunction cloneDataView(dataView, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n}\n\nmodule.exports = cloneDataView;\n","var addMapEntry = require('./_addMapEntry'),\n    arrayReduce = require('./_arrayReduce'),\n    mapToArray = require('./_mapToArray');\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_DEEP_FLAG = 1;\n\n/**\n * Creates a clone of `map`.\n *\n * @private\n * @param {Object} map The map to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned map.\n */\nfunction cloneMap(map, isDeep, cloneFunc) {\n  var array = isDeep ? cloneFunc(mapToArray(map), CLONE_DEEP_FLAG) : mapToArray(map);\n  return arrayReduce(array, addMapEntry, new map.constructor);\n}\n\nmodule.exports = cloneMap;\n","/** Used to match `RegExp` flags from their coerced string values. */\nvar reFlags = /\\w*$/;\n\n/**\n * Creates a clone of `regexp`.\n *\n * @private\n * @param {Object} regexp The regexp to clone.\n * @returns {Object} Returns the cloned regexp.\n */\nfunction cloneRegExp(regexp) {\n  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n  result.lastIndex = regexp.lastIndex;\n  return result;\n}\n\nmodule.exports = cloneRegExp;\n","var addSetEntry = require('./_addSetEntry'),\n    arrayReduce = require('./_arrayReduce'),\n    setToArray = require('./_setToArray');\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_DEEP_FLAG = 1;\n\n/**\n * Creates a clone of `set`.\n *\n * @private\n * @param {Object} set The set to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned set.\n */\nfunction cloneSet(set, isDeep, cloneFunc) {\n  var array = isDeep ? cloneFunc(setToArray(set), CLONE_DEEP_FLAG) : setToArray(set);\n  return arrayReduce(array, addSetEntry, new set.constructor);\n}\n\nmodule.exports = cloneSet;\n","var Symbol = require('./_Symbol');\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * Creates a clone of the `symbol` object.\n *\n * @private\n * @param {Object} symbol The symbol object to clone.\n * @returns {Object} Returns the cloned symbol object.\n */\nfunction cloneSymbol(symbol) {\n  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n}\n\nmodule.exports = cloneSymbol;\n","var cloneArrayBuffer = require('./_cloneArrayBuffer');\n\n/**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */\nfunction cloneTypedArray(typedArray, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\n\nmodule.exports = cloneTypedArray;\n","/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\nmodule.exports = copyArray;\n","var assignValue = require('./_assignValue'),\n    baseAssignValue = require('./_baseAssignValue');\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n  var isNew = !object;\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    if (newValue === undefined) {\n      newValue = source[key];\n    }\n    if (isNew) {\n      baseAssignValue(object, key, newValue);\n    } else {\n      assignValue(object, key, newValue);\n    }\n  }\n  return object;\n}\n\nmodule.exports = copyObject;\n","var copyObject = require('./_copyObject'),\n    getSymbols = require('./_getSymbols');\n\n/**\n * Copies own symbols of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbols(source, object) {\n  return copyObject(source, getSymbols(source), object);\n}\n\nmodule.exports = copySymbols;\n","var copyObject = require('./_copyObject'),\n    getSymbolsIn = require('./_getSymbolsIn');\n\n/**\n * Copies own and inherited symbols of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbolsIn(source, object) {\n  return copyObject(source, getSymbolsIn(source), object);\n}\n\nmodule.exports = copySymbolsIn;\n","var root = require('./_root');\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\nmodule.exports = coreJsData;\n","var getNative = require('./_getNative');\n\nvar defineProperty = (function() {\n  try {\n    var func = getNative(Object, 'defineProperty');\n    func({}, '', {});\n    return func;\n  } catch (e) {}\n}());\n\nmodule.exports = defineProperty;\n","var SetCache = require('./_SetCache'),\n    arraySome = require('./_arraySome'),\n    cacheHas = require('./_cacheHas');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!cacheHas(seen, othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, bitmask, customizer, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\nmodule.exports = equalArrays;\n","var Symbol = require('./_Symbol'),\n    Uint8Array = require('./_Uint8Array'),\n    eq = require('./eq'),\n    equalArrays = require('./_equalArrays'),\n    mapToArray = require('./_mapToArray'),\n    setToArray = require('./_setToArray');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]';\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\nmodule.exports = equalByTag;\n","var getAllKeys = require('./_getAllKeys');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1;\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\nmodule.exports = equalObjects;\n","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n","var baseGetAllKeys = require('./_baseGetAllKeys'),\n    getSymbols = require('./_getSymbols'),\n    keys = require('./keys');\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\nmodule.exports = getAllKeys;\n","var baseGetAllKeys = require('./_baseGetAllKeys'),\n    getSymbolsIn = require('./_getSymbolsIn'),\n    keysIn = require('./keysIn');\n\n/**\n * Creates an array of own and inherited enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeysIn(object) {\n  return baseGetAllKeys(object, keysIn, getSymbolsIn);\n}\n\nmodule.exports = getAllKeysIn;\n","var isKeyable = require('./_isKeyable');\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\nmodule.exports = getMapData;\n","var isStrictComparable = require('./_isStrictComparable'),\n    keys = require('./keys');\n\n/**\n * Gets the property names, values, and compare flags of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the match data of `object`.\n */\nfunction getMatchData(object) {\n  var result = keys(object),\n      length = result.length;\n\n  while (length--) {\n    var key = result[length],\n        value = object[key];\n\n    result[length] = [key, value, isStrictComparable(value)];\n  }\n  return result;\n}\n\nmodule.exports = getMatchData;\n","var baseIsNative = require('./_baseIsNative'),\n    getValue = require('./_getValue');\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\nmodule.exports = getNative;\n","var overArg = require('./_overArg');\n\n/** Built-in value references. */\nvar getPrototype = overArg(Object.getPrototypeOf, Object);\n\nmodule.exports = getPrototype;\n","var Symbol = require('./_Symbol');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n","var arrayFilter = require('./_arrayFilter'),\n    stubArray = require('./stubArray');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\nmodule.exports = getSymbols;\n","var arrayPush = require('./_arrayPush'),\n    getPrototype = require('./_getPrototype'),\n    getSymbols = require('./_getSymbols'),\n    stubArray = require('./stubArray');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\n\n/**\n * Creates an array of the own and inherited enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {\n  var result = [];\n  while (object) {\n    arrayPush(result, getSymbols(object));\n    object = getPrototype(object);\n  }\n  return result;\n};\n\nmodule.exports = getSymbolsIn;\n","var DataView = require('./_DataView'),\n    Map = require('./_Map'),\n    Promise = require('./_Promise'),\n    Set = require('./_Set'),\n    WeakMap = require('./_WeakMap'),\n    baseGetTag = require('./_baseGetTag'),\n    toSource = require('./_toSource');\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    setTag = '[object Set]',\n    weakMapTag = '[object WeakMap]';\n\nvar dataViewTag = '[object DataView]';\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\nmodule.exports = getTag;\n","/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\nmodule.exports = getValue;\n","var castPath = require('./_castPath'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isIndex = require('./_isIndex'),\n    isLength = require('./isLength'),\n    toKey = require('./_toKey');\n\n/**\n * Checks if `path` exists on `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @param {Function} hasFunc The function to check properties.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n */\nfunction hasPath(object, path, hasFunc) {\n  path = castPath(path, object);\n\n  var index = -1,\n      length = path.length,\n      result = false;\n\n  while (++index < length) {\n    var key = toKey(path[index]);\n    if (!(result = object != null && hasFunc(object, key))) {\n      break;\n    }\n    object = object[key];\n  }\n  if (result || ++index != length) {\n    return result;\n  }\n  length = object == null ? 0 : object.length;\n  return !!length && isLength(length) && isIndex(key, length) &&\n    (isArray(object) || isArguments(object));\n}\n\nmodule.exports = hasPath;\n","var nativeCreate = require('./_nativeCreate');\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\nmodule.exports = hashClear;\n","/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = hashDelete;\n","var nativeCreate = require('./_nativeCreate');\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\nmodule.exports = hashGet;\n","var nativeCreate = require('./_nativeCreate');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\nmodule.exports = hashHas;\n","var nativeCreate = require('./_nativeCreate');\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\nmodule.exports = hashSet;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Initializes an array clone.\n *\n * @private\n * @param {Array} array The array to clone.\n * @returns {Array} Returns the initialized clone.\n */\nfunction initCloneArray(array) {\n  var length = array.length,\n      result = array.constructor(length);\n\n  // Add properties assigned by `RegExp#exec`.\n  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n    result.index = array.index;\n    result.input = array.input;\n  }\n  return result;\n}\n\nmodule.exports = initCloneArray;\n","var cloneArrayBuffer = require('./_cloneArrayBuffer'),\n    cloneDataView = require('./_cloneDataView'),\n    cloneMap = require('./_cloneMap'),\n    cloneRegExp = require('./_cloneRegExp'),\n    cloneSet = require('./_cloneSet'),\n    cloneSymbol = require('./_cloneSymbol'),\n    cloneTypedArray = require('./_cloneTypedArray');\n\n/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Initializes an object clone based on its `toStringTag`.\n *\n * **Note:** This function only supports cloning values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to clone.\n * @param {string} tag The `toStringTag` of the object to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneByTag(object, tag, cloneFunc, isDeep) {\n  var Ctor = object.constructor;\n  switch (tag) {\n    case arrayBufferTag:\n      return cloneArrayBuffer(object);\n\n    case boolTag:\n    case dateTag:\n      return new Ctor(+object);\n\n    case dataViewTag:\n      return cloneDataView(object, isDeep);\n\n    case float32Tag: case float64Tag:\n    case int8Tag: case int16Tag: case int32Tag:\n    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n      return cloneTypedArray(object, isDeep);\n\n    case mapTag:\n      return cloneMap(object, isDeep, cloneFunc);\n\n    case numberTag:\n    case stringTag:\n      return new Ctor(object);\n\n    case regexpTag:\n      return cloneRegExp(object);\n\n    case setTag:\n      return cloneSet(object, isDeep, cloneFunc);\n\n    case symbolTag:\n      return cloneSymbol(object);\n  }\n}\n\nmodule.exports = initCloneByTag;\n","var baseCreate = require('./_baseCreate'),\n    getPrototype = require('./_getPrototype'),\n    isPrototype = require('./_isPrototype');\n\n/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneObject(object) {\n  return (typeof object.constructor == 'function' && !isPrototype(object))\n    ? baseCreate(getPrototype(object))\n    : {};\n}\n\nmodule.exports = initCloneObject;\n","/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\nmodule.exports = isIndex;\n","var isArray = require('./isArray'),\n    isSymbol = require('./isSymbol');\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/;\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\nmodule.exports = isKey;\n","/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\nmodule.exports = isKeyable;\n","var coreJsData = require('./_coreJsData');\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\nmodule.exports = isMasked;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\nmodule.exports = isPrototype;\n","var isObject = require('./isObject');\n\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */\nfunction isStrictComparable(value) {\n  return value === value && !isObject(value);\n}\n\nmodule.exports = isStrictComparable;\n","/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\nmodule.exports = listCacheClear;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\nmodule.exports = listCacheDelete;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\nmodule.exports = listCacheGet;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\nmodule.exports = listCacheHas;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\nmodule.exports = listCacheSet;\n","var Hash = require('./_Hash'),\n    ListCache = require('./_ListCache'),\n    Map = require('./_Map');\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\nmodule.exports = mapCacheClear;\n","var getMapData = require('./_getMapData');\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = mapCacheDelete;\n","var getMapData = require('./_getMapData');\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\nmodule.exports = mapCacheGet;\n","var getMapData = require('./_getMapData');\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\nmodule.exports = mapCacheHas;\n","var getMapData = require('./_getMapData');\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\nmodule.exports = mapCacheSet;\n","/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\nmodule.exports = mapToArray;\n","/**\n * A specialized version of `matchesProperty` for source values suitable\n * for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction matchesStrictComparable(key, srcValue) {\n  return function(object) {\n    if (object == null) {\n      return false;\n    }\n    return object[key] === srcValue &&\n      (srcValue !== undefined || (key in Object(object)));\n  };\n}\n\nmodule.exports = matchesStrictComparable;\n","var memoize = require('./memoize');\n\n/** Used as the maximum memoize cache size. */\nvar MAX_MEMOIZE_SIZE = 500;\n\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */\nfunction memoizeCapped(func) {\n  var result = memoize(func, function(key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n\n  var cache = result.cache;\n  return result;\n}\n\nmodule.exports = memoizeCapped;\n","var getNative = require('./_getNative');\n\n/* Built-in method references that are verified to be native. */\nvar nativeCreate = getNative(Object, 'create');\n\nmodule.exports = nativeCreate;\n","var overArg = require('./_overArg');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = overArg(Object.keys, Object);\n\nmodule.exports = nativeKeys;\n","/**\n * This function is like\n * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * except that it includes inherited enumerable properties.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction nativeKeysIn(object) {\n  var result = [];\n  if (object != null) {\n    for (var key in Object(object)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = nativeKeysIn;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\nmodule.exports = nodeUtil;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n","/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\nmodule.exports = overArg;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n","/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\nmodule.exports = setCacheAdd;\n","/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\nmodule.exports = setCacheHas;\n","/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\nmodule.exports = setToArray;\n","var ListCache = require('./_ListCache');\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\nmodule.exports = stackClear;\n","/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\nmodule.exports = stackDelete;\n","/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\nmodule.exports = stackGet;\n","/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\nmodule.exports = stackHas;\n","var ListCache = require('./_ListCache'),\n    Map = require('./_Map'),\n    MapCache = require('./_MapCache');\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\nmodule.exports = stackSet;\n","var memoizeCapped = require('./_memoizeCapped');\n\n/** Used to match property names within property paths. */\nvar reLeadingDot = /^\\./,\n    rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoizeCapped(function(string) {\n  var result = [];\n  if (reLeadingDot.test(string)) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, string) {\n    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\nmodule.exports = stringToPath;\n","var isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = toKey;\n","/** Used for built-in method references. */\nvar funcProto = Function.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\nmodule.exports = toSource;\n","var baseClone = require('./_baseClone');\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_SYMBOLS_FLAG = 4;\n\n/**\n * Creates a shallow clone of `value`.\n *\n * **Note:** This method is loosely based on the\n * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)\n * and supports cloning arrays, array buffers, booleans, date objects, maps,\n * numbers, `Object` objects, regexes, sets, strings, symbols, and typed\n * arrays. The own enumerable properties of `arguments` objects are cloned\n * as plain objects. An empty object is returned for uncloneable values such\n * as error objects, functions, DOM nodes, and WeakMaps.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to clone.\n * @returns {*} Returns the cloned value.\n * @see _.cloneDeep\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var shallow = _.clone(objects);\n * console.log(shallow[0] === objects[0]);\n * // => true\n */\nfunction clone(value) {\n  return baseClone(value, CLONE_SYMBOLS_FLAG);\n}\n\nmodule.exports = clone;\n","/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\nmodule.exports = eq;\n","var baseFindIndex = require('./_baseFindIndex'),\n    baseIteratee = require('./_baseIteratee'),\n    toInteger = require('./toInteger');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * This method is like `_.find` except that it returns the index of the first\n * element `predicate` returns truthy for instead of the element itself.\n *\n * @static\n * @memberOf _\n * @since 1.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {number} Returns the index of the found element, else `-1`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'active': false },\n *   { 'user': 'fred',    'active': false },\n *   { 'user': 'pebbles', 'active': true }\n * ];\n *\n * _.findIndex(users, function(o) { return o.user == 'barney'; });\n * // => 0\n *\n * // The `_.matches` iteratee shorthand.\n * _.findIndex(users, { 'user': 'fred', 'active': false });\n * // => 1\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.findIndex(users, ['active', false]);\n * // => 0\n *\n * // The `_.property` iteratee shorthand.\n * _.findIndex(users, 'active');\n * // => 2\n */\nfunction findIndex(array, predicate, fromIndex) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return -1;\n  }\n  var index = fromIndex == null ? 0 : toInteger(fromIndex);\n  if (index < 0) {\n    index = nativeMax(length + index, 0);\n  }\n  return baseFindIndex(array, baseIteratee(predicate, 3), index);\n}\n\nmodule.exports = findIndex;\n","var baseGet = require('./_baseGet');\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\nmodule.exports = get;\n","var baseHasIn = require('./_baseHasIn'),\n    hasPath = require('./_hasPath');\n\n/**\n * Checks if `path` is a direct or inherited property of `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.hasIn(object, 'a');\n * // => true\n *\n * _.hasIn(object, 'a.b');\n * // => true\n *\n * _.hasIn(object, ['a', 'b']);\n * // => true\n *\n * _.hasIn(object, 'b');\n * // => false\n */\nfunction hasIn(object, path) {\n  return object != null && hasPath(object, path, baseHasIn);\n}\n\nmodule.exports = hasIn;\n","/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\nmodule.exports = identity;\n","var baseIsArguments = require('./_baseIsArguments'),\n    isObjectLike = require('./isObjectLike');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\nmodule.exports = isArguments;\n","/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nmodule.exports = isArray;\n","var isFunction = require('./isFunction'),\n    isLength = require('./isLength');\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\nmodule.exports = isArrayLike;\n","var root = require('./_root'),\n    stubFalse = require('./stubFalse');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\nmodule.exports = isBuffer;\n","var baseGetTag = require('./_baseGetTag'),\n    isObject = require('./isObject');\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nmodule.exports = isFunction;\n","/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\nmodule.exports = isLength;\n","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nmodule.exports = isSymbol;\n","var baseIsTypedArray = require('./_baseIsTypedArray'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\nmodule.exports = isTypedArray;\n","var arrayLikeKeys = require('./_arrayLikeKeys'),\n    baseKeys = require('./_baseKeys'),\n    isArrayLike = require('./isArrayLike');\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\nmodule.exports = keys;\n","var arrayLikeKeys = require('./_arrayLikeKeys'),\n    baseKeysIn = require('./_baseKeysIn'),\n    isArrayLike = require('./isArrayLike');\n\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\nfunction keysIn(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n}\n\nmodule.exports = keysIn;\n","var MapCache = require('./_MapCache');\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = MapCache;\n\nmodule.exports = memoize;\n","var baseProperty = require('./_baseProperty'),\n    basePropertyDeep = require('./_basePropertyDeep'),\n    isKey = require('./_isKey'),\n    toKey = require('./_toKey');\n\n/**\n * Creates a function that returns the value at `path` of a given object.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n * @example\n *\n * var objects = [\n *   { 'a': { 'b': 2 } },\n *   { 'a': { 'b': 1 } }\n * ];\n *\n * _.map(objects, _.property('a.b'));\n * // => [2, 1]\n *\n * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n * // => [1, 2]\n */\nfunction property(path) {\n  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n}\n\nmodule.exports = property;\n","/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\nmodule.exports = stubArray;\n","/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = stubFalse;\n","var toNumber = require('./toNumber');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_INTEGER = 1.7976931348623157e+308;\n\n/**\n * Converts `value` to a finite number.\n *\n * @static\n * @memberOf _\n * @since 4.12.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted number.\n * @example\n *\n * _.toFinite(3.2);\n * // => 3.2\n *\n * _.toFinite(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toFinite(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toFinite('3.2');\n * // => 3.2\n */\nfunction toFinite(value) {\n  if (!value) {\n    return value === 0 ? value : 0;\n  }\n  value = toNumber(value);\n  if (value === INFINITY || value === -INFINITY) {\n    var sign = (value < 0 ? -1 : 1);\n    return sign * MAX_INTEGER;\n  }\n  return value === value ? value : 0;\n}\n\nmodule.exports = toFinite;\n","var toFinite = require('./toFinite');\n\n/**\n * Converts `value` to an integer.\n *\n * **Note:** This method is loosely based on\n * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted integer.\n * @example\n *\n * _.toInteger(3.2);\n * // => 3\n *\n * _.toInteger(Number.MIN_VALUE);\n * // => 0\n *\n * _.toInteger(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toInteger('3.2');\n * // => 3\n */\nfunction toInteger(value) {\n  var result = toFinite(value),\n      remainder = result % 1;\n\n  return result === result ? (remainder ? result - remainder : result) : 0;\n}\n\nmodule.exports = toInteger;\n","var isObject = require('./isObject'),\n    isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = toNumber;\n","var baseToString = require('./_baseToString');\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\nmodule.exports = toString;\n","/* globals module: false, require: false */\r\nmodule.exports = function (options) {\r\n\t'use strict';\r\n\tlet _fi = require('lodash/findIndex')\r\n\t\t// , _iseq = require('lodash/isEqual')\r\n\t\t, _clone = require('lodash/clone')\r\n\t\t//utilities\r\n\t\t// const\r\n\r\n\t\t, _iseq = (x, y) => {\r\n\r\n\t\t\tif (!Array.isArray(x) || !Array.isArray(y)) {\r\n\t\t\t\treturn x == y// eslint-disable-line eqeqeq\r\n\t\t\t\t// return x === y\r\n\t\t\t}\r\n\t\t\tif (x.length !== y.length) return false\r\n\t\t\tfor (let index = 0; index < x.length; index++) {\r\n\t\t\t\tif (!_iseq(x[index], y[index])) {\r\n\t\t\t\t\treturn false\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn true\r\n\r\n\t\t}\r\n\t\t, myIndexOf = (a, b) => {\r\n\t\t\treturn _fi(a, function (x) { return _iseq(x, b) });\r\n\t\t}\r\n\t// this version, without the _fi dependency, doesn't work!todo\r\n\t//  , myIndexOf = (array, item) => {\r\n\t// \t\tfor (let index = 0; index < array.length; index++) {\r\n\t// \t\t\tif (_iseq(array[index], item)) {\r\n\t// \t\t\t\treturn index;\r\n\r\n\t// \t\t\t}\r\n\t// \t\t\treturn -1;\r\n\t// \t\t}\r\n\r\n\t// \t}\r\n\r\n\t// \t, _clone = require('lodash/clone')\r\n\r\n\r\n\toptions = options || {}\r\n\t// boardMode = options.boardMode || 't'/*t:toroid; c:classic */\r\n\t// , boardDimensions = options.boardDimensions || [11, 11]/*move later*/\r\n\t// , rules = options.rules || {\r\n\t// suicide: true,\r\n\t// superko: false\r\n\t// }\r\n\tlet $ = {}\r\n\t////problem with the object spread operator and the build so using Object.assign instead.\r\n\t// $.rules = {\r\n\t// \t\tsuicide: true,\r\n\t// \t\t// superko: false /*todo: enforce when true?*/,\r\n\t// \t\tkomi: 7.5,\r\n\t// \t\t... options.rules\r\n\t// \t}\r\n\t$.rules = Object.assign({}, {\r\n\t\tsuicide: true,\r\n\t\t// superko: false /*todo: enforce when true?*/,\r\n\t\tkomi: 7.5,\r\n\t}, options.rules)\r\n\r\n\t// $.moves = options.moves || []\r\n\t$.options = options\r\n\toptions.boardDimensions = options.boardDimensions || [11, 11]\r\n\toptions.boardMode = options.boardMode || 't'/*t:toroid; c:classic */\r\n\t$.board = {}\r\n\t$.board.blackStones = options.blackStones || []\r\n\t$.board.whiteStones = options.whiteStones || []\r\n\r\n\t$.board.nextPlayer = options.nextPlayer || \"b\"\r\n\t$.board.captured = options.captured || [0, 0]\r\n\r\n\t$.exportData = function () {\r\n\t\treturn {\r\n\t\t\tblackStones: $.board.blackStones.map(_clone),\r\n\r\n\t\t\twhiteStones: $.board.whiteStones.map(_clone),\r\n\t\t\tcaptured: _clone($.board.captured),\r\n\t\t\tnextPlayer: $.board.nextPlayer\r\n\t\t}\r\n\t}\r\n\r\n\t$.loadData = function (data) {\r\n\t\t$.board.blackStones = data.blackStones\r\n\t\t$.board.whiteStones = data.whiteStones\r\n\t\t$.board.captured = data.captured\r\n\t\t$.board.nextPlayer = data.nextPlayer\r\n\t}\r\n\r\n\t//toroid\r\n\tif (options.boardMode === 't') $.board.getNeighbours =\r\n\t\tfunction (point) {\r\n\t\t\tlet result = []\r\n\t\t\tfor (let i = 0; i < 4; i++) {\r\n\t\t\t\tlet newPoint\r\n\t\t\t\tswitch (i) {\r\n\t\t\t\t\tcase 0:\r\n\t\t\t\t\t\tnewPoint = [point[0] + 1, point[1]]\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\tcase 1:\r\n\t\t\t\t\t\tnewPoint = [point[0] - 1, point[1]]\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\tcase 2:\r\n\t\t\t\t\t\tnewPoint = [point[0], point[1] + 1]\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\tcase 3:\r\n\t\t\t\t\t\tnewPoint = [point[0], point[1] - 1]\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t}\r\n\t\t\t\tresult.push([(newPoint[0] + options.boardDimensions[0]) % options.boardDimensions[0], (newPoint[1] + options.boardDimensions[1]) % options.boardDimensions[1]])\r\n\t\t\t}\r\n\t\t\treturn result\r\n\t\t}\r\n\tif (options.boardMode === 'c') $.board.getNeighbours =\r\n\t\tfunction (point) {\r\n\t\t\tlet result = []\r\n\t\t\tfor (let i = 0; i < 4; i++) {\r\n\t\t\t\tlet newPoint\r\n\t\t\t\tswitch (i) {\r\n\t\t\t\t\tcase 0:\r\n\t\t\t\t\t\tnewPoint = [point[0] + 1, point[1]]\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\tcase 1:\r\n\t\t\t\t\t\tnewPoint = [point[0] - 1, point[1]]\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\tcase 2:\r\n\t\t\t\t\t\tnewPoint = [point[0], point[1] + 1]\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\tcase 3:\r\n\t\t\t\t\t\tnewPoint = [point[0], point[1] - 1]\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t}\r\n\t\t\t\tif (newPoint[0] >= 0 && newPoint[0] < options.boardDimensions[0]\r\n\t\t\t\t\t&& newPoint[1] >= 0 && newPoint[1] < options.boardDimensions[1]\r\n\t\t\t\t)\r\n\t\t\t\t\tresult.push(newPoint)\r\n\t\t\t}\r\n\t\t\treturn result\r\n\t\t}\r\n\t//todo: klein, projective plane, \r\n\r\n\t$.board.isEmpty = function (point) {\r\n\t\treturn myIndexOf($.board.blackStones, point) < 0\r\n\t\t\t&& myIndexOf($.board.whiteStones, point) < 0\r\n\t}\r\n\t$.board.getColour = function (point) {\r\n\t\tif (myIndexOf($.board.blackStones, point) >= 0) return 'b'\r\n\t\tif (myIndexOf($.board.whiteStones, point) >= 0) return 'w'\r\n\t\treturn 'e'\r\n\t}\r\n\t/**\r\n\t * Determines if a point is part of a chain with a liberty; if there are no liberties then it returns the chain of stones of the same colour that are connected to `startPoint`. Also used for counting to return connected components of same colour (black, white or empty).\r\n\t * @param {*} startPoint \r\n\t * @param {string|null} chainColour indicates the colour of the starting point.\r\n\t * @param {*} [stopColour='e'] stop working if the chain meets this colour\r\n\t * @param {Function} [getColour=$.board.getColour] Function used to determine the colour of a point.\r\n\t * @returns {bool|array} Returns `true` if the the component meets `stopColour`, and an array containing connected component of points linked to `startPoint` otherwise. \r\n\t */\t\r\n\tfunction chainHasLiberty (startPoint, chainColour, stopColour, getColour) {\r\n\t\tif (stopColour === undefined)\r\n\t\t\tstopColour = 'e'//by default, stop getting the chain when there is a liberty.\r\n\t\tif (getColour === undefined)\r\n\t\t\tgetColour = $.board.getColour//by default, use the usual board colour function\r\n\r\n\t\tif (chainColour === null)\r\n\t\t\tchainColour = getColour(startPoint)\r\n\t\tlet\r\n\t\t\tchain = [startPoint]\r\n\t\t\t, toExplore = []\r\n\t\t\t, point = startPoint //assumed to be of colour chainColour\r\n\r\n\t\twhile (point !== undefined) {\r\n\r\n\t\t\tlet neighbours = $.board.getNeighbours(point)\r\n\t\t\tfor (let i = 0; i < neighbours.length; i++) {\r\n\t\t\t\tlet newPoint = neighbours[i],\r\n\t\t\t\t\tnewColour = getColour(newPoint)\r\n\t\t\t\tif (newColour === stopColour) return true;\r\n\t\t\t\tif (newColour === chainColour) {\r\n\t\t\t\t\tif (myIndexOf(chain, newPoint) < 0) {\r\n\t\t\t\t\t\tchain.push(newPoint)\r\n\t\t\t\t\t\t// if (myIndexOf(toExplore, newPoint) < 0)\r\n\t\t\t\t\t\ttoExplore.push(newPoint)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tpoint = toExplore.pop()\r\n\t\t}\r\n\r\n\t\treturn chain;\r\n\t}\r\n\r\n\t$.board.chainHasLiberty = chainHasLiberty \r\n\r\n\t$.board.score = function (deadStones) {\r\n\t\t/*\r\n\t\tgo through the whole board \r\n\t\t*/\r\n\t\tif (deadStones === undefined) {\r\n\t\t\tdeadStones = []\r\n\t\t}\r\n\r\n\t\tlet result = {\r\n\t\t\tblackEmpty: []\r\n\t\t\t, whiteEmpty: []\r\n\t\t\t, dame: []\r\n\t\t\t, blackAlive: []\r\n\t\t\t, whiteAlive: []\r\n\t\t\t, blackDead: []\r\n\t\t\t, whiteDead: []\r\n\t\t\t, totalBlackCaptured: $.board.captured[0] //nb B stones removed by W during the game\r\n\t\t\t, totalWhiteCaptured: $.board.captured[1] //nb W stones removed by B during the game\r\n\t\t\t//todo:could replace by an class. data stored in a big array of pairs [point, status]\r\n\t\t}\r\n\r\n\t\tfor (let index = 0; index < deadStones.length; index++) {\r\n\t\t\tconst deadStone = deadStones[index];\r\n\t\t\tlet deadColour = $.board.getColour(deadStone)\r\n\t\t\tif (deadColour === 'e') throw new Error('invalid marked dead stone')\r\n\t\t\tlet\r\n\t\t\t\tdeadToFill = deadColour === 'b' ? result.blackDead : result.whiteDead\r\n\t\t\t\t, emptyToFill = deadColour === 'b' ? result.whiteEmpty : result.blackEmpty\r\n\t\t\t\t, aliveToFill = deadColour === 'b' ? result.whiteAlive : result.blackAlive\r\n\t\t\t\t, processPoint = (point, colour) => {\r\n\t\t\t\t\tif (colour === deadColour && myIndexOf(deadToFill, point) < 0) {\r\n\t\t\t\t\t\tdeadToFill.push(point)\r\n\t\t\t\t\t\temptyToFill.push(point)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ((colour === deadColour || colour === 'e') && myIndexOf(emptyToFill, point) < 0) {\r\n\t\t\t\t\t\temptyToFill.push(point)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (colour !== deadColour && colour !== 'e' && myIndexOf(aliveToFill, point) < 0) {\r\n\t\t\t\t\t\taliveToFill.push(point)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t, getColourForDeadComponent = (point) => {\r\n\t\t\t\t\tlet colour = $.board.getColour(point)\r\n\t\t\t\t\tprocessPoint(point, colour)\r\n\t\t\t\t\treturn colour === deadColour ? 'e' : colour\r\n\t\t\t\t}\r\n\t\t\tprocessPoint(deadStone, deadColour)\r\n\t\t\t$.board.chainHasLiberty(deadStone, 'e', '', getColourForDeadComponent)\r\n\t\t}\r\n\r\n\t\tfor (let i = 0,exitLoop = false; i < options.boardDimensions[0]; i++) {\r\n\t\t\tif (exitLoop) {\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t\tfor (let j = 0; j < options.boardDimensions[1]; j++) {\r\n\t\t\t\tif (result.blackEmpty.length\r\n\t\t\t\t\t+ result.whiteEmpty.length\r\n\t\t\t\t\t+ result.dame.length\r\n\t\t\t\t\t+ result.blackAlive.length\r\n\t\t\t\t\t+ result.whiteAlive.length\r\n\t\t\t\t\t// + result.blackDead.length\r\n\t\t\t\t\t// + result.whiteDead.length\r\n\t\t\t\t\t=== options.boardDimensions[0] * options.boardDimensions[1]\r\n\t\t\t\t) {\r\n\t\t\t\t\texitLoop = true\r\n\t\t\t\t\tbreak\r\n\t\t\t\t}\r\n\t\t\t\tconst point = [i, j], colour = $.board.getColour(point)\r\n\r\n\t\t\t\tif (colour === 'b'\r\n\t\t\t\t) {\r\n\t\t\t\t\tif (myIndexOf(result.blackAlive, point) < 0\r\n\t\t\t\t\t\t&& myIndexOf(result.blackDead, point) < 0) {\r\n\t\t\t\t\t\tresult.blackAlive.push(point)\r\n\t\t\t\t\t} else continue\r\n\t\t\t\t}\r\n\t\t\t\tif (colour === 'w') {\r\n\t\t\t\t\tif (myIndexOf(result.whiteAlive, point) < 0\r\n\t\t\t\t\t\t&& myIndexOf(result.whiteDead, point) < 0) {\r\n\t\t\t\t\t\tresult.whiteAlive.push(point)\r\n\t\t\t\t\t} else continue\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (colour === 'e') {\r\n\t\t\t\t\tif (myIndexOf(result.blackEmpty, point) >= 0\r\n\t\t\t\t\t\t|| myIndexOf(result.whiteEmpty, point) >= 0\r\n\t\t\t\t\t\t|| myIndexOf(result.dame, point) >= 0) {\r\n\t\t\t\t\t\tcontinue\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlet\r\n\t\t\t\t\t\tmeetsBlack = false\r\n\t\t\t\t\t\t, meetsWhite = false\r\n\t\t\t\t\t\t, isBlackTerritory = false\r\n\t\t\t\t\t\t, isWhiteTerritory = false\r\n\t\t\t\t\t\t, getColourForScoring = (point) => {\r\n\r\n\t\t\t\t\t\t\tlet colour = $.board.getColour(point)\r\n\t\t\t\t\t\t\tswitch (colour) {\r\n\t\t\t\t\t\t\t\tcase 'b':\r\n\t\t\t\t\t\t\t\t\tif (myIndexOf(result.blackDead, point) >= 0) {\r\n\t\t\t\t\t\t\t\t\t\tcolour = 'e'\r\n\t\t\t\t\t\t\t\t\t\tisWhiteTerritory = true\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\t\tmeetsBlack = true\r\n\t\t\t\t\t\t\t\t\t\tif (myIndexOf(result.blackAlive, point) < 0) {\r\n\t\t\t\t\t\t\t\t\t\t\tresult.blackAlive.push(point)\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\tcase 'w':\r\n\t\t\t\t\t\t\t\t\tif (myIndexOf(result.whiteDead, point) >= 0) {\r\n\t\t\t\t\t\t\t\t\t\tcolour = 'e'\r\n\t\t\t\t\t\t\t\t\t\tisBlackTerritory = true\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\t\tmeetsWhite = true\r\n\t\t\t\t\t\t\t\t\t\tif (myIndexOf(result.whiteAlive, point) < 0) {\r\n\t\t\t\t\t\t\t\t\t\t\tresult.whiteAlive.push(point)\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\tdefault://nothing needed for 'e'\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn colour\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\tlet emptyComponent = $.board.chainHasLiberty(point, 'e', '', getColourForScoring)\r\n\t\t\t\t\tif (!meetsBlack && !meetsWhite) {\r\n\t\t\t\t\t\tthrow new Error('counting an empty board!')\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (isBlackTerritory && isWhiteTerritory) {\r\n\t\t\t\t\t\tthrow new Error('too many stones marked as dead')\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//could store the different empty components: V2 \r\n\t\t\t\t\tif (meetsBlack && meetsWhite) {\r\n\t\t\t\t\t\tresult.dame = result.dame.concat(emptyComponent)\r\n\t\t\t\t\t\tcontinue\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (meetsBlack) {\r\n\t\t\t\t\t\tresult.blackEmpty = result.blackEmpty.concat(emptyComponent)\r\n\t\t\t\t\t\tcontinue\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (meetsWhite) {\r\n\t\t\t\t\t\tresult.whiteEmpty = result.whiteEmpty.concat(emptyComponent)\r\n\t\t\t\t\t\tcontinue\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t//totals\r\n\t\tresult.totalBlackDead = result.blackDead.length\r\n\t\tresult.totalWhiteDead = result.whiteDead.length\r\n\t\tresult.totalBlackTerritory = result.blackEmpty.length\r\n\t\tresult.totalWhiteTerritory = result.whiteEmpty.length\r\n\r\n\r\n\t\t//todo: implement other rulesets. For now, just do territory + prisoners (Japanese style counting)\r\n\t\tresult.blackScore =\r\n\t\t\tresult.totalWhiteDead\r\n\t\t\t+ result.totalWhiteCaptured\r\n\t\t\t+ result.totalBlackTerritory\r\n\t\tresult.whiteScore =\r\n\t\t\tresult.totalBlackDead\r\n\t\t\t+ result.totalBlackCaptured\r\n\t\t\t+ result.totalWhiteTerritory\r\n\t\t\t+ $.rules.komi\r\n\t\tlet r = result.blackScore - result.whiteScore\r\n\t\tif (r === 0) result.RE = '0'\r\n\t\telse if (r > 0) result.RE = 'B+' + r\r\n\t\telse result.RE = 'W+' + (-r)\r\n\t\treturn result\r\n\t}\r\n\r\n\t$.board.empty = function () {\r\n\t\t$.board.whiteStones = []\r\n\t\t$.board.blackStones = []\r\n\t\t$.board.captured = [0, 0]\r\n\r\n\t}\r\n\r\n\t$.removeChain = function (chain, colour) {\r\n\t\tlet toRemoveFrom = colour === 'w' ? $.board.whiteStones : $.board.blackStones\r\n\t\tfor (let j = 0; j < chain.length; j++) {\r\n\t\t\tlet index = myIndexOf(toRemoveFrom, chain[j])\r\n\t\t\ttoRemoveFrom.splice(index, 1)\r\n\t\t\tif (colour === 'w') $.board.captured[1] = $.board.captured[1] + 1\r\n\t\t\telse $.board.captured[0] = $.board.captured[0] + 1\r\n\t\t}\r\n\t}\r\n\t$.play = function (playerColour, point) {\r\n\r\n\r\n\r\n\t\t// let result = \"ok\"\r\n\t\tif (!$.board.isEmpty(point))\r\n\t\t\tthrow new Error('point is not empty')\r\n\t\t// console.log('point is not empty' + point)\r\n\r\n\t\tif (playerColour === 'b') $.board.blackStones.push(point)\r\n\t\telse $.board.whiteStones.push(point)\r\n\r\n\t\tlet neighbours = $.board.getNeighbours(point)\r\n\t\t\t, removed = []//chains removed\r\n\r\n\t\tfor (let i = 0; i < neighbours.length; i++) {\r\n\t\t\tlet neighbour = neighbours[i], colour = $.board.getColour(neighbour)\r\n\t\t\tif (colour === playerColour || colour === 'e') continue\r\n\t\t\tlet oppColour = $.getOppositeColour(playerColour),\r\n\t\t\t\tr = $.board.chainHasLiberty(neighbour, oppColour)\r\n\t\t\tif (r === true) continue\r\n\t\t\t////remove - no liberties\r\n\t\t\tremoved[removed.length] = r\r\n\r\n\t\t\t$.removeChain(r, oppColour)\r\n\r\n\t\t\t// let chainToRemove = r[1],\r\n\t\t\t// toRemoveFrom = playerColour === 'b' ? $.board.whiteStones : $.board.blackStones\r\n\t\t\t// for (let j = 0; j<chainToRemove.length; j++)\r\n\t\t\t// {\r\n\t\t\t// let index = myIndexOf(toRemoveFrom,chainToRemove[j])\r\n\t\t\t// toRemoveFrom.splice(index, 1)\r\n\t\t\t// if (playerColour === 'b') $.board.captured[1] = $.board.captured[1] + 1\r\n\t\t\t// else $.board.captured[0] = $.board.captured[0] + 1\r\n\t\t\t// }\r\n\t\t\t// removed = true\r\n\t\t}\r\n\t\tlet suicide = false\r\n\t\tif (removed.length === 0) {\r\n\t\t\tlet s = $.board.chainHasLiberty(point, playerColour)\r\n\t\t\tif (s !== true) {\r\n\t\t\t\tif ($.rules.suicide) {\r\n\t\t\t\t\t$.removeChain(s, playerColour)\r\n\t\t\t\t\tsuicide = s\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tthrow new Error('suicide')//isnt allowed\r\n\t\t\t\t\t//todo: remove point from whiteStones or blackStones\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\t\tstoring the situation in memory - would be useful when implementing going back a move, superko, \r\n\t\t\tnot needed for now\r\n\t\t*/\r\n\t\t//$.moves.push([playerColour,point,_.clone($.board.whiteStones),_.clone($.board.blackStones)])\r\n\t\t// $.moves.push([playerColour,point])\r\n\r\n\t\t// getNeighbours[i] = [getNeighbours[i], $.board.getColour[getNeighbours[i]]\r\n\t\t// //\r\n\r\n\r\n\t\treturn { removed, suicide }\r\n\t}\r\n\t$.getOppositeColour = function (colour) {\r\n\t\tswitch (colour) {\r\n\t\t\tcase 'b':\r\n\t\t\t\treturn 'w'\r\n\t\t\tcase 'w':\r\n\t\t\t\treturn 'b'\r\n\t\t}\r\n\t\treturn null\r\n\t}\r\n\treturn $\r\n\r\n}","var baseIndexOf = require('./_baseIndexOf');\n\n/**\n * A specialized version of `_.includes` for arrays without support for\n * specifying an index to search from.\n *\n * @private\n * @param {Array} [array] The array to inspect.\n * @param {*} target The value to search for.\n * @returns {boolean} Returns `true` if `target` is found, else `false`.\n */\nfunction arrayIncludes(array, value) {\n  var length = array == null ? 0 : array.length;\n  return !!length && baseIndexOf(array, value, 0) > -1;\n}\n\nmodule.exports = arrayIncludes;\n","/**\n * This function is like `arrayIncludes` except that it accepts a comparator.\n *\n * @private\n * @param {Array} [array] The array to inspect.\n * @param {*} target The value to search for.\n * @param {Function} comparator The comparator invoked per element.\n * @returns {boolean} Returns `true` if `target` is found, else `false`.\n */\nfunction arrayIncludesWith(array, value, comparator) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (comparator(value, array[index])) {\n      return true;\n    }\n  }\n  return false;\n}\n\nmodule.exports = arrayIncludesWith;\n","var arrayPush = require('./_arrayPush'),\n    isFlattenable = require('./_isFlattenable');\n\n/**\n * The base implementation of `_.flatten` with support for restricting flattening.\n *\n * @private\n * @param {Array} array The array to flatten.\n * @param {number} depth The maximum recursion depth.\n * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n * @param {Array} [result=[]] The initial result value.\n * @returns {Array} Returns the new flattened array.\n */\nfunction baseFlatten(array, depth, predicate, isStrict, result) {\n  var index = -1,\n      length = array.length;\n\n  predicate || (predicate = isFlattenable);\n  result || (result = []);\n\n  while (++index < length) {\n    var value = array[index];\n    if (depth > 0 && predicate(value)) {\n      if (depth > 1) {\n        // Recursively flatten arrays (susceptible to call stack limits).\n        baseFlatten(value, depth - 1, predicate, isStrict, result);\n      } else {\n        arrayPush(result, value);\n      }\n    } else if (!isStrict) {\n      result[result.length] = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseFlatten;\n","var baseFindIndex = require('./_baseFindIndex'),\n    baseIsNaN = require('./_baseIsNaN'),\n    strictIndexOf = require('./_strictIndexOf');\n\n/**\n * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseIndexOf(array, value, fromIndex) {\n  return value === value\n    ? strictIndexOf(array, value, fromIndex)\n    : baseFindIndex(array, baseIsNaN, fromIndex);\n}\n\nmodule.exports = baseIndexOf;\n","/**\n * The base implementation of `_.isNaN` without support for number objects.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n */\nfunction baseIsNaN(value) {\n  return value !== value;\n}\n\nmodule.exports = baseIsNaN;\n","var SetCache = require('./_SetCache'),\n    arrayIncludes = require('./_arrayIncludes'),\n    arrayIncludesWith = require('./_arrayIncludesWith'),\n    cacheHas = require('./_cacheHas'),\n    createSet = require('./_createSet'),\n    setToArray = require('./_setToArray');\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * The base implementation of `_.uniqBy` without support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} [iteratee] The iteratee invoked per element.\n * @param {Function} [comparator] The comparator invoked per element.\n * @returns {Array} Returns the new duplicate free array.\n */\nfunction baseUniq(array, iteratee, comparator) {\n  var index = -1,\n      includes = arrayIncludes,\n      length = array.length,\n      isCommon = true,\n      result = [],\n      seen = result;\n\n  if (comparator) {\n    isCommon = false;\n    includes = arrayIncludesWith;\n  }\n  else if (length >= LARGE_ARRAY_SIZE) {\n    var set = iteratee ? null : createSet(array);\n    if (set) {\n      return setToArray(set);\n    }\n    isCommon = false;\n    includes = cacheHas;\n    seen = new SetCache;\n  }\n  else {\n    seen = iteratee ? [] : result;\n  }\n  outer:\n  while (++index < length) {\n    var value = array[index],\n        computed = iteratee ? iteratee(value) : value;\n\n    value = (comparator || value !== 0) ? value : 0;\n    if (isCommon && computed === computed) {\n      var seenIndex = seen.length;\n      while (seenIndex--) {\n        if (seen[seenIndex] === computed) {\n          continue outer;\n        }\n      }\n      if (iteratee) {\n        seen.push(computed);\n      }\n      result.push(value);\n    }\n    else if (!includes(seen, computed, comparator)) {\n      if (seen !== result) {\n        seen.push(computed);\n      }\n      result.push(value);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseUniq;\n","var Set = require('./_Set'),\n    noop = require('./noop'),\n    setToArray = require('./_setToArray');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Creates a set object of `values`.\n *\n * @private\n * @param {Array} values The values to add to the set.\n * @returns {Object} Returns the new set.\n */\nvar createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {\n  return new Set(values);\n};\n\nmodule.exports = createSet;\n","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n","var Symbol = require('./_Symbol'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray');\n\n/** Built-in value references. */\nvar spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;\n\n/**\n * Checks if `value` is a flattenable `arguments` object or array.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n */\nfunction isFlattenable(value) {\n  return isArray(value) || isArguments(value) ||\n    !!(spreadableSymbol && value && value[spreadableSymbol]);\n}\n\nmodule.exports = isFlattenable;\n","/**\n * A specialized version of `_.indexOf` which performs strict equality\n * comparisons of values, i.e. `===`.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction strictIndexOf(array, value, fromIndex) {\n  var index = fromIndex - 1,\n      length = array.length;\n\n  while (++index < length) {\n    if (array[index] === value) {\n      return index;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = strictIndexOf;\n","var baseFlatten = require('./_baseFlatten');\n\n/**\n * Flattens `array` a single level deep.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to flatten.\n * @returns {Array} Returns the new flattened array.\n * @example\n *\n * _.flatten([1, [2, [3, [4]], 5]]);\n * // => [1, 2, [3, [4]], 5]\n */\nfunction flatten(array) {\n  var length = array == null ? 0 : array.length;\n  return length ? baseFlatten(array, 1) : [];\n}\n\nmodule.exports = flatten;\n","/**\n * This method returns `undefined`.\n *\n * @static\n * @memberOf _\n * @since 2.3.0\n * @category Util\n * @example\n *\n * _.times(2, _.noop);\n * // => [undefined, undefined]\n */\nfunction noop() {\n  // No operation performed.\n}\n\nmodule.exports = noop;\n","var baseIteratee = require('./_baseIteratee'),\n    baseUniq = require('./_baseUniq');\n\n/**\n * This method is like `_.uniq` except that it accepts `iteratee` which is\n * invoked for each element in `array` to generate the criterion by which\n * uniqueness is computed. The order of result values is determined by the\n * order they occur in the array. The iteratee is invoked with one argument:\n * (value).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n * @returns {Array} Returns the new duplicate free array.\n * @example\n *\n * _.uniqBy([2.1, 1.2, 2.3], Math.floor);\n * // => [2.1, 1.2]\n *\n * // The `_.property` iteratee shorthand.\n * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n * // => [{ 'x': 1 }, { 'x': 2 }]\n */\nfunction uniqBy(array, iteratee) {\n  return (array && array.length) ? baseUniq(array, baseIteratee(iteratee, 2)) : [];\n}\n\nmodule.exports = uniqBy;\n","/**\n * Convert SGF files to a JS object\n * @param {string} sgf A valid SGF file.\n * @see http://www.red-bean.com/sgf/sgf4.html\n * @return {object} The SGF file represented as a JS object\n */\nexports.parse = function (sgf) {\n\t'use strict';\n\n\tvar parse;\n\tvar parser;\n\tvar collection = {};\n\n\t// tracks the current sequence\n\tvar sequence;\n\n\t// tracks the current node\n\tvar node;\n\n\t// tracks the last PropIdent\n\tvar lastPropIdent;\n\n\t// A map of functions to parse the different components of an SGF file\n\tparser = {\n\n\t\tbeginSequence: function (sgf) {\n\t\t\tvar key = 'sequences';\n\n\t\t\t// Top-level sequences are gameTrees\n\t\t\tif (!sequence) {\n\t\t\t\tsequence = collection;\n\t\t\t\tkey = 'gameTrees';\n\t\t\t}\n\n\t\t\tif (sequence.gameTrees) {\n\t\t\t\tkey = 'gameTrees';\n\t\t\t}\n\n\t\t\tvar newSequence = {\n\t\t\t\tparent: sequence\n\t\t\t};\n\n\t\t\tsequence[key] = sequence[key] || [];\n\t\t\tsequence[key].push(newSequence);\n\t\t\tsequence = newSequence;\n\n\t\t\treturn sgf.substring(1);\n\t\t},\n\n\t\tendSequence: function (sgf) {\n\t\t\tif (sequence.parent) {\n\t\t\t\tsequence = sequence.parent;\n\t\t\t} else {\n\t\t\t\tsequence = null;\n\t\t\t}\n\t\t\treturn sgf.substring(1);\n\t\t},\n\n\t\tnode: function (sgf) {\n\t\t\tnode = {};\n\t\t\tsequence.nodes = sequence.nodes || [];\n\t\t\tsequence.nodes.push(node);\n\t\t\treturn sgf.substring(1);\n\t\t},\n\n\t\tproperty: function (sgf) {\n\t\t\tvar propValue;\n\n\t\t\t// Search for the first unescaped ]\n\t\t\tvar firstPropEnd = sgf.match(/([^\\\\\\]]|\\\\(.|\\n|\\r))*\\]/);\n\n\t\t\tif (!firstPropEnd.length) {\n\t\t\t\tthrow new Error('malformed sgf');\n\t\t\t}\n\n\t\t\tfirstPropEnd = firstPropEnd[0].length;\n\n\t\t\tvar property = sgf.substring(0, firstPropEnd);\n\t\t\tvar propValueBegin = property.indexOf('[');\n\t\t\tvar propIdent = property.substring(0, propValueBegin);\n\n\t\t\t// Point lists don't declare a PropIdent for each PropValue\n\t\t\t// Instead, they should use the last declared property\n\t\t\t// See: http://www.red-bean.com/sgf/sgf4.html#move/pos\n\t\t\tif (!propIdent) {\n\t\t\t\tpropIdent = lastPropIdent;\n\n\t\t\t\t// If this is the first property in a list of multiple\n\t\t\t\t// properties, we need to wrap the PropValue in an array\n\t\t\t\tif (!Array.isArray(node[propIdent])) {\n\t\t\t\t\tnode[propIdent] = [node[propIdent]];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlastPropIdent = propIdent;\n\n\t\t\tpropValue = property.substring(propValueBegin + 1, property.length - 1);\n\n\t\t\t// We have no problem parsing PropIdents of any length, but the spec\n\t\t\t// says they should be no longer than two characters.\n\t\t\t//\n\t\t\t// http://www.red-bean.com/sgf/sgf4.html#2.2\n\t\t\tif (propIdent.length > 2) {\n\t\t\t\t// TODO: What's the best way to issue a warning?\n\t\t\t\tconsole.warn(\n\t\t\t\t\t'SGF PropIdents should be no longer than two characters:', propIdent\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (Array.isArray(node[propIdent])) {\n\t\t\t\tnode[propIdent].push(propValue);\n\t\t\t} else {\n\t\t\t\tnode[propIdent] = propValue;\n\t\t\t}\n\n\t\t\treturn sgf.substring(firstPropEnd);\n\t\t},\n\n\t\t// Whitespace, tabs, or anything else we don't recognize\n\t\tunrecognized: function (sgf) {\n\n\t\t\t// March ahead to the next character\n\t\t\treturn sgf.substring(1);\n\t\t}\n\t};\n\n\t// Processes an SGF file character by character\n\tparse = function (sgf) {\n\t\twhile (sgf) {\n\t\t\tvar initial = sgf.substring(0, 1);\n\t\t\tvar type;\n\n\t\t\t// Use the initial (the first character in the remaining sgf file) to\n\t\t\t// decide which parser function to use\n\t\t\tif (initial === '(') {\n\t\t\t\ttype = 'beginSequence';\n\t\t\t} else if (initial === ')') {\n\t\t\t\ttype = 'endSequence';\n\t\t\t} else if (initial === ';') {\n\t\t\t\ttype = 'node';\n\t\t\t} else if (initial.search(/[A-Z\\[]/) !== -1) {\n\t\t\t\ttype = 'property';\n\t\t\t} else {\n\t\t\t\ttype = 'unrecognized';\n\t\t\t}\n\n\t\t\tsgf = parser[type](sgf);\n\t\t}\n\n\t\treturn collection;\n\t};\n\n\t// Begin parsing the SGF file\n\treturn parse(sgf);\n};\n\n/**\n * Generate an SGF file from a SmartGame Record JavaScript Object\n * @param {object} record A record object.\n * @return {string} The record as a string suitable for saving as an SGF file\n */\nexports.generate = function (record) {\n\t'use strict';\n\n\tfunction stringifySequences(sequences) {\n\t\tvar contents = '';\n\n\t\tsequences.forEach(function (sequence) {\n\t\t\tcontents += '(';\n\n\t\t\t// Parse all nodes in this sequence\n\t\t\tif (sequence.nodes) {\n\t\t\t\tsequence.nodes.forEach(function (node) {\n\t\t\t\t\tvar nodeString = ';';\n\t\t\t\t\tfor (var property in node) {\n\t\t\t\t\t\tif (node.hasOwnProperty(property)) {\n\t\t\t\t\t\t\tvar prop = node[property];\n\t\t\t\t\t\t\tif (Array.isArray(prop)) {\n\t\t\t\t\t\t\t\tprop = prop.join('][');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnodeString += property + '[' + prop + ']';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcontents += nodeString;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Call the function we're in recursively for any child sequences\n\t\t\tif (sequence.sequences) {\n\t\t\t\tcontents += stringifySequences(sequence.sequences);\n\t\t\t}\n\n\t\t\tcontents += ')';\n\t\t});\n\n\t\treturn contents;\n\t}\n\n\treturn stringifySequences(record.gameTrees);\n};\n\n","/**\n * Interact with smartgame objects.\n * @param {object} smartgame A JS Object representing a smartgame\n * @see http://www.red-bean.com/sgf/sgf4.html\n * @return {object} An object with methods for navigating and manipulating a\n * smartgame\n */\nmodule.exports = function (smartgame) {\n\t'use strict';\n\n\tvar sequence;\n\tvar node;\n\n\tvar Smartgamer = function () {\n\t\tthis.init();\n\t};\n\n\tSmartgamer.prototype = {\n\t\tinit: function () {\n\t\t\tif (smartgame) {\n\t\t\t\tthis.game = smartgame.gameTrees[0];\n\t\t\t\tthis.reset();\n\t\t\t}\n\t\t},\n\n\t\t// Load a smartgame to make it possible to load new games or add one after\n\t\t// initialization, if desired\n\t\tload: function (newSmartgame) {\n\t\t\tsmartgame = newSmartgame;\n\t\t\tthis.init();\n\t\t},\n\n\t\t// Having multiple games in a collection is not common, but it's part of\n\t\t// the spec\n\t\tgames: function () {\n\t\t\treturn smartgame.gameTrees;\n\t\t},\n\n\t\tselectGame: function (i) {\n\t\t\tif (i < smartgame.gameTrees.length) {\n\t\t\t\tthis.game = smartgame.gameTrees[i];\n\t\t\t\tthis.reset();\n\t\t\t} else {\n\t\t\t\tthrow new Error('the collection doesn\\'t contain that many games');\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\treset: function () {\n\t\t\tsequence = this.game;\n\t\t\tnode = sequence.nodes[0];\n\t\t\tthis.path = { m: 0 };\n\n\t\t\treturn this;\n\t\t},\n\n\t\tgetSmartgame: function () {\n\t\t\treturn smartgame;\n\t\t},\n\n\t\t/**\n\t\t * Return any variations available at the current move\n\t\t **/\n\t\tvariations: function () {\n\t\t\tif (sequence) {\n\t\t\t\tvar localNodes = sequence.nodes;\n\t\t\t\tvar localIndex = (localNodes) ? localNodes.indexOf(node) : null;\n\n\t\t\t\tif (localNodes) {\n\t\t\t\t\tif (localIndex === (localNodes.length - 1)) {\n\t\t\t\t\t\treturn sequence.sequences || [];\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn [];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Go to the next move\n\t\t **/\n\t\tnext: function (variation) {\n\t\t\tvariation = variation || 0;\n\n\t\t\tvar localNodes = sequence.nodes;\n\t\t\tvar localIndex = (localNodes) ? localNodes.indexOf(node) : null;\n\n\t\t\t// If there are no additional nodes in this sequence,\n\t\t\t// advance to the next one\n\t\t\tif (localIndex === null || localIndex >= (localNodes.length - 1)) {\n\t\t\t\tif (sequence.sequences) {\n\t\t\t\t\tif (sequence.sequences[variation]) {\n\t\t\t\t\t\tsequence = sequence.sequences[variation];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsequence = sequence.sequences[0];\n\t\t\t\t\t}\n\n\t\t\t\t\tnode = sequence.nodes[0];\n\n\t\t\t\t\t// Note the fork chosen for this variation in the path\n\t\t\t\t\tthis.path[this.path.m] = variation;\n\t\t\t\t\tthis.path.m += 1;\n\t\t\t\t} else {\n\t\t\t\t\t// End of sequence / game\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnode = localNodes[localIndex + 1];\n\t\t\t\tthis.path.m += 1;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\t/**\n\t\t * Go to the previous move\n\t\t **/\n\t\tprevious: function () {\n\t\t\tvar localNodes = sequence.nodes;\n\t\t\tvar localIndex = (localNodes) ? localNodes.indexOf(node) : null;\n\n\t\t\t// Delete any variation forks at this point\n\t\t\t// TODO: Make this configurable... we should keep this if we're\n\t\t\t// remembering chosen paths\n\t\t\tdelete this.path[this.path.m];\n\n\t\t\tif (!localIndex || localIndex === 0) {\n\t\t\t\tif (sequence.parent && !sequence.parent.gameTrees) {\n\t\t\t\t\tsequence = sequence.parent;\n\t\t\t\t\tif (sequence.nodes) {\n\t\t\t\t\t\tnode = sequence.nodes[sequence.nodes.length - 1];\n\t\t\t\t\t\tthis.path.m -= 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnode = null;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Already at the beginning\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnode = localNodes[localIndex - 1];\n\t\t\t\tthis.path.m -= 1;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\t// Go to the last move of the game\n\t\tlast: function () {\n\t\t\tvar totalMoves = this.totalMoves();\n\n\t\t\twhile(this.path.m < totalMoves) {\n\t\t\t\tthis.next();\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\t// Go to the first move of the game\n\t\tfirst: function () {\n\t\t\tthis.reset();\n\t\t\treturn this;\n\t\t},\n\n\t\t/**\n\t\t * Go to a particular move, specified as a\n\t\t * a) number\n\t\t * b) path string\n\t\t * c) path object\n\t\t **/\n\t\tgoTo: function (path) {\n\t\t\tif (typeof path === 'string') {\n\t\t\t\tpath = this.pathTransform(path, 'object');\n\t\t\t} else if (typeof path === 'number') {\n\t\t\t\tpath = { m: path };\n\t\t\t}\n\n\t\t\tthis.reset();\n\n\t\t\tvar n = node;\n\n\t\t\tfor (var i = 0; i < path.m && n; i += 1) {\n\t\t\t\t// Check for a variation in the path for the upcoming move\n\t\t\t\tvar variation = path[i + 1] || 0;\n\t\t\t\tn = this.next(variation);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\tgetGameInfo: function () {\n\t\t\treturn this.game.nodes[0];\n\t\t},\n\n\t\t// Provide the current node\n\t\tnode: function () {\n\t\t\treturn node;\n\t\t},\n\n\t\t// Get the total number of moves in a game\n\t\ttotalMoves: function () {\n\t\t\tvar localSequence = this.game;\n\t\t\tvar moves = 0;\n\t\t\twhile(localSequence) {\n\t\t\t\tmoves += localSequence.nodes.length;\n\n\t\t\t\tif (localSequence.sequences) {\n\t\t\t\t\tlocalSequence = localSequence.sequences[0];\n\t\t\t\t} else {\n\t\t\t\t\tlocalSequence = null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// TODO: Right now we're *assuming* that the root node doesn't have a\n\t\t\t// move in it, which is *recommended* but not required practice.\n\t\t\t// @see http://www.red-bean.com/sgf/sgf4.html\n\t\t\t// \"Note: it's bad style to have move properties in root nodes.\n\t\t\t// (it isn't forbidden though)\"\n\t\t\treturn moves - 1;\n\t\t},\n\n\t\t// Get or set a comment on the current node\n\t\t// @see http://www.red-bean.com/sgf/sgf4.html#text\n\t\tcomment: function (text) {\n\t\t\tif (typeof text === 'undefined') {\n\t\t\t\t// Unescape characters\n\t\t\t\tif (node.C) {\n\t\t\t\t\treturn node.C.replace(/\\\\([\\\\:\\]])/g, '$1');\n\t\t\t\t} else {\n\t\t\t\t\treturn '';\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Escape characters\n\t\t\t\tnode.C = text.replace(/[\\\\:\\]]/g, '\\\\$&');\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Translate alpha coordinates into an array\n\t\t * @param string alphaCoordinates\n\t\t * @return array [x, y]\n\t\t **/\n\t\ttranslateCoordinates: function (alphaCoordinates) {\n\t\t\tvar coordinateLabels = 'abcdefghijklmnopqrst';\n\t\t\tvar intersection = [];\n\n\t\t\tintersection[0] = coordinateLabels.indexOf(alphaCoordinates.substring(0, 1));\n\t\t\tintersection[1] = coordinateLabels.indexOf(alphaCoordinates.substring(1, 2));\n\n\t\t\treturn intersection;\n\t\t},\n\n\t\t/**\n\t\t * Convert path objects to strings and path strings to objects\n\t\t **/\n\t\tpathTransform: function (input, outputType, verbose) {\n\t\t\tvar output;\n\n\t\t\t// If no output type has been specified, try to set it to the\n\t\t\t// opposite of the input\n\t\t\tif (typeof outputType === 'undefined') {\n\t\t\t\toutputType = (typeof input === 'string') ? 'object' : 'string';\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Turn a path object into a string.\n\t\t\t */\n\t\t\tfunction stringify(input) {\n\t\t\t\tif (typeof input === 'string') {\n\t\t\t\t\treturn input;\n\t\t\t\t}\n\n\t\t\t\tif (!input) {\n\t\t\t\t\treturn '';\n\t\t\t\t}\n\n\t\t\t\toutput = input.m;\n\n\t\t\t\tvar variations = [];\n\t\t\t\tfor (var key in input) {\n\t\t\t\t\tif (input.hasOwnProperty(key) && key !== 'm') {\n\t\t\t\t\t\t// Only show variations that are not the primary one, since\n\t\t\t\t\t\t// primary variations are chosen by default\n\t\t\t\t\t\tif (input[key] > 0) {\n\t\t\t\t\t\t\tif (verbose) {\n\t\t\t\t\t\t\t\tvariations.push(', variation ' + input[key] + ' at move ' + key);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tvariations.push('-' + key + ':' + input[key]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\toutput += variations.join('');\n\t\t\t\treturn output;\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Turn a path string into an object.\n\t\t\t */\n\t\t\tfunction parse(input) {\n\t\t\t\tif (typeof input === 'object') {\n\t\t\t\t\tinput = stringify(input);\n\t\t\t\t}\n\n\t\t\t\tif (!input) {\n\t\t\t\t\treturn { m: 0 };\n\t\t\t\t}\n\n\t\t\t\tvar path = input.split('-');\n\t\t\t\toutput = {\n\t\t\t\t\tm: Number(path.shift())\n\t\t\t\t};\n\n\t\t\t\tif (path.length) {\n\t\t\t\t\tpath.forEach(function (variation, i) {\n\t\t\t\t\t\tvariation = variation.split(':');\n\t\t\t\t\t\toutput[Number(variation[0])] = parseInt(variation[1], 10);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\treturn output;\n\t\t\t}\n\n\t\t\tif (outputType === 'string') {\n\t\t\t\toutput = stringify(input);\n\t\t\t} else if (outputType === 'object') {\n\t\t\t\toutput = parse(input);\n\t\t\t} else {\n\t\t\t\toutput = undefined;\n\t\t\t}\n\n\t\t\treturn output;\n\t\t}\n\t};\n\n\treturn new Smartgamer();\n};\n","/* globals module: false, require: false\r\n\r\n*/\r\n/**\r\n * Provides a function for transforming SGF for a Go variant to SGF for a standard Go viewer; also provides a function for the inverse transformation.\r\n * @param {object} [options=] Defines various options for the output SGF. May be omitted, in which case the default options (see below) are used.\r\n * @param {boolean} [options.addComments = false] When flagged, comments are added to each node giving the move number and the number of stones captured by Black and White.\r\n * @param {boolean} [options.addPasses = true] When flagged, a pass is added to each node corresponding to a move by a player. This can make the output more easy to navigate in some viewers.\r\n * @param {array} [options.boardDimensions = [11, 11]] May be used for rectangular t-Go. Should be ommitted for [n, n] t-Go, where n is specified in the input SGF (@param variantSgf).\r\n * @param {number} [options.coordinatesType = 0] 0: none;\r\n * 1: (;A|1-K|11): Western;\r\n * 2: (;A|1-L|11): Western, no I;\r\n * 3: (;1|1-11|11): Latin/Latin, top to bottom;\r\n * 4: (;1|1-11|): Latin/Chinese, top to bottom;\r\n * @param {number} [options.wraparoundMarkersType = 1] 0: none;\r\n * 1: Full outline, using unicode Box Drawing symbols;\r\n * 2: corners and middles, using unicode Box Drawing symbols;\r\n * 3: just corners, using unicode Box Drawing symbols;\r\n * 4: just middles, using unicode Box Drawing symbols;\r\n * @param {object} [options.projectionSettings=] Further optional settings for how the (toroidal, or other sort of) board is projected to a flat grid.\r\n * @param {number} [options.projectionSettings.wraparound = 4]  Number of lines to add for the wraparound.\r\n * @param {array} [options.projectionSettings.offset = [0,0]]  Translation to apply to all moves.\r\n * @param {boolean} [options.transformToString=true] When set to false, the output is an object (an instance of a Smartgame).\r\n * @public\r\n * @return {object} An object exposing functions for going back and forth between SGF for a standard viewer, and SGF for a game of toroidal Go\r\n *//*todos:\r\noptions.markLastMove Default value: 'CR'\r\nopions.placesToCount Default: undefined. May be: 'last'|[countInfo1, .. countInfo1]. countInfo is a path plus an array with a point for each chain to be considered as dead. {path, deadChains: [...]}\r\noptions.projectionSettings.rotation {integer} Default value: 0. Allowed values: 0 .. 3\r\noptions.projectionSettings.normalizePlace array, or one of: C, TL TR BL BR (centre, top left, top right, bottom left, bottom right)\r\noptions.projectionSettings.normalize {boolean} \r\n\r\n*/\r\nfunction transformer(options\r\n) {\r\n\t'use strict';\r\n\tconst\r\n\t\t_flatten = require('lodash/flatten')\r\n\t\t, _uniqBy = require('lodash/uniqBy')\r\n\t\t, _fi = require('lodash/findIndex')\r\n\t\t, modulo = (x, y) => (x % y + y) % y\r\n\t\t, sourceSgfMessage = 'source sgf for toroidal Go has been adapted by go-variants-transformer so as to be rendered by any standard Go application'\r\n\toptions = {\r\n\t\taddPasses: true\r\n\t\t, boardDimensions: [11, 11]\r\n\t\t, transformToString: true\r\n\t\t, addComments: true\r\n\t\t, coordinatesType: 0\r\n\t\t, wraparoundMarkersType: 1\r\n\t\t//above are the defaults\r\n\t\t, ...options\r\n\t}\r\n\toptions.projectionSettings =\r\n\t\t{\r\n\t\t\twraparound: 4,\r\n\t\t\toffset: [0, 0],\r\n\t\t\t...options.projectionSettings\r\n\t\t}\r\n\r\n\tif (options.addPasses === undefined)\r\n\t\toptions.addPasses = true;\r\n\r\n\toptions.boardDimensions = options.boardDimensions || [11, 11]\r\n\r\n\tif (options.transformToString === undefined)\r\n\t\toptions.transformToString = true;\r\n\r\n\tif (options.addComments === undefined)\r\n\t\toptions.addComments = true;\r\n\t// options.projectionSettings = \r\n\r\n\tlet wraparound = options.projectionSettings.wraparound\r\n\r\n\tlet $ = {}\r\n\t\t// , _markersForWraparound = null\r\n\t\t, coordinateLabels = function (i) {\r\n\t\t\t// 97..122 and 65..90\r\n\t\t\treturn String.fromCharCode(i < 26 ? i + 97 : i + 39)\r\n\t\t\t//65 - 26 =\r\n\t\t}\r\n\t\t,\r\n\t\ttranslateCoordinate = (c) => {\r\n\t\t\tlet r = c.charCodeAt(0)\r\n\t\t\treturn r >= 97 ? r - 97 : r - 26\r\n\t\t},\r\n\t\t/**\r\n\t\t * Translate alpha coordinates into an array\r\n\t\t * @param string alphaCoordinates\r\n\t\t * @return array [x, y]\r\n\t\t **/\r\n\t\ttranslateCoordinates = (alphaCoordinates) => {\r\n\t\t\treturn [translateCoordinate(alphaCoordinates.substring(0, 1))\r\n\t\t\t\t, translateCoordinate(alphaCoordinates.substring(1, 2))]\r\n\r\n\t\t}\r\n\r\n\r\n\t$.coordinateLabels = coordinateLabels\r\n\t$.translateCoordinates = translateCoordinates\r\n\t/**\r\n\t * @public\r\n\t */\r\n\t$.options = options\r\n\r\n\t$.projectOnLine = function (a, isVertical) {\r\n\t\t/*\r\n\t\tm: boardDimensions[0] : 11\r\n\t\tn: wraparound : 4\r\n\t\tline: 0,...,(m-1)\r\n\t\t=>\r\n\t\t0,...,(n-1), (start line) n, ... , (n + m - 1) end line,  (n+m), ... , (2n + m - 1)\r\n\r\n\t\tcoordinate a  {0 .. m-1} projects to n + a in main area\r\n\t\tall projections are of the form n + a + xm, x   s.t. 0  n + a + xm  2n + m -1\r\n\t\t-xm  n + a\r\n\t\t\tsmallest such x < 0 is ceil(-(n+a)/m)\r\n\t\t xm  n + m - 1 -a\r\n\t\t\tlargest such x is floor((n + m - 1 -a) / m)\r\n\r\n\r\n\t\t*/\r\n\r\n\t\tconst m //= options.boardDimensions[0]\r\n\t\t\t= options.boardDimensions[isVertical ? 1 : 0]\r\n\r\n\t\t\t, r = []\r\n\r\n\t\tfor (let i = Math.ceil(-(wraparound + a) / m); i <= (wraparound + m - 1 - a) / m; i++)\r\n\t\t\tr.push(wraparound + a + i * m)\r\n\t\treturn r\r\n\t}\r\n\r\n\t/**\r\n\t * This is the inverse function to the function projectOnFlat  at least it is when multiple is false.\r\n\t * @param {Array} points The point or array of points projected onto the grid.\r\n\t * @param {Boolean=false} multiple Whether the argument points is the image of a single point (multiple=false) or of multiple points.\r\n\t * @returns {Array} When the flag multiple is flagged, returns an array of points; otherwise returns a single point (i.e. an array of two integers).\r\n\t */\r\n\tfunction inverseProjectOnFlat(points, multiple) {\r\n\t\tif (!Array.isArray(points[0])) points = [points]\r\n\t\tif (!multiple)\r\n\t\t\treturn [modulo(points[0][0] - options.projectionSettings.offset[0] - wraparound, options.boardDimensions[0])\r\n\t\t\t\t, modulo(points[0][1] - options.projectionSettings.offset[1] - wraparound, options.boardDimensions[1])]\r\n\t\treturn _uniqBy(points.map(x => inverseProjectOnFlat([x])), (x) => `${x[0]}_${x[1]}`)\r\n\t}\r\n\t$.inverseProjectOnFlat = inverseProjectOnFlat\r\n\r\n\t/**\r\n\t * Projects a point on the t-Go board to the array of points on the standard grid/board.\r\n\t * @param {Array} p The point in the t-Go board to be projected on to the grid.\r\n\t * @returns {Array}\r\n\t */\r\n\tfunction projectOnFlat(p) {\r\n\t\tconst a = $.projectOnLine(p[0] + options.projectionSettings.offset[0])\r\n\t\t\t, b = $.projectOnLine(p[1] + options.projectionSettings.offset[1])\r\n\t\t\t, r = []\r\n\t\tfor (let i = 0; i < a.length; i++)\r\n\t\t\tfor (let j = 0; j < b.length; j++)\r\n\t\t\t\tr.push([a[i], b[j]])\r\n\t\treturn r\r\n\t}\r\n\t$.projectOnFlat = projectOnFlat\r\n\r\n\t$.modX = (x) => modulo(x, options.boardDimensions[0])\r\n\t$.modY = (y) => modulo(y, options.boardDimensions[1])\r\n\r\n\tlet setUpMarkers = () => {\r\n\t\t$.wraparoundAndCoords = []\r\n\r\n\t\t// $.getMarkersForWraparound = function (){\r\n\t\tif (options.projectionSettings.wraparound > 0) {\r\n\t\t\tconst m = options.boardDimensions[0],\r\n\t\t\t\tn = options.boardDimensions[1]\r\n\r\n\t\t\t/*\r\n\t\t\tm: boardDimensions[0] : 11\r\n\t\t\tw: wraparound : 4\r\n\t\t\tline: 0,...,(m-1)\r\n\t\t\t=>\r\n\t\t\t0,...,(w-1), (start line) w, ... , (w + m - 1) end line, (w+m), ... , (2w + m - 1)\r\n\t\t\t*/\r\n\r\n\t\t\tlet board = []\r\n\t\t\tif ([1, 2, 4].indexOf(options.wraparoundMarkersType) > -1) {\r\n\t\t\t\tlet middles = options.wraparoundMarkersType > 1 ?\r\n\t\t\t\t\t[Math.floor((m - 1) / 2) + 1, Math.ceil((m - 1) / 2) + 1,\r\n\t\t\t\t\tMath.floor((n - 1) / 2) + 1, Math.ceil((n - 1) / 2) + 1]\r\n\t\t\t\t\t: [-1, 99, -1, 99]\r\n\t\t\t\tfor (let i = 1; i <= m; i++) {\r\n\t\t\t\t\tif (i < middles[0] || i > middles[1]) {\r\n\t\t\t\t\t\tcontinue\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlet label = ''//U+2500 Box Drawings Light Horizontal\r\n\r\n\t\t\t\t\tboard.push(coordinateLabels(wraparound - 1 + i) + coordinateLabels(wraparound - 1) + \":\" + label)\r\n\t\t\t\t\tboard.push(coordinateLabels(wraparound - 1 + i) + coordinateLabels(wraparound + m) + \":\" + label)\r\n\t\t\t\t}\r\n\t\t\t\tfor (let i = 1; i <= n; i++) {\r\n\t\t\t\t\tif (i < middles[2] || i > middles[3]) {\r\n\t\t\t\t\t\tcontinue\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlet label = ''//unicode too\r\n\t\t\t\t\tboard.push(coordinateLabels(wraparound - 1) + coordinateLabels(wraparound - 1 + i) + \":\" + label)\r\n\t\t\t\t\tboard.push(coordinateLabels(wraparound + n) + coordinateLabels(wraparound - 1 + i) + \":\" + label)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif ([1, 2, 3].indexOf(options.wraparoundMarkersType) > -1) {\r\n\t\t\t\t//     \r\n\t\t\t\tboard.push(coordinateLabels(wraparound - 1) + coordinateLabels(wraparound + n) + \":\")\r\n\t\t\t\tboard.push(coordinateLabels(wraparound + m) + coordinateLabels(wraparound + n) + \":\")\r\n\t\t\t\tboard.push(coordinateLabels(wraparound - 1) + coordinateLabels(wraparound - 1) + \":\")\r\n\t\t\t\tboard.push(coordinateLabels(wraparound + m) + coordinateLabels(wraparound - 1) + \":\")\r\n\t\t\t}\r\n\r\n\t\t\tif (options.coordinatesType > 0 && wraparound > 1) {\r\n\t\t\t\tfor (let i = 1; i < 2 * wraparound + m - 1; i++) {\r\n\r\n\t\t\t\t\tlet coordIndex = $.modX(-options.projectionSettings.offset[0] - wraparound + i)\r\n\r\n\t\t\t\t\tif (options.coordinatesType === 2 && coordIndex >= 8) {\r\n\t\t\t\t\t\t//omit the I - historical coordinates for Go...\r\n\t\t\t\t\t\t//I: 9th letter\r\n\t\t\t\t\t\tcoordIndex++\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlet label =\r\n\t\t\t\t\t\toptions.coordinatesType < 3\r\n\t\t\t\t\t\t\t? coordinateLabels(coordIndex).toUpperCase()\r\n\t\t\t\t\t\t\t: '' + (coordIndex + 1)\r\n\t\t\t\t\tboard.push(coordinateLabels(i) + coordinateLabels(0) + \":\" + label)\r\n\t\t\t\t\tboard.push(coordinateLabels(i) + coordinateLabels(2 * wraparound + n - 1) + \":\" + label)\r\n\t\t\t\t}\r\n\t\t\t\tlet cjkNumbers = ''\r\n\t\t\t\tfor (let i = 1; i < 2 * wraparound + n - 1; i++) {\r\n\t\t\t\t\t/*\r\n\t\t\t\t\t0\t\t-w\r\n\t\t\t\t\t...\r\n\t\t\t\t\tw-1\t-1\r\n\t\t\t\t\tw\t\t0\r\n\t\t\t\t\t...\r\n\t\t\t\t\tw + n -1\r\n\t\t\t\t\t\r\n\t\t\t\t\t*/\r\n\t\t\t\t\tlet coordIndex =\r\n\t\t\t\t\t\toptions.coordinatesType < 3\r\n\t\t\t\t\t\t\t? $.modY(n + options.projectionSettings.offset[1] + wraparound - i - 1)\r\n\t\t\t\t\t\t\t: $.modY(i - wraparound - options.projectionSettings.offset[1])\r\n\t\t\t\t\tlet label = ''\r\n\t\t\t\t\tswitch (options.coordinatesType) {\r\n\t\t\t\t\t\tcase 1:\r\n\t\t\t\t\t\tcase 2:\r\n\t\t\t\t\t\tcase 3:\r\n\t\t\t\t\t\t\tlabel = '' + (coordIndex + 1)\r\n\t\t\t\t\t\t\tbreak\r\n\t\t\t\t\t\tcase 4:\r\n\t\t\t\t\t\t\tlabel = modulo(coordIndex, 10) === 9 ? '' : cjkNumbers[modulo(coordIndex, 10)]\r\n\r\n\t\t\t\t\t\t\tif (coordIndex > 8) {\r\n\t\t\t\t\t\t\t\tlabel = (coordIndex > 18 ? cjkNumbers[Math.floor((coordIndex + 1) / 10) - 1] : '') + '' + label\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tbreak\r\n\t\t\t\t\t}\r\n\t\t\t\t\tboard.push(coordinateLabels(0) + coordinateLabels(i) + \":\" + label)\r\n\t\t\t\t\tboard.push(coordinateLabels(2 * wraparound + m - 1) + coordinateLabels(i) + \":\" + label)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t$.wraparoundAndCoords = board\r\n\t\t}\r\n\t}\r\n\tsetUpMarkers()\r\n\r\n\r\n\t$.coords2String =\r\n\t\t/**\r\n\t\t * converts coordinates to a string\r\n\t\t */\r\n\t\tfunction coords2String(coords) {\r\n\t\t\treturn coordinateLabels(coords[0]) + coordinateLabels(coords[1])\r\n\t\t}\r\n\r\n\tfunction goThroughTree(state) {\r\n\t\tlet { wrappedGame, node, pending, currentPath, tGo } = state\r\n\t\t\t, nbVariations = wrappedGame.variations().length\r\n\t\tif (currentPath.m > 1000) throw new Error('seem to be stuck!');\r\n\t\tstate.hasSiblings = nbVariations > 0\r\n\t\tif (state.hasSiblings) {\r\n\t\t\t// if(currentPath[m] === undefined)\r\n\t\t\t// currentPath[m] = 0\r\n\t\t\t// else\r\n\t\t\t// currentPath[m] += 1\r\n\t\t\t// currentPath.m += 1\r\n\t\t\tfor (let i = nbVariations - 1; i > 0; i--)\r\n\t\t\t//pile up in this order, as it's FILO and we want the last variation, which may contain a mode added by CGoboard to go last\r\n\t\t\t{\r\n\t\t\t\tlet pathForLater = { ...currentPath }//Object.assign({}, currentPath)\r\n\t\t\t\tpathForLater[currentPath.m + 1] = i\r\n\t\t\t\tpathForLater.m += 1\r\n\r\n\t\t\t\tif (tGo !== undefined)\r\n\t\t\t\t\tpending.push({ path: pathForLater, tGoData: tGo.exportData() })\r\n\t\t\t\telse\r\n\t\t\t\t\tpending.push({ path: pathForLater })\r\n\r\n\t\t\t}\r\n\t\t\tstate.node = wrappedGame.next().node()\r\n\t\t\tcurrentPath[currentPath.m + 1] = 0\r\n\t\t\tcurrentPath.m += 1\r\n\t\t\treturn state.node\r\n\t\t}\r\n\r\n\t\tlet nextNode = wrappedGame.next().node()\r\n\t\tif (node === nextNode) {//at a leaf:\r\n\t\t\tif (pending.length === 0) {\r\n\t\t\t\tstate.node = null\r\n\t\t\t\treturn state.node//finished\r\n\t\t\t}\r\n\t\t\tlet fromStack = pending.pop()\r\n\t\t\tstate.hasSiblings = true\r\n\t\t\t// if (fromStack === null) {\r\n\t\t\t// \tnode = null\r\n\t\t\t// \treturn//finished!\r\n\t\t\t// }\r\n\t\t\tif (tGo !== undefined) tGo.loadData(fromStack.tGoData)\r\n\t\t\tstate.node = wrappedGame.goTo(fromStack.path).node()\r\n\t\t\tstate.currentPath = fromStack.path\r\n\t\t\treturn state.node\r\n\t\t}\r\n\t\telse {\r\n\t\t\tcurrentPath.m += 1\r\n\t\t\tstate.node = nextNode\r\n\t\t\treturn state.node\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Apart from a few details, this is an inverse of the transform function.\r\n\t * @param {smartgame|string} wrappedGame\r\n\t * @param {smartgame} smartgame\r\n\t * @public\r\n\t */\r\n\tfunction inverseTransform(\r\n\t\twrappedGame, smartgame) {\r\n\r\n\t\tif (smartgame === undefined) {\r\n\t\t\tsmartgame = require('smartgame')\r\n\t\t}\r\n\r\n\t\tif (typeof wrappedGame === 'string') {\r\n\t\t\tvar smartgamer = require('smartgamer')\r\n\t\t\twrappedGame = smartgamer(smartgame.parse(wrappedGame))\r\n\t\t}\r\n\r\n\t\tlet node = wrappedGame.first().node()\r\n\t\t\t, pending = []\r\n\t\t\t, currentPath = { m: 0 }\r\n\t\t\t, cleanerRegEx = /^[a-zA-Z :0-9\\-(\\r\\n]+GoVariantsTransformer\\)--[\\r\\n]*/\r\n\t\t\t, cleanComments = () => {\r\n\t\t\t\tif (node.C !== undefined) {\r\n\t\t\t\t\tnode.C = node.C.replace(cleanerRegEx, '')\r\n\t\t\t\t}\r\n\t\t\t\tif (node.C === '')\r\n\t\t\t\t\tdelete node.C\r\n\t\t\t}\r\n\t\t\t,\r\n\t\t\t/**\r\n\t\t\t * Function to:\r\n\t\t\t * \t- remove the border (unicode symbols added by the transform to indicate where the wraparound area meets the main grid).\r\n\t\t\t * \t- remove CM (colour map) and CT (colour table) which are nonstandard SGF added by CGoboard for background colour (could be interesting to use this feature later on).\r\n\t\t\t */\r\n\t\t\tcleanLabels = () => {\r\n\r\n\t\t\t\tlet labels = []\r\n\t\t\t\tif (node.LB !== undefined) {\r\n\t\t\t\t\tlabels = node.LB\r\n\t\t\t\t\tif (!Array.isArray(labels))\r\n\t\t\t\t\t\tlabels = [labels]\r\n\t\t\t\t\tlabels = labels.filter(i => !$.wraparoundAndCoords.includes(i))\r\n\t\t\t\t\t/* jshint loopfunc: true */\r\n\t\t\t\t\tlabels =\r\n\t\t\t\t\t\t_uniqBy(\r\n\t\t\t\t\t\t\tlabels\r\n\t\t\t\t\t\t\t\t.map(function (x) { return x.split(':', 2) })//assume the label doesnt contain :\r\n\t\t\t\t\t\t\t\t.map((x) => [$.coords2String($.inverseProjectOnFlat(translateCoordinates(x[0]))), x[1]])\r\n\t\t\t\t\t\t\t, (x) => x[0])\r\n\t\t\t\t\t\t\t.map((x) => `${x[0]}:${x[1]}`)\r\n\r\n\r\n\t\t\t\t\t// labels = []\r\n\t\t\t\t\t// for (let i = 0; i < labels2.length; i++)\r\n\t\t\t\t\t// \tlabels = labels.concat(labels2)\r\n\t\t\t\t}\r\n\r\n\t\t\t\tnode.LB = labels\r\n\t\t\t\tif (node.LB.length === 0)\r\n\t\t\t\t\tdelete node.LB\r\n\r\n\t\t\t\tif (node.CM)\r\n\t\t\t\t\tdelete node.CM\r\n\t\t\t\tif (node.CT)\r\n\t\t\t\t\tdelete node.CT\r\n\t\t\t}\r\n\r\n\t\tcleanLabels()\r\n\t\tnode.SZ = options.boardDimensions[0]\r\n\t\tnode.AP = \"go-variants-transformer\"\r\n\r\n\t\tif (node.SO !== undefined) {\r\n\t\t\tlet cleanSourceRegex = new RegExp(` \\\\(${sourceSgfMessage}\\\\)`)\r\n\t\t\tnode.SO = node.SO.replace(cleanSourceRegex, '')\r\n\t\t\t// if (node.SO === '')\r\n\t\t\t// \tdelete node.SO\r\n\t\t}\r\n\r\n\t\tlet state = {\r\n\t\t\twrappedGame, node, pending, currentPath, siblingMoves: {}//, parentsWithChildToDelete: [] \r\n\t\t}\r\n\r\n\t\tnode = goThroughTree(state)\r\n\t\twhile (node !== null) {\r\n\t\t\tcleanLabels()\r\n\t\t\tcleanComments()\r\n\r\n\t\t\tconst\r\n\t\t\t\tisBlack = node.AB !== undefined || node.B !== undefined\r\n\t\t\t\t, addedStones = isBlack ? node.AB : node.AW\r\n\t\t\t\t, playedStone = isBlack ? node.B : node.W\r\n\t\t\t\t, move = addedStones ? addedStones : playedStone\r\n\t\t\t\t, moveAsArray = Array.isArray(move) ? move : [move]\r\n\t\t\t\t, isAPass = isBlack ? node.B === '' : node.W === ''\r\n\t\t\t\t, moveHasCoords = move !== undefined && move !== ''\r\n\t\t\t\t, coords = !moveHasCoords ? undefined : $.coords2String($.inverseProjectOnFlat(moveAsArray.map(translateCoordinates)))\r\n\r\n\t\t\t//alter the node\r\n\r\n\t\t\t/*\r\n\t\t\tlogic removing a node added by CGoboard, if there already is the same move as AB or AW in a prior variation; assuming \r\n\t\t\tthe variation to be removed is the last of the siblings - which does seem to be the way CGoboard behaves when a click \r\n\t\t\tis made on a point where the next node is AB or AW.  \r\n\t\t\t*/\r\n\t\t\tif (state.hasSiblings) {\r\n\t\t\t\tlet pathForParent = { ...wrappedGame.path } //Object.assign({}, wrappedGame.path)\r\n\t\t\t\tpathForParent.m--\r\n\t\t\t\tdelete pathForParent[pathForParent.m]\r\n\t\t\t\tpathForParent = wrappedGame.pathTransform(pathForParent)\r\n\t\t\t\t// wrappedGame.previous()\r\n\t\t\t\tif (state.siblingMoves[pathForParent] === undefined) {\r\n\t\t\t\t\tstate.siblingMoves[pathForParent] = []\r\n\t\t\t\t}\r\n\t\t\t\tif (addedStones) {\r\n\t\t\t\t\tstate.siblingMoves[pathForParent].push(coords)\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t\tif (playedStone && state.siblingMoves[pathForParent].indexOf(coords) > -1) {\r\n\r\n\t\t\t\t\t\t// state.parentsWithChildToDelete.push(pathForParent)\r\n\t\t\t\t\t\tnode.XX = \"inverseTransformToDelete\"\r\n\t\t\t\t\t}\r\n\t\t\t\t// wrappedGame.goTo(currentPath)\r\n\t\t\t}\r\n\r\n\t\t\tdelete node[isBlack ? 'AB' : 'AW']\r\n\t\t\tdelete node[isBlack ? 'B' : 'W']\r\n\t\t\tdelete node.CR\r\n\t\t\tdelete node.AE\r\n\r\n\t\t\tif (isAPass) {\r\n\t\t\t\tnode[isBlack ? 'B' : 'W'] = ''\r\n\t\t\t}\r\n\r\n\t\t\tif (moveHasCoords) {\r\n\t\t\t\tnode[isBlack ? 'B' : 'W'] = coords\r\n\t\t\t}\r\n\r\n\t\t\t;/*note: this next semicolon is needed! */[// eslint-disable-line no-extra-semi\r\n\t\t\t\t//'CR',todo: add if not marking the move\r\n\t\t\t\t'DD', 'MA', 'SL', 'SQ', 'TR'].forEach(function (sgfProperty) {\r\n\t\t\t\t\t// _.map(['DD','MA','SL','SQ','TR'], function(sgfProperty){\r\n\t\t\t\t\tif (node[sgfProperty] === undefined) return\r\n\t\t\t\t\tlet points = []\r\n\t\t\t\t\tif (Array.isArray(node[sgfProperty])) {\r\n\t\t\t\t\t\tpoints = node[sgfProperty]\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tpoints = [node[sgfProperty]]\r\n\t\t\t\t\t}\r\n\t\t\t\t\tpoints =\r\n\t\t\t\t\t\t$.inverseProjectOnFlat(\r\n\t\t\t\t\t\t\tpoints.map(translateCoordinates), true\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t.map($.coords2String)\r\n\t\t\t\t\tnode[sgfProperty] = points\r\n\t\t\t\t})\r\n\t\t\t// move to next node\r\n\t\t\tnode = goThroughTree(state)\r\n\t\t}\r\n\r\n\t\t// state.parentsWithChildToDelete.forEach((path) => {\r\n\t\t// \t//remove the sgf node\r\n\t\t// \twrappedGame.goTo(path)\r\n\t\t// \tlet sequences = wrappedGame.game.sequences\r\n\t\t// \tlet index = _fi(sequences, (seq) => seq.nodes[0].inverseTransformToDelete)\r\n\t\t// \t\t, tmpI = 0\r\n\t\t// \twhile (index > -1) {\r\n\t\t// \t\tsequences.splice(index, 1)\r\n\t\t// \t\tindex = _fi(sequences, (seq) => seq.nodes[0].inverseTransformToDelete)\r\n\t\t// \t\ttmpI++\r\n\t\t// \t\tif (tmpI > 100) throw new Error('seem to be stuck!');\r\n\t\t// \t}\r\n\r\n\t\t// \t// console.log(path)\r\n\t\t// })\r\n\r\n\t\tlet deleteNodes = (sequence) => {\r\n\t\t\tif (sequence.sequences) {\r\n\r\n\t\t\t\tlet\r\n\t\t\t\t\tsequences = sequence.sequences\r\n\t\t\t\t\t, index = _fi(sequences, (seq) => seq.nodes[0].XX === 'inverseTransformToDelete')\r\n\t\t\t\t\t, tmpI = 0, max = sequences.length\r\n\t\t\t\twhile (index > -1) {\r\n\t\t\t\t\tsequences.splice(index, 1)\r\n\t\t\t\t\tindex = _fi(sequences, (seq) => seq.nodes[0].XX === 'inverseTransformToDelete')\r\n\t\t\t\t\ttmpI++\r\n\t\t\t\t\tif (tmpI > max) throw new Error('seem to be stuck!');\r\n\t\t\t\t}\r\n\t\t\t\tfor (let index2 = 0; index2 < sequences.length; index2++) {\r\n\t\t\t\t\t// deleteNodes(sequences[index2].nodes[sequences[index2].nodes.length - 1]);\r\n\t\t\t\t\tdeleteNodes(sequences[index2]);\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (sequence.nodes)\r\n\t\t\t\tdeleteNodes(sequence.nodes[sequence.nodes.length - 1])\r\n\t\t}\r\n\t\tdeleteNodes(wrappedGame.game)\r\n\r\n\t\tif (options.transformToString)\r\n\t\t\treturn smartgame.generate({ gameTrees: [wrappedGame.game] });\r\n\t\telse return wrappedGame\r\n\r\n\t}\r\n\t$.inverseTransform = inverseTransform\r\n\r\n\t/**\r\n\t * Main function; converts SGF for a Go variant (so far, just toroidal Go or t-Go).\r\n\t * @param {string} tSgf\r\n\t * @param {object} tGo Engine for counting liberties in t-Go. An instance of go-variants-engine.\r\n\t * @param {*} smartgame\r\n\t * @param {*} smartgamer\r\n\t * @returns {string|object} SGF that can be viewed in a standard SGF viewer. (See `options.transformToString` for the data type of the value returned.)\r\n\t * @public\r\n\t */\r\n\tfunction transform(\r\n\t\ttSgf //eg 11x11 sgf from LittleGolem\r\n\t\t, tGo //app implementing t-Go\r\n\t\t, smartgame\r\n\t\t, smartgamer) {\r\n\r\n\t\tif (tGo === undefined) {\r\n\t\t\t//  tGo = require('../dist/node_modules/go-variants-engine/src/engine.min.js')({\r\n\t\t\t//  tGo = require('../../engine/dist/engine.min.js')({\r\n\t\t\t\ttGo = require('go-variants-engine')({\r\n\t\t\t\t\t// tGo = require('../node_modules/go-variants-engine/src/engine')({\r\n\t\t\t\t// boardMode:'t',\r\n\t\t\t\tboardDimensions: options.boardDimensions\r\n\t\t\t})\r\n\t\t\t// tGo = require('../node_modules/go-variants-engine')({boardMode:'t', boardDimensions:options.boardDimensions})\r\n\t\t\t// tGo = require('../node_modules/go-variants-engine/src/engine')({boardMode:'t', boardDimensions:options.boardDimensions})\r\n\t\t}\r\n\t\t// else {\r\n\t\t// \ttGo.options.boardDimensions = options.boardDimensions\r\n\t\t// }\r\n\r\n\t\tif (smartgame === undefined) {\r\n\t\t\tsmartgame = require('smartgame')\r\n\t\t}\r\n\t\tif (smartgamer === undefined) {\r\n\t\t\tsmartgamer = require('smartgamer')\r\n\t\t}\r\n\t\t// console.log(tGo)\r\n\t\tlet parsed = smartgame.parse(tSgf)\r\n\t\t\t, wrappedGame = smartgamer(parsed)\r\n\t\t\t, node = wrappedGame.node()\r\n\t\t\t, passes = 0\r\n\t\t\t, pending = []\r\n\t\t\t, currentPath = { m: 0 }\r\n\t\tif (node.SZ !== undefined) {\r\n\t\t\tlet sz = Number(node.SZ)\r\n\t\t\t// sz+= 2*options.projectionSettings.wraparound\r\n\t\t\toptions.boardDimensions = [sz, sz]\r\n\t\t\ttGo.options.boardDimensions = options.boardDimensions\r\n\t\t\tsetUpMarkers()\r\n\t\t}\r\n\t\tif (node.KM !== undefined) {\r\n\t\t\toptions.rules = {komi: parseFloat(node.KM), ... options.rules }\r\n\t\t}\r\n\t\tnode.SZ = \"\" + (options.boardDimensions[0] + 2 * options.projectionSettings.wraparound)//not sure how to make a rectangular goban!\r\n\t\t//offset modulo\r\n\t\toptions.projectionSettings.offset[0] = modulo(options.projectionSettings.offset[0], options.boardDimensions[0])\r\n\t\toptions.projectionSettings.offset[1] = modulo(options.projectionSettings.offset[1], options.boardDimensions[1])\r\n\t\tlet setLabels = () => {\r\n\t\t\t//node.LB = $.wraparoundAndCoords\r\n\t\t\tlet labels = []\r\n\t\t\tif (node.LB !== undefined) {\r\n\t\t\t\tlabels = node.LB\r\n\t\t\t\tif (!Array.isArray(labels))\r\n\t\t\t\t\tlabels = [labels]\r\n\r\n\t\t\t\t/* jshint loopfunc: true */\r\n\t\t\t\tlet labels2 = labels//_.chain(labels)\r\n\t\t\t\t\t.map(function (x) { return x.split(':', 2) })//assume the label doesnt contain :\r\n\t\t\t\t\t.map(function (x) { return [translateCoordinates(x[0]), x[1]] })\r\n\t\t\t\t\t.map(function (x) { return [$.projectOnFlat(x[0]), x[1]] })\r\n\t\t\t\t// .value()\r\n\t\t\t\tlabels = []\r\n\t\t\t\tfor (let i = 0; i < labels2.length; i++)\r\n\t\t\t\t\tlabels = labels.concat(\r\n\t\t\t\t\t\tlabels2[i][0].map(function (x) {\r\n\t\t\t\t\t\t\treturn $.coords2String(x) + \":\" + labels2[i][1]\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t)\r\n\t\t\t}\r\n\r\n\t\t\tnode.LB = $.wraparoundAndCoords.concat(labels)\r\n\t\t\tif (node.LB.length === 0)\r\n\t\t\t\t// delete node['LB']\r\n\t\t\t\tdelete node.LB\r\n\t\t}\r\n\r\n\t\tsetLabels()\r\n\r\n\t\tif (node.SO !== undefined)\r\n\t\t\tnode.SO = wrappedGame.game.nodes[0].SO + ` (${sourceSgfMessage})`\r\n\t\t//else node.SO = sourceSgfMessage//prefer not to add the message when original Sgf has no SO info.\r\n\r\n\t\tnode.AP = \"go-variants-transformer\"\r\n\r\n\r\n\t\tlet state = { wrappedGame, node, pending, currentPath, tGo }\r\n\r\n\t\tfunction comment(isPass, isBlack, score) {\r\n\t\t\tif (!options.addComments && !score)\r\n\t\t\t\treturn\r\n\r\n\t\t\tlet r = !options.addComments ?\r\n\t\t\t\t''\r\n\t\t\t\t: 'move ' + state.currentPath.m + '\\n' + 'White stones captured by Black: ' + tGo.board.captured[1] + '\\nBlack stones captured by White: ' + tGo.board.captured[0]\r\n\t\t\t\t//let r =  'Black captures: ' + tGo.board.captured[1] + '\\r\\nWhite captures: ' + tGo.board.captured[0]\r\n\t\t\t\t+ (!isPass ? '' : '\\n' + (isBlack ? 'Black passes' : 'White passes'))\r\n\t\t\t\t+ (!score ? '' : '\\n' + `result: ${score.displayResult}`)\r\n\r\n\t\t\tr += '\\n--(the content above was generated automatically by GoVariantsTransformer)--'\r\n\t\t\tr += (node.C === undefined ? '' : '\\n' + node.C)\r\n\t\t\tnode.C = r\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tnode = goThroughTree(state)\r\n\t\twhile (node !== null) {\r\n\r\n\r\n\t\t\tlet\r\n\t\t\t\tisBlack = node.B !== undefined\r\n\t\t\t\t, move = isBlack ? node.B : node.W\r\n\t\t\t\t, isPass = move === \"\" || (options.boardDimensions[0] === options.boardDimensions[1]\r\n\t\t\t\t\t&& options.boardDimensions[0] <= 19\r\n\t\t\t\t\t&& move === \"tt\" //weird SGF[3] way to show a pass move!\r\n\t\t\t\t)\r\n\t\t\t\t, stonesMarkedForScoring = []\r\n\r\n\t\t\tif (move === undefined && !isPass) {\r\n\t\t\t\tnode = goThroughTree(state)\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\tsetLabels()\r\n\r\n\t\t\tif (isPass) {\r\n\t\t\t\tdelete node[isBlack ? 'B' : 'W']\r\n\t\t\t\tcomment(isPass, isBlack)\r\n\t\t\t\tnode[isBlack ? 'AB' : 'AW'] = []\r\n\t\t\t\t// if (passes === 2) {\r\n\t\t\t\t// \t//wrappedGame.game.nodes.splice(i+1)//get rid of nodes afterwards -- may not work with variations! todo\r\n\t\t\t\t// \tbreak;//stop after 3 successive passes for now\r\n\t\t\t\t// }\r\n\t\t\t\tpasses++\r\n\t\t\t\tif (passes >= 1000)\r\n\t\t\t\t\tbreak//just in case!\r\n\t\t\t\tnode = goThroughTree(state)\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tconst coords = translateCoordinates(move)\r\n\t\t\t\tlet playResult = null\r\n\t\t\t\t// run move through tGo and update game accordingly\r\n\t\t\t\ttry {\r\n\t\t\t\t\tplayResult = tGo.play(isBlack ? 'b' : 'w', coords)\r\n\r\n\t\t\t\t} catch (error) {\r\n\t\t\t\t\tif (error.message !== 'point is not empty' /*ignore this - it happens with some sgf from littleGolem. Todo: look into scoring the position here. */)\r\n\t\t\t\t\t\tthrow (error)\r\n\t\t\t\t}\r\n\t\t\t\tconst projectedCoords = $.projectOnFlat(coords)\r\n\t\t\t\tlet toAdd = playResult === null ? [] : projectedCoords.map($.coords2String)\r\n\t\t\t\t\t, toRemove = playResult === null ? [] :\r\n\t\t\t\t\t\t// _.chain(playResult.removed)\r\n\t\t\t\t\t\t// \t.flatten(true)\r\n\t\t\t\t\t\t// \t.map($.projectOnFlat)\r\n\t\t\t\t\t\t// \t.flatten(true)\r\n\t\t\t\t\t\t// \t.map($.coords2String)\r\n\t\t\t\t\t\t// \t.value()\r\n\t\t\t\t\t\t_flatten(\r\n\t\t\t\t\t\t\t_flatten(playResult.removed)\r\n\t\t\t\t\t\t\t\t.map($.projectOnFlat))\r\n\t\t\t\t\t\t\t.map($.coords2String)\r\n\r\n\t\t\t\t//alter the node\r\n\t\t\t\tif (options.addPasses)\r\n\t\t\t\t\tnode[isBlack ? 'B' : 'W'] = ''\r\n\t\t\t\telse delete node[isBlack ? 'B' : 'W']\r\n\t\t\t\t// node[isBlack ? 'B' : 'W'] = ''\r\n\t\t\t\tnode[isBlack ? 'AB' : 'AW'] = toAdd\r\n\t\t\t\tif (toAdd.length > 0)\r\n\t\t\t\t\tnode.CR = toAdd\r\n\t\t\t\tif (toRemove.length > 0)\r\n\t\t\t\t\tnode.AE = toRemove\r\n\r\n\t\t\t\t\t\t/*\r\n\t\t\t\t\t\ttodo: other properties with board coordinates\r\n\t\t\t\t\t\tLeave for now:\r\n\t\t\t\t\t\tAR\r\n\t\t\t\t\t\tLN\r\n\t\t\t\t\t\t*/\r\n\r\n\t\t\t\t\t\t;/*note this semicolon is needed! */\r\n\t\t\t\t[\r\n\t\t\t\t\t//'CR',todo: add if not marking the move\r\n\t\t\t\t\t'DD', 'MA', 'SL', 'SQ', 'TR'].forEach(function (sgfProperty) {\r\n\t\t\t\t\t\t// _.map(['DD','MA','SL','SQ','TR'], function(sgfProperty){\r\n\t\t\t\t\t\tif (node[sgfProperty] === undefined) return\r\n\t\t\t\t\t\tlet points = []\r\n\t\t\t\t\t\tif (Array.isArray(node[sgfProperty])) {\r\n\t\t\t\t\t\t\tpoints = node[sgfProperty]\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tpoints = [node[sgfProperty]]\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (node.SC && sgfProperty === 'MA') {\r\n\t\t\t\t\t\t\tstonesMarkedForScoring = { ...points }\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tpoints =\r\n\t\t\t\t\t\t\t// _.chain(points)\r\n\t\t\t\t\t\t\t// \t.map(translateCoordinates)\r\n\t\t\t\t\t\t\t// \t.map($.projectOnFlat)\r\n\t\t\t\t\t\t\t// \t.flatten(true)\r\n\t\t\t\t\t\t\t// \t.map($.coords2String)\r\n\t\t\t\t\t\t\t// \t.value()\r\n\t\t\t\t\t\t\t_flatten(\r\n\t\t\t\t\t\t\t\tpoints\r\n\t\t\t\t\t\t\t\t\t.map(translateCoordinates)\r\n\t\t\t\t\t\t\t\t\t.map($.projectOnFlat)\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t.map($.coords2String)\r\n\t\t\t\t\t\tnode[sgfProperty] = points\r\n\t\t\t\t\t})\r\n\t\t\t\tnode.MN = currentPath.m\r\n\r\n\t\t\t\t/*\r\n\t\t\t\tUse a custom, new SGF property, SC, in order to see if the current position should be scored, and if so, what to do with the score.\r\n\t\t\t\tIts a bit flag.  \r\n\t\t\t\t1\t update the comments for the node (succint). When flagged, the next option is not available.\r\n\t\t\t\t2\t update the comments for the node (verbose)\r\n\t\t\t\t4\t update the game result (RE) for the root node\r\n\t\t\t\tTypical usage: add SC[6] to the last node, and SC[2] to score a variation.\r\n\t\t\t\t*/\r\n\t\t\t\tlet updatedComment = false\r\n\t\t\t\tif (node.SC) {\r\n\t\t\t\t\tlet score = engine.score(stonesMarkedForScoring)\r\n\t\t\t\t\tif (node.SC & 1 === 1) {\r\n\t\t\t\t\t\tupdatedComment = true\r\n\t\t\t\t\t\tcomment(isPass, isBlack, score.RE)\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse /*don't want to treat succint and verbose at the same time*/ if (node.SC & 2 === 2) {\r\n\t\t\t\t\t\tupdatedComment = true\r\n\t\t\t\t\t\tcomment(isPass, isBlack,\r\n\t\t\t\t\t\t\t`Black: ${score.totalWhiteDead\r\n\t\t\t\t\t\t\t+ score.totalWhiteCaptured\r\n\t\t\t\t\t\t\t+ score.totalBlackTerritory} = ${score.totalBlackTerritory} territory + ${score.totalWhiteDead + score.totalWhiteCaptured} prisoners\r\nWhite: ${score.totalBlackDead\r\n\t\t\t\t\t\t\t+ score.totalBlackCaptured\r\n\t\t\t\t\t\t\t+ score.totalWhiteTerritory} = ${score.totalWhiteTerritory} territory + ${score.totalBlackDead + score.totalBlackCaptured} prisoners +${engine.rules.komi} komi`)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (node.SC & 4 === 4) {\r\n\t\t\t\t\t\twrappedGame.game.nodes[0].RE = score.RE\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (!updatedComment)\r\n\t\t\t\t\tcomment(isPass, isBlack)\r\n\r\n\t\t\t\t// move to next node\r\n\t\t\t\tnode = goThroughTree(state)\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (options.transformToString)\r\n\t\t\treturn smartgame.generate({ gameTrees: [wrappedGame.game] });\r\n\t\telse return wrappedGame\r\n\t}\r\n\t$.transform = transform\r\n\treturn $\r\n\r\n}\r\nmodule.exports = transformer","/* eslint-env browser */\r\n/* global GoBoardApi */\r\n/* eslint no-console: 0 */\r\ndocument.goVariantsEditor = function (editorOptions) {\r\n\teditorOptions = { rootId: 'sgfEditor', showExtras: true, ...editorOptions }\r\n\tvar { rootId, showExtras } = editorOptions\r\n\t\t, editorTemplate = require('./editor.jsx')\r\n\t\t, go_variants_transformer = require('../src/transformer')\r\n\t// document.viewer = {}\r\n\t// var viewer = document.viewer\r\n\tvar viewer = {}\r\n\tif (viewer.ran) return\r\n\tviewer.ran = true//just run this function once\r\n\r\n\tdocument.getElementById(rootId).appendChild(editorTemplate(rootId))\r\n\r\n\tvar getElementByIdSuffix = (suffix) => document.getElementById(rootId + '_' + suffix)\r\n\r\n\r\n\tgetElementByIdSuffix('updateButton').addEventListener('click', updateVariantSgf)\r\n\r\n\t\t;[].forEach.call(document.querySelectorAll(`#${rootId}_viewerControls input[type=button]`), function (el) {\r\n\t\t\tel.addEventListener('click', function (e) {\r\n\t\t\t\tvar target = e.target || e.srcElement\r\n\t\t\t\tshowBoard({ panningDirection: target.value })\r\n\t\t\t})\r\n\t\t})\r\n\r\n\tif (showExtras) {\r\n\t\t[].forEach.call(document.querySelectorAll(`#${rootId} .go-variants-extras`), function (el) {\r\n\t\t\tel.style.display = 'inline-block'\r\n\t\t})\r\n\r\n\t\t// ;/*another semicolon that's needed...*/[].forEach.call(document.querySelectorAll(`#${rootId} fieldset.go-variants-extras`), function (el) {\r\n\t\t// \tel.style.display = 'inline-block'\r\n\t\t// })\r\n\r\n\r\n\t\tlet select = getElementByIdSuffix('sizeSelect')\r\n\t\tfor (let index = 4; index < 20; index++) {\r\n\t\t\tconst option = document.createElement('option')\r\n\t\t\toption.value = '' + index\r\n\t\t\toption.appendChild(document.createTextNode(index))\r\n\t\t\tselect.appendChild(option)\r\n\t\t}\r\n\r\n\t} else {\r\n\t\t[].forEach.call(document.querySelectorAll(`#${rootId} .go-variants-extras`), function (el) {\r\n\t\t\t//el.parentNode.removeChild(el)\r\n\t\t\tel.style.display = 'none'\r\n\t\t})\r\n\t}\r\n\r\n\tgetElementByIdSuffix('goButton').addEventListener('click', function () {\r\n\t\tshowBoard()\r\n\t})\r\n\tgetElementByIdSuffix('goLgButton').addEventListener('click', function () {\r\n\t\tgetLittleGolemSgfAndShowBoard()\r\n\t})\r\n\tgetElementByIdSuffix('newButton').addEventListener('click', function () {\r\n\t\tgetElementByIdSuffix(\"sgfIn\").value = `(;GM[1]FF[4]AP[go-variants-transformer]SZ[${getElementByIdSuffix('sizeSelect').value}])`\r\n\t\tshowBoard()\r\n\t})\r\n\r\n\tgetElementByIdSuffix('viewerControls').style.display = \"none\"\r\n\r\n\t//startup\r\n\tvar inputSgfNode = document.querySelectorAll(\r\n\t\t// `#${rootId} .go-variants-data:first-of-type`)\r\n\t\t`#${rootId} .go-variants-data`)\r\n\tif (inputSgfNode.length > 0) {\r\n\t\tgetElementByIdSuffix(\"sgfIn\").value = inputSgfNode[0].innerText\r\n\r\n\t\tshowBoard()\r\n\t}\r\n\telse {\r\n\t\tlet params = new URLSearchParams((new URL(window.location)).search.slice(1))\r\n\t\tif (params.has('sgf')) {\r\n\t\t\tlet sgf = params.get('sgf')\r\n\t\t\tif (looksLikeSgf(sgf)) {\r\n\t\t\t\tgetElementByIdSuffix(\"sgfIn\").value = sgf\r\n\t\t\t\tshowBoard()\r\n\t\t\t}\r\n\t\t} else if (params.has('littlegolemid')) {\r\n\t\t\tlet id = params.get('littlegolemid')\r\n\t\t\tif (/^\\d+$/g.test(id)) {\r\n\t\t\t\tgetElementByIdSuffix('littleGolemId').value = id\r\n\t\t\t\tgetLittleGolemSgfAndShowBoard()\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n\tfunction showBoard(options) {\r\n\t\tif (options === undefined) options = {}\r\n\t\tvar { tSgf, panningDirection, moveReference, reset } = options\r\n\t\tif (reset || !viewer.offset) viewer.offset = [0, 0]\r\n\t\tif (panningDirection) {\r\n\t\t\tvar right = viewer.offset[0], up = viewer.offset[1]\r\n\t\t\tswitch (panningDirection) {\r\n\r\n\t\t\t\tcase \"\":\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tup--\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\tcase \"\":\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tup++\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\t}\r\n\t\t\t\tcase \"\":\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tright--\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\tcase \"\":\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tright++\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tviewer.offset = [right, up]\r\n\t\t}\r\n\r\n\t\tif (tSgf === undefined || tSgf === null) {\r\n\t\t\ttSgf = getElementByIdSuffix(\"sgfIn\").value\r\n\t\t}\r\n\t\tif (tSgf === '') {\r\n\t\t\tif (!viewer.warnedEmptySgf) {\r\n\t\t\t\talert('No SGF was entered, so showing a simple sample instead.')\r\n\t\t\t\tviewer.warnedEmptySgf = true\r\n\t\t\t}\r\n\t\t\ttSgf = '(;GM[1]FF[4]CA[UTF-8]AP[go-variants-transformer]ST[0]SZ[4]KM[0]HA[0]PB[Black]PW[White]C[Here is a small sample game of Toroidal Go. It ends in a seki.];B[ad];W[bd];B[bc];W[ac];B[bb];W[aa];B[ab];W[dd];B[ca];W[cd];B[db];W[dc];B[cc];MA[ba]C[Its a seki; neither player should play at X now - if they do, they put their own stones in atari. This is shown in the next two variations.]W[da](;B[ba];W[cb])(;B[];W[ba];B[ad]))'//forked from sample7\r\n\t\t\tgetElementByIdSuffix(\"sgfIn\").value = tSgf\r\n\t\t}\r\n\t\tvar wraparound = Number(getElementByIdSuffix('wraparoundSelect').value)\r\n\t\t\t, wraparoundMarkersType = Number(getElementByIdSuffix('wraparoundBorderSelect').value)\r\n\t\t\t, coordinatesType = Number(getElementByIdSuffix('coordinateSelect').value)\r\n\t\t\t, addComments = getElementByIdSuffix('addComments').checked\r\n\t\t\t, sgf = ''\r\n\t\ttry {\r\n\t\t\tvar transformer = go_variants_transformer({\r\n\t\t\t\taddComments,\r\n\t\t\t\twraparoundMarkersType,\r\n\t\t\t\tcoordinatesType,\r\n\t\t\t\tprojectionSettings: {\r\n\t\t\t\t\toffset: viewer.offset,\r\n\t\t\t\t\twraparound\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t\tsgf = transformer.transform(tSgf)\r\n\t\t\tgetElementByIdSuffix(\"sgfOut\").value = sgf\r\n\t\t\tviewer.transformer = transformer\r\n\t\t}\r\n\t\tcatch (e) {\r\n\t\t\talert('an error occurred.')\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tviewer.sgf = sgf\r\n\t\tif (!panningDirection) {\r\n\r\n\t\t\tvar oGameTree = GoBoardApi.Create_GameTree()\r\n\t\t\tviewer.oGameTree = oGameTree\r\n\r\n\t\t\tGoBoardApi.Set_OnGameTreeModifiedCallback(oGameTree, () => { })\r\n\t\t\tGoBoardApi.Toggle_Rulers(oGameTree)\r\n\t\t\tGoBoardApi.Set_DrawHandicapMarks(oGameTree, false)\r\n\t\t\tGoBoardApi.Set_CapturingMode(oGameTree, false)\r\n\r\n\t\t\tGoBoardApi.Create_BoardCommentsButtonsNavigator(oGameTree, rootId + '_' + \"playerDiv\")\r\n\t\t\t// GoBoardApi.Create_EditorVer(oGameTree, \"playerDiv\");\r\n\t\t\tif (moveReference !== undefined)\r\n\t\t\t\tGoBoardApi.Load_Sgf(viewer.oGameTree, sgf, undefined, moveReference);\r\n\t\t\telse\r\n\t\t\t\tGoBoardApi.Load_Sgf(oGameTree, sgf);\r\n\r\n\t\t\tGoBoardApi.Set_OnGameTreeModifiedCallback(oGameTree, gameTreeModifiedCallback)\r\n\r\n\t\t\twindow.onresize = function () {\r\n\t\t\t\tGoBoardApi.Update_Size(oGameTree);\r\n\t\t\t};\r\n\r\n\r\n\t\t\tgetElementByIdSuffix('viewerControls').style.display = \"inline-block\"\r\n\t\t\tgetElementByIdSuffix('updateButtonDiv').style.display = \"inline-block\"\r\n\r\n\t\t\tif (showExtras) {\r\n\t\t\t\tgetElementByIdSuffix('transformedSgfFs').style.display = \"inline-block\"\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tGoBoardApi.Set_OnGameTreeModifiedCallback(viewer.oGameTree, () => { })\r\n\t\t\tmoveReference = GoBoardApi.Get_MoveReference(viewer.oGameTree, false)\r\n\t\t\tGoBoardApi.Load_Sgf(viewer.oGameTree, sgf, undefined, moveReference)\r\n\t\t\tGoBoardApi.Set_OnGameTreeModifiedCallback(viewer.oGameTree, gameTreeModifiedCallback)\r\n\t\t\tgetElementByIdSuffix('offsetTr').innerHTML = 'panned: ['\r\n\t\t\t\t+ viewer.transformer.modX(viewer.transformer.options.projectionSettings.offset[0])\r\n\t\t\t\t+ ', ' + viewer.transformer.modY(-viewer.transformer.options.projectionSettings.offset[1]) + ']'\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction gameTreeModifiedCallback() {\r\n\t\t//when a move is played, the callback is raised twice in quick succession. We want to only do work on the second call.\r\n\t\tif (!viewer.callbackLastCalled) {\r\n\t\t\tviewer.callbackLastCalled = Date.now()\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (Date.now() - viewer.callbackLastCalled < 300) {\r\n\t\t\tupdateVariantSgf()\r\n\t\t}\r\n\t\telse viewer.callbackLastCalled = Date.now()\r\n\t}\r\n\r\n\tfunction looksLikeSgf(sgf, size) {\r\n\t\tlet result = sgf.startsWith('(')\r\n\t\t// && sgf.indexOf('GM[1]') > 0 //SGF LG doesn't!\r\n\r\n\t\tif (size) {\r\n\t\t\treturn result && sgf.indexOf(`SZ[${size}]` > 3)\r\n\t\t}\r\n\t\treturn result && /SZ\\[\\d+]/.test(sgf)\r\n\t}\r\n\tfunction updateVariantSgf() {\r\n\t\tvar sgf = GoBoardApi.Save_Sgf(viewer.oGameTree)\r\n\t\tif (sgf == viewer.sgf) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tviewer.sgf = sgf\r\n\t\tvar moveReference = GoBoardApi.Get_MoveReference(viewer.oGameTree, false)\r\n\t\t// var options = viewer.transformer.options\r\n\t\t// options.boardDimensions = options.boardDimensions.map((x) => x - 2 * options.projectionSettings.wraparound) \r\n\t\tvar tSgf = viewer.transformer.inverseTransform(sgf)\r\n\t\tgetElementByIdSuffix(\"sgfIn\").value = tSgf\r\n\t\tshowBoard({ tSgf, moveReference })\r\n\t}\r\n\r\n\tfunction getLittleGolemSgfAndShowBoard() {\r\n\t\tvar gameId = getElementByIdSuffix('littleGolemId').value\r\n\t\tif (gameId === '') {\r\n\t\t\t//gameId = '1860795'\r\n\t\t\talert('enter the ID of a game from LittleGolem, e.g. 1860795')\r\n\t\t\treturn\r\n\t\t}\r\n\t\tgameId = gameId.trim()\r\n\r\n\t\tvar proxyurl = \"https://cors-anywhere.herokuapp.com/\"\r\n\t\tvar url = `http://littlegolem.net/servlet/sgf/${gameId}/game${gameId}.sgf`\r\n\t\tif (!/^\\d+$/g.test(gameId)) {\r\n\t\t\talert('invalid ID')\r\n\t\t\treturn\r\n\t\t}\r\n\t\tgetElementByIdSuffix('goLgMsg').innerText = 'loading'\r\n\t\tvar myHeaders = new Headers({\r\n\t\t\t\"Content-Type\": \"application/sgf\"\r\n\t\t});\r\n\t\tconst failMsg = 'load from littel Golem failed'\r\n\t\tfetch(proxyurl + url, { headers: myHeaders }).then(\r\n\t\t\tfunction (response) {\r\n\t\t\t\tif (response.status !== 200) {\r\n\t\t\t\t\tconsole.log('Looks like there was a problem. Status Code: ' + response.status);\r\n\r\n\t\t\t\t\tgetElementByIdSuffix('goLgMsg').innerText = failMsg\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Examine the text in the response\r\n\t\t\t\tresponse.text().then(function (sgf) {\r\n\t\t\t\t\tif (!looksLikeSgf(sgf, 11 /*LG is always 11x11*/)) {\r\n\t\t\t\t\t\tconsole.log('invalid SGF. Received:' + sgf)\r\n\r\n\t\t\t\t\t\tgetElementByIdSuffix('goLgMsg').innerText = failMsg\r\n\t\t\t\t\t\treturn\r\n\t\t\t\t\t}\r\n\t\t\t\t\tsgf = sgf.replace('SZ[11]', `SZ[11]SO[http://littlegolem.net/jsp/game/game.jsp?gid=${gameId}`)\r\n\r\n\t\t\t\t\tgetElementByIdSuffix(\"sgfIn\").value = sgf\r\n\t\t\t\t\tshowBoard()\r\n\r\n\t\t\t\t\tgetElementByIdSuffix('goLgMsg').innerText = 'game loaded from Little Golem'\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t).catch(function (err) {\r\n\t\t\tconsole.log('Fetch Error :-S', err);\r\n\t\t});\r\n\t}\r\n\r\n\r\n\r\n\r\n}\r\ndocument.addEventListener('DOMContentLoaded', function () {\r\n\t[].forEach.call(document.querySelectorAll('.go-variants-editor'), function (el) {\r\n\t\tvar options = { rootId: el.id }\r\n\t\tif (el.classList.contains('go-variants-hide-extras')) {\r\n\t\t\toptions.showExtras = false\r\n\t\t}\r\n\t\tdocument.goVariantsEditor(options)\r\n\t})\r\n})","module.exports = (rootId) =>\r\n    <div>\r\n\r\n        <style type=\"text/css\">\r\n            {`#${rootId}\r\n.masonry {\r\n    -moz-column-count: 3;\r\n    -webkit-column-count: 3;\r\n    column-count: 3;\r\n    column-gap: 1em;\r\n}\r\n.item {\r\n    background-color: #fff;\r\n    display: inline-block;\r\n    margin: 0 0 1em;\r\n    \r\n    padding: 2px;\r\n    border: 1px black solid;\r\n    width: 100%;\r\n}\r\n}\r\n.go-variants-extras {\r\ndisplay: none !important;\r\n}`}\r\n        </style>\r\n        <div class=\"masonry\">\r\n            <div class=\"item go-variants-extras\">\r\n                Paste the SGF for a game of toroidal Go, (e.g. from Little Golem) in the box, and then push the button to view the game!\r\n            <br /><label for={`${rootId}_sgfIn`}>T-Go SGF:</label>\r\n                <textarea id={`${rootId}_sgfIn`} rows=\"3\"></textarea>\r\n                <input type=\"button\" id={`${rootId}_goButton`} value=\"show board (from t-Go SGF)\" />\r\n\r\n            </div>\r\n\r\n            <div class=\"item go-variants-extras\">\r\n                <label for={`${rootId}_littleGolemId`}>LittleGolem game ID:</label>\r\n                <input id={`${rootId}_littleGolemId`} type=\"text\"></input>\r\n                <input type=\"button\" id={`${rootId}_goLgButton`} value=\"show board (from littleGolem game ID)\" /><span id={`${rootId}_goLgMsg`} />\r\n            </div>\r\n\r\n            <div class=\"item go-variants-extras\">\r\n                <label for={`${rootId}_sizeSelect`}>Size:</label>\r\n                <select id={`${rootId}_sizeSelect`}>\r\n                    {/* options filled by editor.js */}\r\n                </select>\r\n                <input type=\"button\" id={`${rootId}_newButton`} value=\"New game\" />\r\n            </div>\r\n            <div style=\"display: none\" id={`${rootId}_transformedSgfFs`} class=\"item go-variants-extras\">\r\n                <label for={`${rootId}_sgfOut`}>Transformed SGF:</label>\r\n                <textarea id={`${rootId}_sgfOut`} rows=\"3\"></textarea>\r\n            </div>\r\n            <div id={`${rootId}_viewerControls`} style=\"display:none\" class=\"item\">\r\n\r\n                <table title=\"panning\" style=\"float:left\">\r\n                    <tr>\r\n                        <td colspan=\"2\" style=\"text-align: center\">\r\n                            <input type=\"button\" value=\"\" />\r\n                        </td>\r\n                        <td rowspan=\"4\" style=\"vertical-align: middle\">Panning\r\n                <p> Use the buttons to the left to pan the board.</p>\r\n                        </td>\r\n                    </tr>\r\n                    <tr>\r\n                        <td>\r\n                            <input type=\"button\" value=\"\" />\r\n                        </td>\r\n                        <td>\r\n                            <input type=\"button\" value=\"\" />\r\n                        </td>\r\n                    </tr>\r\n                    <tr>\r\n                        <td colspan=\"2\" style=\"text-align: center\">\r\n                            <input type=\"button\" value=\"\" />\r\n                        </td>\r\n                    </tr>\r\n                    <tr>\r\n                        <td colspan=\"2\" style=\"text-align: center; font-size: small\" id={`${rootId}_offsetTr`} >\r\n                            panned: [0,0]\r\n            </td>\r\n                    </tr>\r\n                </table>\r\n            </div>\r\n            <div class=\"item\">\r\n                <label for={`${rootId}_wraparoundSelect`}>number of wraparound lines to add:</label>\r\n                <select id={`${rootId}_wraparoundSelect`}>\r\n                    <option value=\"0\">0</option>\r\n                    <option value=\"1\">1</option>\r\n                    <option value=\"2\">2</option>\r\n                    <option value=\"3\">3</option>\r\n                    <option value=\"4\" selected>4</option>\r\n                    <option value=\"5\">5</option>\r\n                    <option value=\"6\">6</option>\r\n                    <option value=\"7\">7</option>\r\n\r\n                </select>\r\n                <br />\r\n                <label for=\"addComments\">add comments:</label>\r\n                <input type=\"checkbox\" id={`${rootId}_addComments`} />\r\n                <br />\r\n                <label for={`${rootId}_wraparoundBorderSelect`}>Type of border for wraparound:</label>\r\n                <select id={`${rootId}_wraparoundBorderSelect`}>\r\n                    <option value=\"0\">No border</option>\r\n                    <option value=\"1\" selected>Full border</option>\r\n                    <option value=\"2\">Partial border (corners &amp; middles)</option>\r\n                    <option value=\"3\">Just corners</option>\r\n                    <option value=\"4\">Just middles</option>\r\n                </select>\r\n                <br />\r\n                <label for={`${rootId}_coordinateSelect`}>Type of coordinates:</label>\r\n                <select id={`${rootId}_coordinateSelect`}>\r\n                    <option value=\"0\" selected>None</option>\r\n                    <option value=\"1\">(;A|1-K|11): Western</option>\r\n                    <option value=\"2\">(;A|1-L|11): Western, no I</option>\r\n                    <option value=\"3\">(;1|1-11|11): Latin/Latin, top to bottom</option>\r\n                    <option value=\"4\">(;1|1-11|): Latin/Chinese, top to bottom</option>\r\n                </select>\r\n                <br />\r\n                <div id={`${rootId}_updateButtonDiv`} style=\"display:none\">\r\n                    <input type=\"button\" id={`${rootId}_updateButton`} value=\"update (from board)\" /> Press this button after adding marks to the board position in order to get the wraparound effect.\r\n                </div>\r\n            </div>\r\n\r\n        </div>\r\n        <div id={`${rootId}_playerDiv`} style=\"position:relative; height: 75vh;width: 85vw\"></div>\r\n    </div>"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0RhdGFWaWV3LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19IYXNoLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19MaXN0Q2FjaGUuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX01hcC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fTWFwQ2FjaGUuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1Byb21pc2UuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1NldC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fU2V0Q2FjaGUuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1N0YWNrLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19TeW1ib2wuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1VpbnQ4QXJyYXkuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1dlYWtNYXAuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FkZE1hcEVudHJ5LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19hZGRTZXRFbnRyeS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlFYWNoLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUZpbHRlci5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlMaWtlS2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlNYXAuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5UHVzaC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlSZWR1Y2UuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5U29tZS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXNzaWduVmFsdWUuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Fzc29jSW5kZXhPZi5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUFzc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUFzc2lnbkluLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQXNzaWduVmFsdWUuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VDbG9uZS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZpbmRJbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldEFsbEtleXMuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXRUYWcuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VIYXNJbi5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzQXJndW1lbnRzLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNFcXVhbC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzRXF1YWxEZWVwLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNNYXRjaC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzTmF0aXZlLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNUeXBlZEFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXRlcmF0ZWUuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VLZXlzLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlS2V5c0luLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWF0Y2hlcy5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZU1hdGNoZXNQcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUHJvcGVydHlEZWVwLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVGltZXMuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VUb1N0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVVuYXJ5LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19jYWNoZUhhcy5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2FzdFBhdGguanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lQXJyYXlCdWZmZXIuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lQnVmZmVyLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZURhdGFWaWV3LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZU1hcC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVSZWdFeHAuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lU2V0LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZVN5bWJvbC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVUeXBlZEFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5QXJyYXkuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlPYmplY3QuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlTeW1ib2xzLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5U3ltYm9sc0luLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3JlSnNEYXRhLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19kZWZpbmVQcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZXF1YWxBcnJheXMuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2VxdWFsQnlUYWcuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2VxdWFsT2JqZWN0cy5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZnJlZUdsb2JhbC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0QWxsS2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0QWxsS2V5c0luLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRNYXBEYXRhLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRNYXRjaERhdGEuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldE5hdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0UHJvdG90eXBlLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRSYXdUYWcuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFN5bWJvbHMuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFN5bWJvbHNJbi5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0VGFnLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRWYWx1ZS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzUGF0aC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaENsZWFyLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoRGVsZXRlLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoR2V0LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoSGFzLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoU2V0LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19pbml0Q2xvbmVBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9faW5pdENsb25lQnlUYWcuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2luaXRDbG9uZU9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNJbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNLZXkuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzS2V5YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNNYXNrZWQuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzUHJvdG90eXBlLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19pc1N0cmljdENvbXBhcmFibGUuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUNsZWFyLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVEZWxldGUuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUdldC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlSGFzLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVTZXQuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlQ2xlYXIuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlRGVsZXRlLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUdldC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVIYXMuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlU2V0LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBUb0FycmF5LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWVtb2l6ZUNhcHBlZC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlQ3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVLZXlzLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVLZXlzSW4uanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25vZGVVdGlsLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19vYmplY3RUb1N0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fb3ZlckFyZy5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fcm9vdC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2V0Q2FjaGVBZGQuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldENhY2hlSGFzLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRUb0FycmF5LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0NsZWFyLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0RlbGV0ZS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tHZXQuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrSGFzLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja1NldC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RyaW5nVG9QYXRoLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL190b0tleS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fdG9Tb3VyY2UuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvY2xvbmUuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvZXEuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvZmluZEluZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL2dldC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9oYXNJbi5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9pZGVudGl0eS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FyZ3VtZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXlMaWtlLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQnVmZmVyLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL2lzRnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNMZW5ndGguanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3QuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3RMaWtlLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL2lzU3ltYm9sLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL2lzVHlwZWRBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL2tleXNJbi5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9tZW1vaXplLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL3Byb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL3N0dWJBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9zdHViRmFsc2UuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvdG9GaW5pdGUuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvdG9JbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL3RvTnVtYmVyLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL3RvU3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9zcmMvZW5naW5lLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlJbmNsdWRlcy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5SW5jbHVkZXNXaXRoLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZsYXR0ZW4uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSW5kZXhPZi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc05hTi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VVbmlxLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlU2V0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZnJlZUdsb2JhbC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzRmxhdHRlbmFibGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19zdHJpY3RJbmRleE9mLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9mbGF0dGVuLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9ub29wLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC91bmlxQnkuanMiLCJub2RlX21vZHVsZXMvc21hcnRnYW1lL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NtYXJ0Z2FtZXIvaW5kZXguanMiLCJzcmMvdHJhbnNmb3JtZXIuanMiLCJ1aS9lZGl0b3IuanMiLCJ1aS9lZGl0b3IuanN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDek1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFBO0FBQUEsc0JBQVEsSUFBTyxNQUFQLHNCQUFSO0FBQ0k7QUFBQTtBQUFBLDBCQUFRLE9BQU0sR0FBZCxFQUFrQixjQUFsQjtBQUFBO0FBQUEscUJBREo7QUFFSTtBQUFBO0FBQUEsMEJBQVEsT0FBTSxHQUFkO0FBQUE7QUFBQSxxQkFGSjtBQUdJO0FBQUE7QUFBQSwwQkFBUSxPQUFNLEdBQWQ7QUFBQTtBQUFBLHFCQUhKO0FBSUk7QUFBQTtBQUFBLDBCQUFRLE9BQU0sR0FBZDtBQUFBO0FBQUEscUJBSko7QUFLSTtBQUFBO0FBQUEsMEJBQVEsT0FBTSxHQUFkO0FBQUE7QUFBQTtBQUxKLGlCQTNCSjtBQWtDSSwrQ0FsQ0o7QUFtQ0k7QUFBQTtBQUFBLHNCQUFLLElBQU8sTUFBUCxxQkFBTCxFQUFzQyxPQUFNLGNBQTVDO0FBQ0ksbURBQU8sTUFBSyxRQUFaLEVBQXFCLElBQU8sTUFBUCxrQkFBckIsRUFBbUQsT0FBTSxxQkFBekQsR0FESjtBQUFBO0FBQUE7QUFuQ0o7QUF6REosU0F4Qko7QUEwSEkscUNBQUssSUFBTyxNQUFQLGVBQUwsRUFBZ0MsT0FBTSw2Q0FBdEM7QUExSEosS0FEYTtBQUFBLENBQWpCIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgRGF0YVZpZXcgPSBnZXROYXRpdmUocm9vdCwgJ0RhdGFWaWV3Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YVZpZXc7XG4iLCJ2YXIgaGFzaENsZWFyID0gcmVxdWlyZSgnLi9faGFzaENsZWFyJyksXG4gICAgaGFzaERlbGV0ZSA9IHJlcXVpcmUoJy4vX2hhc2hEZWxldGUnKSxcbiAgICBoYXNoR2V0ID0gcmVxdWlyZSgnLi9faGFzaEdldCcpLFxuICAgIGhhc2hIYXMgPSByZXF1aXJlKCcuL19oYXNoSGFzJyksXG4gICAgaGFzaFNldCA9IHJlcXVpcmUoJy4vX2hhc2hTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG5IYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbkhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG5IYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbkhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gSGFzaDtcbiIsInZhciBsaXN0Q2FjaGVDbGVhciA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUNsZWFyJyksXG4gICAgbGlzdENhY2hlRGVsZXRlID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlRGVsZXRlJyksXG4gICAgbGlzdENhY2hlR2V0ID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlR2V0JyksXG4gICAgbGlzdENhY2hlSGFzID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlSGFzJyksXG4gICAgbGlzdENhY2hlU2V0ID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBMaXN0Q2FjaGU7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIE1hcCA9IGdldE5hdGl2ZShyb290LCAnTWFwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwO1xuIiwidmFyIG1hcENhY2hlQ2xlYXIgPSByZXF1aXJlKCcuL19tYXBDYWNoZUNsZWFyJyksXG4gICAgbWFwQ2FjaGVEZWxldGUgPSByZXF1aXJlKCcuL19tYXBDYWNoZURlbGV0ZScpLFxuICAgIG1hcENhY2hlR2V0ID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVHZXQnKSxcbiAgICBtYXBDYWNoZUhhcyA9IHJlcXVpcmUoJy4vX21hcENhY2hlSGFzJyksXG4gICAgbWFwQ2FjaGVTZXQgPSByZXF1aXJlKCcuL19tYXBDYWNoZVNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbk1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbk1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcbk1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbk1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXBDYWNoZTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgUHJvbWlzZSA9IGdldE5hdGl2ZShyb290LCAnUHJvbWlzZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb21pc2U7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFNldCA9IGdldE5hdGl2ZShyb290LCAnU2V0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2V0O1xuIiwidmFyIE1hcENhY2hlID0gcmVxdWlyZSgnLi9fTWFwQ2FjaGUnKSxcbiAgICBzZXRDYWNoZUFkZCA9IHJlcXVpcmUoJy4vX3NldENhY2hlQWRkJyksXG4gICAgc2V0Q2FjaGVIYXMgPSByZXF1aXJlKCcuL19zZXRDYWNoZUhhcycpO1xuXG4vKipcbiAqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNhY2hlIG9iamVjdCB0byBzdG9yZSB1bmlxdWUgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFNldENhY2hlKHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcyA9PSBudWxsID8gMCA6IHZhbHVlcy5sZW5ndGg7XG5cbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU2V0Q2FjaGVgLlxuU2V0Q2FjaGUucHJvdG90eXBlLmFkZCA9IFNldENhY2hlLnByb3RvdHlwZS5wdXNoID0gc2V0Q2FjaGVBZGQ7XG5TZXRDYWNoZS5wcm90b3R5cGUuaGFzID0gc2V0Q2FjaGVIYXM7XG5cbm1vZHVsZS5leHBvcnRzID0gU2V0Q2FjaGU7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgc3RhY2tDbGVhciA9IHJlcXVpcmUoJy4vX3N0YWNrQ2xlYXInKSxcbiAgICBzdGFja0RlbGV0ZSA9IHJlcXVpcmUoJy4vX3N0YWNrRGVsZXRlJyksXG4gICAgc3RhY2tHZXQgPSByZXF1aXJlKCcuL19zdGFja0dldCcpLFxuICAgIHN0YWNrSGFzID0gcmVxdWlyZSgnLi9fc3RhY2tIYXMnKSxcbiAgICBzdGFja1NldCA9IHJlcXVpcmUoJy4vX3N0YWNrU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcblN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcblN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcblN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcblN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxubW9kdWxlLmV4cG9ydHMgPSBTdGFjaztcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW1ib2w7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgVWludDhBcnJheSA9IHJvb3QuVWludDhBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBVaW50OEFycmF5O1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBXZWFrTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdXZWFrTWFwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gV2Vha01hcDtcbiIsIi8qKlxuICogQWRkcyB0aGUga2V5LXZhbHVlIGBwYWlyYCB0byBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHBhaXIgVGhlIGtleS12YWx1ZSBwYWlyIHRvIGFkZC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG1hcGAuXG4gKi9cbmZ1bmN0aW9uIGFkZE1hcEVudHJ5KG1hcCwgcGFpcikge1xuICAvLyBEb24ndCByZXR1cm4gYG1hcC5zZXRgIGJlY2F1c2UgaXQncyBub3QgY2hhaW5hYmxlIGluIElFIDExLlxuICBtYXAuc2V0KHBhaXJbMF0sIHBhaXJbMV0pO1xuICByZXR1cm4gbWFwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFkZE1hcEVudHJ5O1xuIiwiLyoqXG4gKiBBZGRzIGB2YWx1ZWAgdG8gYHNldGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBtb2RpZnkuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhZGQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBzZXRgLlxuICovXG5mdW5jdGlvbiBhZGRTZXRFbnRyeShzZXQsIHZhbHVlKSB7XG4gIC8vIERvbid0IHJldHVybiBgc2V0LmFkZGAgYmVjYXVzZSBpdCdzIG5vdCBjaGFpbmFibGUgaW4gSUUgMTEuXG4gIHNldC5hZGQodmFsdWUpO1xuICByZXR1cm4gc2V0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFkZFNldEVudHJ5O1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZm9yRWFjaGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RWFjaChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkgPT09IGZhbHNlKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5RWFjaDtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZpbHRlcmAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheUZpbHRlcihhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXNJbmRleCA9IDAsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUZpbHRlcjtcbiIsInZhciBiYXNlVGltZXMgPSByZXF1aXJlKCcuL19iYXNlVGltZXMnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlMaWtlS2V5cztcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlNYXA7XG4iLCIvKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlQdXNoO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucmVkdWNlYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0QWNjdW1dIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YCBhc1xuICogIHRoZSBpbml0aWFsIHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBhcnJheVJlZHVjZShhcnJheSwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0pIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICBpZiAoaW5pdEFjY3VtICYmIGxlbmd0aCkge1xuICAgIGFjY3VtdWxhdG9yID0gYXJyYXlbKytpbmRleF07XG4gIH1cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5UmVkdWNlO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc29tZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5U29tZShhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheVNvbWU7XG4iLCJ2YXIgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnblZhbHVlJyksXG4gICAgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gIGlmICghKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGVxKG9ialZhbHVlLCB2YWx1ZSkpIHx8XG4gICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzaWduVmFsdWU7XG4iLCJ2YXIgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzb2NJbmRleE9mO1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gKiBvciBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnbihvYmplY3QsIHNvdXJjZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUFzc2lnbjtcbiIsInZhciBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4va2V5c0luJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ25JbihvYmplY3QsIHNvdXJjZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQXNzaWduSW47XG4iLCJ2YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19kZWZpbmVQcm9wZXJ0eScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBhc3NpZ25WYWx1ZWAgYW5kIGBhc3NpZ25NZXJnZVZhbHVlYCB3aXRob3V0XG4gKiB2YWx1ZSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5ID09ICdfX3Byb3RvX18nICYmIGRlZmluZVByb3BlcnR5KSB7XG4gICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgJ2VudW1lcmFibGUnOiB0cnVlLFxuICAgICAgJ3ZhbHVlJzogdmFsdWUsXG4gICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBc3NpZ25WYWx1ZTtcbiIsInZhciBTdGFjayA9IHJlcXVpcmUoJy4vX1N0YWNrJyksXG4gICAgYXJyYXlFYWNoID0gcmVxdWlyZSgnLi9fYXJyYXlFYWNoJyksXG4gICAgYXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25WYWx1ZScpLFxuICAgIGJhc2VBc3NpZ24gPSByZXF1aXJlKCcuL19iYXNlQXNzaWduJyksXG4gICAgYmFzZUFzc2lnbkluID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnbkluJyksXG4gICAgY2xvbmVCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUJ1ZmZlcicpLFxuICAgIGNvcHlBcnJheSA9IHJlcXVpcmUoJy4vX2NvcHlBcnJheScpLFxuICAgIGNvcHlTeW1ib2xzID0gcmVxdWlyZSgnLi9fY29weVN5bWJvbHMnKSxcbiAgICBjb3B5U3ltYm9sc0luID0gcmVxdWlyZSgnLi9fY29weVN5bWJvbHNJbicpLFxuICAgIGdldEFsbEtleXMgPSByZXF1aXJlKCcuL19nZXRBbGxLZXlzJyksXG4gICAgZ2V0QWxsS2V5c0luID0gcmVxdWlyZSgnLi9fZ2V0QWxsS2V5c0luJyksXG4gICAgZ2V0VGFnID0gcmVxdWlyZSgnLi9fZ2V0VGFnJyksXG4gICAgaW5pdENsb25lQXJyYXkgPSByZXF1aXJlKCcuL19pbml0Q2xvbmVBcnJheScpLFxuICAgIGluaXRDbG9uZUJ5VGFnID0gcmVxdWlyZSgnLi9faW5pdENsb25lQnlUYWcnKSxcbiAgICBpbml0Q2xvbmVPYmplY3QgPSByZXF1aXJlKCcuL19pbml0Q2xvbmVPYmplY3QnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xudmFyIENMT05FX0RFRVBfRkxBRyA9IDEsXG4gICAgQ0xPTkVfRkxBVF9GTEFHID0gMixcbiAgICBDTE9ORV9TWU1CT0xTX0ZMQUcgPSA0O1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIHN1cHBvcnRlZCBieSBgXy5jbG9uZWAuICovXG52YXIgY2xvbmVhYmxlVGFncyA9IHt9O1xuY2xvbmVhYmxlVGFnc1thcmdzVGFnXSA9IGNsb25lYWJsZVRhZ3NbYXJyYXlUYWddID1cbmNsb25lYWJsZVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRhVmlld1RhZ10gPVxuY2xvbmVhYmxlVGFnc1tib29sVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0ZVRhZ10gPVxuY2xvbmVhYmxlVGFnc1tmbG9hdDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZmxvYXQ2NFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbaW50MTZUYWddID1cbmNsb25lYWJsZVRhZ3NbaW50MzJUYWddID0gY2xvbmVhYmxlVGFnc1ttYXBUYWddID1cbmNsb25lYWJsZVRhZ3NbbnVtYmVyVGFnXSA9IGNsb25lYWJsZVRhZ3Nbb2JqZWN0VGFnXSA9XG5jbG9uZWFibGVUYWdzW3JlZ2V4cFRhZ10gPSBjbG9uZWFibGVUYWdzW3NldFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tzdHJpbmdUYWddID0gY2xvbmVhYmxlVGFnc1tzeW1ib2xUYWddID1cbmNsb25lYWJsZVRhZ3NbdWludDhUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50OENsYW1wZWRUYWddID1cbmNsb25lYWJsZVRhZ3NbdWludDE2VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG5jbG9uZWFibGVUYWdzW2Vycm9yVGFnXSA9IGNsb25lYWJsZVRhZ3NbZnVuY1RhZ10gPVxuY2xvbmVhYmxlVGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsb25lYCBhbmQgYF8uY2xvbmVEZWVwYCB3aGljaCB0cmFja3NcbiAqIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gRGVlcCBjbG9uZVxuICogIDIgLSBGbGF0dGVuIGluaGVyaXRlZCBwcm9wZXJ0aWVzXG4gKiAgNCAtIENsb25lIHN5bWJvbHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2tleV0gVGhlIGtleSBvZiBgdmFsdWVgLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBwYXJlbnQgb2JqZWN0IG9mIGB2YWx1ZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIG9iamVjdHMgYW5kIHRoZWlyIGNsb25lIGNvdW50ZXJwYXJ0cy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VDbG9uZSh2YWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCBvYmplY3QsIHN0YWNrKSB7XG4gIHZhciByZXN1bHQsXG4gICAgICBpc0RlZXAgPSBiaXRtYXNrICYgQ0xPTkVfREVFUF9GTEFHLFxuICAgICAgaXNGbGF0ID0gYml0bWFzayAmIENMT05FX0ZMQVRfRkxBRyxcbiAgICAgIGlzRnVsbCA9IGJpdG1hc2sgJiBDTE9ORV9TWU1CT0xTX0ZMQUc7XG5cbiAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICByZXN1bHQgPSBvYmplY3QgPyBjdXN0b21pemVyKHZhbHVlLCBrZXksIG9iamVjdCwgc3RhY2spIDogY3VzdG9taXplcih2YWx1ZSk7XG4gIH1cbiAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKTtcbiAgaWYgKGlzQXJyKSB7XG4gICAgcmVzdWx0ID0gaW5pdENsb25lQXJyYXkodmFsdWUpO1xuICAgIGlmICghaXNEZWVwKSB7XG4gICAgICByZXR1cm4gY29weUFycmF5KHZhbHVlLCByZXN1bHQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKSxcbiAgICAgICAgaXNGdW5jID0gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcblxuICAgIGlmIChpc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjbG9uZUJ1ZmZlcih2YWx1ZSwgaXNEZWVwKTtcbiAgICB9XG4gICAgaWYgKHRhZyA9PSBvYmplY3RUYWcgfHwgdGFnID09IGFyZ3NUYWcgfHwgKGlzRnVuYyAmJiAhb2JqZWN0KSkge1xuICAgICAgcmVzdWx0ID0gKGlzRmxhdCB8fCBpc0Z1bmMpID8ge30gOiBpbml0Q2xvbmVPYmplY3QodmFsdWUpO1xuICAgICAgaWYgKCFpc0RlZXApIHtcbiAgICAgICAgcmV0dXJuIGlzRmxhdFxuICAgICAgICAgID8gY29weVN5bWJvbHNJbih2YWx1ZSwgYmFzZUFzc2lnbkluKHJlc3VsdCwgdmFsdWUpKVxuICAgICAgICAgIDogY29weVN5bWJvbHModmFsdWUsIGJhc2VBc3NpZ24ocmVzdWx0LCB2YWx1ZSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWNsb25lYWJsZVRhZ3NbdGFnXSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0ID8gdmFsdWUgOiB7fTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGluaXRDbG9uZUJ5VGFnKHZhbHVlLCB0YWcsIGJhc2VDbG9uZSwgaXNEZWVwKTtcbiAgICB9XG4gIH1cbiAgLy8gQ2hlY2sgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMgYW5kIHJldHVybiBpdHMgY29ycmVzcG9uZGluZyBjbG9uZS5cbiAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQodmFsdWUpO1xuICBpZiAoc3RhY2tlZCkge1xuICAgIHJldHVybiBzdGFja2VkO1xuICB9XG4gIHN0YWNrLnNldCh2YWx1ZSwgcmVzdWx0KTtcblxuICB2YXIga2V5c0Z1bmMgPSBpc0Z1bGxcbiAgICA/IChpc0ZsYXQgPyBnZXRBbGxLZXlzSW4gOiBnZXRBbGxLZXlzKVxuICAgIDogKGlzRmxhdCA/IGtleXNJbiA6IGtleXMpO1xuXG4gIHZhciBwcm9wcyA9IGlzQXJyID8gdW5kZWZpbmVkIDoga2V5c0Z1bmModmFsdWUpO1xuICBhcnJheUVhY2gocHJvcHMgfHwgdmFsdWUsIGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgIGtleSA9IHN1YlZhbHVlO1xuICAgICAgc3ViVmFsdWUgPSB2YWx1ZVtrZXldO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBwb3B1bGF0ZSBjbG9uZSAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCBiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgdmFsdWUsIHN0YWNrKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VDbG9uZTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xudmFyIGJhc2VDcmVhdGUgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIG9iamVjdCgpIHt9XG4gIHJldHVybiBmdW5jdGlvbihwcm90bykge1xuICAgIGlmICghaXNPYmplY3QocHJvdG8pKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGlmIChvYmplY3RDcmVhdGUpIHtcbiAgICAgIHJldHVybiBvYmplY3RDcmVhdGUocHJvdG8pO1xuICAgIH1cbiAgICBvYmplY3QucHJvdG90eXBlID0gcHJvdG87XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBvYmplY3Q7XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ3JlYXRlO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maW5kSW5kZXhgIGFuZCBgXy5maW5kTGFzdEluZGV4YCB3aXRob3V0XG4gKiBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4LCBmcm9tUmlnaHQpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIGluZGV4ID0gZnJvbUluZGV4ICsgKGZyb21SaWdodCA/IDEgOiAtMSk7XG5cbiAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZpbmRJbmRleDtcbiIsInZhciBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWZhdWx0IHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldChvYmplY3QsIHBhdGgpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gMCxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgIG9iamVjdCA9IG9iamVjdFt0b0tleShwYXRoW2luZGV4KytdKV07XG4gIH1cbiAgcmV0dXJuIChpbmRleCAmJiBpbmRleCA9PSBsZW5ndGgpID8gb2JqZWN0IDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXQ7XG4iLCJ2YXIgYXJyYXlQdXNoID0gcmVxdWlyZSgnLi9fYXJyYXlQdXNoJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRBbGxLZXlzYCBhbmQgYGdldEFsbEtleXNJbmAgd2hpY2ggdXNlc1xuICogYGtleXNGdW5jYCBhbmQgYHN5bWJvbHNGdW5jYCB0byBnZXQgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3ltYm9sc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XG4gIHZhciByZXN1bHQgPSBrZXlzRnVuYyhvYmplY3QpO1xuICByZXR1cm4gaXNBcnJheShvYmplY3QpID8gcmVzdWx0IDogYXJyYXlQdXNoKHJlc3VsdCwgc3ltYm9sc0Z1bmMob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldEFsbEtleXM7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgZ2V0UmF3VGFnID0gcmVxdWlyZSgnLi9fZ2V0UmF3VGFnJyksXG4gICAgb2JqZWN0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19vYmplY3RUb1N0cmluZycpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0VGFnO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNJbmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUhhc0luKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBrZXkgaW4gT2JqZWN0KG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUhhc0luO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICovXG5mdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNBcmd1bWVudHM7XG4iLCJ2YXIgYmFzZUlzRXF1YWxEZWVwID0gcmVxdWlyZSgnLi9fYmFzZUlzRXF1YWxEZWVwJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0VxdWFsYCB3aGljaCBzdXBwb3J0cyBwYXJ0aWFsIGNvbXBhcmlzb25zXG4gKiBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gVW5vcmRlcmVkIGNvbXBhcmlzb25cbiAqICAyIC0gUGFydGlhbCBjb21wYXJpc29uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykge1xuICBpZiAodmFsdWUgPT09IG90aGVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgfHwgb3RoZXIgPT0gbnVsbCB8fCAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzT2JqZWN0TGlrZShvdGhlcikpKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gIH1cbiAgcmV0dXJuIGJhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGJhc2VJc0VxdWFsLCBzdGFjayk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzRXF1YWw7XG4iLCJ2YXIgU3RhY2sgPSByZXF1aXJlKCcuL19TdGFjaycpLFxuICAgIGVxdWFsQXJyYXlzID0gcmVxdWlyZSgnLi9fZXF1YWxBcnJheXMnKSxcbiAgICBlcXVhbEJ5VGFnID0gcmVxdWlyZSgnLi9fZXF1YWxCeVRhZycpLFxuICAgIGVxdWFsT2JqZWN0cyA9IHJlcXVpcmUoJy4vX2VxdWFsT2JqZWN0cycpLFxuICAgIGdldFRhZyA9IHJlcXVpcmUoJy4vX2dldFRhZycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDE7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAqIGRlZXAgY29tcGFyaXNvbnMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsRGVlcChvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBvYmpJc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgIG90aElzQXJyID0gaXNBcnJheShvdGhlciksXG4gICAgICBvYmpUYWcgPSBvYmpJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG9iamVjdCksXG4gICAgICBvdGhUYWcgPSBvdGhJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG90aGVyKTtcblxuICBvYmpUYWcgPSBvYmpUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG9ialRhZztcbiAgb3RoVGFnID0gb3RoVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvdGhUYWc7XG5cbiAgdmFyIG9iaklzT2JqID0gb2JqVGFnID09IG9iamVjdFRhZyxcbiAgICAgIG90aElzT2JqID0gb3RoVGFnID09IG9iamVjdFRhZyxcbiAgICAgIGlzU2FtZVRhZyA9IG9ialRhZyA9PSBvdGhUYWc7XG5cbiAgaWYgKGlzU2FtZVRhZyAmJiBpc0J1ZmZlcihvYmplY3QpKSB7XG4gICAgaWYgKCFpc0J1ZmZlcihvdGhlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgb2JqSXNBcnIgPSB0cnVlO1xuICAgIG9iaklzT2JqID0gZmFsc2U7XG4gIH1cbiAgaWYgKGlzU2FtZVRhZyAmJiAhb2JqSXNPYmopIHtcbiAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgIHJldHVybiAob2JqSXNBcnIgfHwgaXNUeXBlZEFycmF5KG9iamVjdCkpXG4gICAgICA/IGVxdWFsQXJyYXlzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spXG4gICAgICA6IGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgb2JqVGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgfVxuICBpZiAoIShiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcpKSB7XG4gICAgdmFyIG9iaklzV3JhcHBlZCA9IG9iaklzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnX193cmFwcGVkX18nKSxcbiAgICAgICAgb3RoSXNXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwgJ19fd3JhcHBlZF9fJyk7XG5cbiAgICBpZiAob2JqSXNXcmFwcGVkIHx8IG90aElzV3JhcHBlZCkge1xuICAgICAgdmFyIG9ialVud3JhcHBlZCA9IG9iaklzV3JhcHBlZCA/IG9iamVjdC52YWx1ZSgpIDogb2JqZWN0LFxuICAgICAgICAgIG90aFVud3JhcHBlZCA9IG90aElzV3JhcHBlZCA/IG90aGVyLnZhbHVlKCkgOiBvdGhlcjtcblxuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgIHJldHVybiBlcXVhbEZ1bmMob2JqVW53cmFwcGVkLCBvdGhVbndyYXBwZWQsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFpc1NhbWVUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgcmV0dXJuIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNFcXVhbERlZXA7XG4iLCJ2YXIgU3RhY2sgPSByZXF1aXJlKCcuL19TdGFjaycpLFxuICAgIGJhc2VJc0VxdWFsID0gcmVxdWlyZSgnLi9fYmFzZUlzRXF1YWwnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWF0Y2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtBcnJheX0gbWF0Y2hEYXRhIFRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSwgY3VzdG9taXplcikge1xuICB2YXIgaW5kZXggPSBtYXRjaERhdGEubGVuZ3RoLFxuICAgICAgbGVuZ3RoID0gaW5kZXgsXG4gICAgICBub0N1c3RvbWl6ZXIgPSAhY3VzdG9taXplcjtcblxuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gIWxlbmd0aDtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgaWYgKChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSlcbiAgICAgICAgICA/IGRhdGFbMV0gIT09IG9iamVjdFtkYXRhWzBdXVxuICAgICAgICAgIDogIShkYXRhWzBdIGluIG9iamVjdClcbiAgICAgICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgdmFyIGtleSA9IGRhdGFbMF0sXG4gICAgICAgIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIHNyY1ZhbHVlID0gZGF0YVsxXTtcblxuICAgIGlmIChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSkge1xuICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdGFjayA9IG5ldyBTdGFjaztcbiAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKCEocmVzdWx0ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcsIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICAgICAgOiByZXN1bHRcbiAgICAgICAgICApKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTWF0Y2g7XG4iLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzTWFza2VkID0gcmVxdWlyZSgnLi9faXNNYXNrZWQnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICB0b1NvdXJjZSA9IHJlcXVpcmUoJy4vX3RvU291cmNlJyk7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gaXNGdW5jdGlvbih2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTmF0aXZlO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc1R5cGVkQXJyYXk7XG4iLCJ2YXIgYmFzZU1hdGNoZXMgPSByZXF1aXJlKCcuL19iYXNlTWF0Y2hlcycpLFxuICAgIGJhc2VNYXRjaGVzUHJvcGVydHkgPSByZXF1aXJlKCcuL19iYXNlTWF0Y2hlc1Byb3BlcnR5JyksXG4gICAgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5JyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIHByb3BlcnR5ID0gcmVxdWlyZSgnLi9wcm9wZXJ0eScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLml0ZXJhdGVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSBbdmFsdWU9Xy5pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYW4gaXRlcmF0ZWUuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGl0ZXJhdGVlLlxuICovXG5mdW5jdGlvbiBiYXNlSXRlcmF0ZWUodmFsdWUpIHtcbiAgLy8gRG9uJ3Qgc3RvcmUgdGhlIGB0eXBlb2ZgIHJlc3VsdCBpbiBhIHZhcmlhYmxlIHRvIGF2b2lkIGEgSklUIGJ1ZyBpbiBTYWZhcmkgOS5cbiAgLy8gU2VlIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNTYwMzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGlkZW50aXR5O1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSlcbiAgICAgID8gYmFzZU1hdGNoZXNQcm9wZXJ0eSh2YWx1ZVswXSwgdmFsdWVbMV0pXG4gICAgICA6IGJhc2VNYXRjaGVzKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gcHJvcGVydHkodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJdGVyYXRlZTtcbiIsInZhciBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyksXG4gICAgbmF0aXZlS2V5cyA9IHJlcXVpcmUoJy4vX25hdGl2ZUtleXMnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VLZXlzO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKSxcbiAgICBuYXRpdmVLZXlzSW4gPSByZXF1aXJlKCcuL19uYXRpdmVLZXlzSW4nKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzSW5gIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXNJbihvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXNJbihvYmplY3QpO1xuICB9XG4gIHZhciBpc1Byb3RvID0gaXNQcm90b3R5cGUob2JqZWN0KSxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICBpZiAoIShrZXkgPT0gJ2NvbnN0cnVjdG9yJyAmJiAoaXNQcm90byB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlS2V5c0luO1xuIiwidmFyIGJhc2VJc01hdGNoID0gcmVxdWlyZSgnLi9fYmFzZUlzTWF0Y2gnKSxcbiAgICBnZXRNYXRjaERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXRjaERhdGEnKSxcbiAgICBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc2Agd2hpY2ggZG9lc24ndCBjbG9uZSBgc291cmNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzKHNvdXJjZSkge1xuICB2YXIgbWF0Y2hEYXRhID0gZ2V0TWF0Y2hEYXRhKHNvdXJjZSk7XG4gIGlmIChtYXRjaERhdGEubGVuZ3RoID09IDEgJiYgbWF0Y2hEYXRhWzBdWzJdKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKG1hdGNoRGF0YVswXVswXSwgbWF0Y2hEYXRhWzBdWzFdKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PT0gc291cmNlIHx8IGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNYXRjaGVzO1xuIiwidmFyIGJhc2VJc0VxdWFsID0gcmVxdWlyZSgnLi9fYmFzZUlzRXF1YWwnKSxcbiAgICBnZXQgPSByZXF1aXJlKCcuL2dldCcpLFxuICAgIGhhc0luID0gcmVxdWlyZSgnLi9oYXNJbicpLFxuICAgIGlzS2V5ID0gcmVxdWlyZSgnLi9faXNLZXknKSxcbiAgICBpc1N0cmljdENvbXBhcmFibGUgPSByZXF1aXJlKCcuL19pc1N0cmljdENvbXBhcmFibGUnKSxcbiAgICBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlJyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc1Byb3BlcnR5YCB3aGljaCBkb2Vzbid0IGNsb25lIGBzcmNWYWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzUHJvcGVydHkocGF0aCwgc3JjVmFsdWUpIHtcbiAgaWYgKGlzS2V5KHBhdGgpICYmIGlzU3RyaWN0Q29tcGFyYWJsZShzcmNWYWx1ZSkpIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUodG9LZXkocGF0aCksIHNyY1ZhbHVlKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIG9ialZhbHVlID0gZ2V0KG9iamVjdCwgcGF0aCk7XG4gICAgcmV0dXJuIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmIG9ialZhbHVlID09PSBzcmNWYWx1ZSlcbiAgICAgID8gaGFzSW4ob2JqZWN0LCBwYXRoKVxuICAgICAgOiBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1hdGNoZXNQcm9wZXJ0eTtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5KGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVByb3BlcnR5O1xuIiwidmFyIGJhc2VHZXQgPSByZXF1aXJlKCcuL19iYXNlR2V0Jyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUHJvcGVydHlgIHdoaWNoIHN1cHBvcnRzIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5RGVlcChwYXRoKSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQcm9wZXJ0eURlZXA7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUaW1lcztcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBhcnJheU1hcCA9IHJlcXVpcmUoJy4vX2FycmF5TWFwJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUb1N0cmluZztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVW5hcnk7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBhIGBjYWNoZWAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBjYWNoZUhhcyhjYWNoZSwga2V5KSB7XG4gIHJldHVybiBjYWNoZS5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYWNoZUhhcztcbiIsInZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNLZXkgPSByZXF1aXJlKCcuL19pc0tleScpLFxuICAgIHN0cmluZ1RvUGF0aCA9IHJlcXVpcmUoJy4vX3N0cmluZ1RvUGF0aCcpLFxuICAgIHRvU3RyaW5nID0gcmVxdWlyZSgnLi90b1N0cmluZycpO1xuXG4vKipcbiAqIENhc3RzIGB2YWx1ZWAgdG8gYSBwYXRoIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2FzdFBhdGgodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIGlzS2V5KHZhbHVlLCBvYmplY3QpID8gW3ZhbHVlXSA6IHN0cmluZ1RvUGF0aCh0b1N0cmluZyh2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhc3RQYXRoO1xuIiwidmFyIFVpbnQ4QXJyYXkgPSByZXF1aXJlKCcuL19VaW50OEFycmF5Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBhcnJheUJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBhcnJheUJ1ZmZlci5jb25zdHJ1Y3RvcihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgbmV3IFVpbnQ4QXJyYXkocmVzdWx0KS5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZUFycmF5QnVmZmVyO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIGFsbG9jVW5zYWZlID0gQnVmZmVyID8gQnVmZmVyLmFsbG9jVW5zYWZlIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiAgYGJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgVGhlIGJ1ZmZlciB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBjbG9uZUJ1ZmZlcihidWZmZXIsIGlzRGVlcCkge1xuICBpZiAoaXNEZWVwKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5zbGljZSgpO1xuICB9XG4gIHZhciBsZW5ndGggPSBidWZmZXIubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gYWxsb2NVbnNhZmUgPyBhbGxvY1Vuc2FmZShsZW5ndGgpIDogbmV3IGJ1ZmZlci5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gIGJ1ZmZlci5jb3B5KHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVCdWZmZXI7XG4iLCJ2YXIgY2xvbmVBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQXJyYXlCdWZmZXInKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGRhdGFWaWV3YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFWaWV3IFRoZSBkYXRhIHZpZXcgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIGRhdGEgdmlldy5cbiAqL1xuZnVuY3Rpb24gY2xvbmVEYXRhVmlldyhkYXRhVmlldywgaXNEZWVwKSB7XG4gIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKGRhdGFWaWV3LmJ1ZmZlcikgOiBkYXRhVmlldy5idWZmZXI7XG4gIHJldHVybiBuZXcgZGF0YVZpZXcuY29uc3RydWN0b3IoYnVmZmVyLCBkYXRhVmlldy5ieXRlT2Zmc2V0LCBkYXRhVmlldy5ieXRlTGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZURhdGFWaWV3O1xuIiwidmFyIGFkZE1hcEVudHJ5ID0gcmVxdWlyZSgnLi9fYWRkTWFwRW50cnknKSxcbiAgICBhcnJheVJlZHVjZSA9IHJlcXVpcmUoJy4vX2FycmF5UmVkdWNlJyksXG4gICAgbWFwVG9BcnJheSA9IHJlcXVpcmUoJy4vX21hcFRvQXJyYXknKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbnZhciBDTE9ORV9ERUVQX0ZMQUcgPSAxO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNsb25lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2xvbmVGdW5jIFRoZSBmdW5jdGlvbiB0byBjbG9uZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIG1hcC5cbiAqL1xuZnVuY3Rpb24gY2xvbmVNYXAobWFwLCBpc0RlZXAsIGNsb25lRnVuYykge1xuICB2YXIgYXJyYXkgPSBpc0RlZXAgPyBjbG9uZUZ1bmMobWFwVG9BcnJheShtYXApLCBDTE9ORV9ERUVQX0ZMQUcpIDogbWFwVG9BcnJheShtYXApO1xuICByZXR1cm4gYXJyYXlSZWR1Y2UoYXJyYXksIGFkZE1hcEVudHJ5LCBuZXcgbWFwLmNvbnN0cnVjdG9yKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZU1hcDtcbiIsIi8qKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgIGZsYWdzIGZyb20gdGhlaXIgY29lcmNlZCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlRmxhZ3MgPSAvXFx3KiQvO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgcmVnZXhwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHJlZ2V4cCBUaGUgcmVnZXhwIHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHJlZ2V4cC5cbiAqL1xuZnVuY3Rpb24gY2xvbmVSZWdFeHAocmVnZXhwKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgcmVnZXhwLmNvbnN0cnVjdG9yKHJlZ2V4cC5zb3VyY2UsIHJlRmxhZ3MuZXhlYyhyZWdleHApKTtcbiAgcmVzdWx0Lmxhc3RJbmRleCA9IHJlZ2V4cC5sYXN0SW5kZXg7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVSZWdFeHA7XG4iLCJ2YXIgYWRkU2V0RW50cnkgPSByZXF1aXJlKCcuL19hZGRTZXRFbnRyeScpLFxuICAgIGFycmF5UmVkdWNlID0gcmVxdWlyZSgnLi9fYXJyYXlSZWR1Y2UnKSxcbiAgICBzZXRUb0FycmF5ID0gcmVxdWlyZSgnLi9fc2V0VG9BcnJheScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xudmFyIENMT05FX0RFRVBfRkxBRyA9IDE7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBzZXRgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjbG9uZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNsb25lIHZhbHVlcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgc2V0LlxuICovXG5mdW5jdGlvbiBjbG9uZVNldChzZXQsIGlzRGVlcCwgY2xvbmVGdW5jKSB7XG4gIHZhciBhcnJheSA9IGlzRGVlcCA/IGNsb25lRnVuYyhzZXRUb0FycmF5KHNldCksIENMT05FX0RFRVBfRkxBRykgOiBzZXRUb0FycmF5KHNldCk7XG4gIHJldHVybiBhcnJheVJlZHVjZShhcnJheSwgYWRkU2V0RW50cnksIG5ldyBzZXQuY29uc3RydWN0b3IpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lU2V0O1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGBzeW1ib2xgIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHN5bWJvbCBUaGUgc3ltYm9sIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBzeW1ib2wgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBjbG9uZVN5bWJvbChzeW1ib2wpIHtcbiAgcmV0dXJuIHN5bWJvbFZhbHVlT2YgPyBPYmplY3Qoc3ltYm9sVmFsdWVPZi5jYWxsKHN5bWJvbCkpIDoge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVTeW1ib2w7XG4iLCJ2YXIgY2xvbmVBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQXJyYXlCdWZmZXInKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHR5cGVkQXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gdHlwZWRBcnJheSBUaGUgdHlwZWQgYXJyYXkgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHR5cGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBjbG9uZVR5cGVkQXJyYXkodHlwZWRBcnJheSwgaXNEZWVwKSB7XG4gIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKHR5cGVkQXJyYXkuYnVmZmVyKSA6IHR5cGVkQXJyYXkuYnVmZmVyO1xuICByZXR1cm4gbmV3IHR5cGVkQXJyYXkuY29uc3RydWN0b3IoYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkubGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVR5cGVkQXJyYXk7XG4iLCIvKipcbiAqIENvcGllcyB0aGUgdmFsdWVzIG9mIGBzb3VyY2VgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheT1bXV0gVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIHRvLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlBcnJheShzb3VyY2UsIGFycmF5KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcblxuICBhcnJheSB8fCAoYXJyYXkgPSBBcnJheShsZW5ndGgpKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtpbmRleF0gPSBzb3VyY2VbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5QXJyYXk7XG4iLCJ2YXIgYXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25WYWx1ZScpLFxuICAgIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpO1xuXG4vKipcbiAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMgdG8gY29weS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvcGllZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSwgcHJvcHMsIG9iamVjdCwgY3VzdG9taXplcikge1xuICB2YXIgaXNOZXcgPSAhb2JqZWN0O1xuICBvYmplY3QgfHwgKG9iamVjdCA9IHt9KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG5cbiAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICA/IGN1c3RvbWl6ZXIob2JqZWN0W2tleV0sIHNvdXJjZVtrZXldLCBrZXksIG9iamVjdCwgc291cmNlKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbmV3VmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gICAgaWYgKGlzTmV3KSB7XG4gICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5T2JqZWN0O1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAgZ2V0U3ltYm9scyA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHMnKTtcblxuLyoqXG4gKiBDb3BpZXMgb3duIHN5bWJvbHMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgZnJvbS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlTeW1ib2xzKHNvdXJjZSwgb2JqZWN0KSB7XG4gIHJldHVybiBjb3B5T2JqZWN0KHNvdXJjZSwgZ2V0U3ltYm9scyhzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlTeW1ib2xzO1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAgZ2V0U3ltYm9sc0luID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9sc0luJyk7XG5cbi8qKlxuICogQ29waWVzIG93biBhbmQgaW5oZXJpdGVkIHN5bWJvbHMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgZnJvbS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlTeW1ib2xzSW4oc291cmNlLCBvYmplY3QpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzSW4oc291cmNlKSwgb2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5U3ltYm9sc0luO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbm1vZHVsZS5leHBvcnRzID0gY29yZUpzRGF0YTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKTtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHZhciBmdW5jID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2RlZmluZVByb3BlcnR5Jyk7XG4gICAgZnVuYyh7fSwgJycsIHt9KTtcbiAgICByZXR1cm4gZnVuYztcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmaW5lUHJvcGVydHk7XG4iLCJ2YXIgU2V0Q2FjaGUgPSByZXF1aXJlKCcuL19TZXRDYWNoZScpLFxuICAgIGFycmF5U29tZSA9IHJlcXVpcmUoJy4vX2FycmF5U29tZScpLFxuICAgIGNhY2hlSGFzID0gcmVxdWlyZSgnLi9fY2FjaGVIYXMnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYGFycmF5YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cbiAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1BhcnRpYWwgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KGFycmF5KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gdHJ1ZSxcbiAgICAgIHNlZW4gPSAoYml0bWFzayAmIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpID8gbmV3IFNldENhY2hlIDogdW5kZWZpbmVkO1xuXG4gIHN0YWNrLnNldChhcnJheSwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIGFycmF5KTtcblxuICAvLyBJZ25vcmUgbm9uLWluZGV4IHByb3BlcnRpZXMuXG4gIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2luZGV4XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBhcnJWYWx1ZSwgaW5kZXgsIG90aGVyLCBhcnJheSwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihhcnJWYWx1ZSwgb3RoVmFsdWUsIGluZGV4LCBhcnJheSwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgaWYgKGNvbXBhcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChjb21wYXJlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKHNlZW4pIHtcbiAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSwgb3RoSW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghY2FjaGVIYXMoc2Vlbiwgb3RoSW5kZXgpICYmXG4gICAgICAgICAgICAgICAgKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzZWVuLnB1c2gob3RoSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEoXG4gICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG4gICAgICAgICAgICBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKGFycmF5KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbEFycmF5cztcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBVaW50OEFycmF5ID0gcmVxdWlyZSgnLi9fVWludDhBcnJheScpLFxuICAgIGVxID0gcmVxdWlyZSgnLi9lcScpLFxuICAgIGVxdWFsQXJyYXlzID0gcmVxdWlyZSgnLi9fZXF1YWxBcnJheXMnKSxcbiAgICBtYXBUb0FycmF5ID0gcmVxdWlyZSgnLi9fbWFwVG9BcnJheScpLFxuICAgIHNldFRvQXJyYXkgPSByZXF1aXJlKCcuL19zZXRUb0FycmF5Jyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgIChvYmplY3QuYnl0ZU9mZnNldCAhPSBvdGhlci5ieXRlT2Zmc2V0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XG5cbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgICFlcXVhbEZ1bmMobmV3IFVpbnQ4QXJyYXkob2JqZWN0KSwgbmV3IFVpbnQ4QXJyYXkob3RoZXIpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAvLyBDb2VyY2UgYm9vbGVhbnMgdG8gYDFgIG9yIGAwYCBhbmQgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzLlxuICAgICAgLy8gSW52YWxpZCBkYXRlcyBhcmUgY29lcmNlZCB0byBgTmFOYC5cbiAgICAgIHJldHVybiBlcSgrb2JqZWN0LCArb3RoZXIpO1xuXG4gICAgY2FzZSBlcnJvclRhZzpcbiAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIC8vIENvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgYW5kIHRyZWF0IHN0cmluZ3MsIHByaW1pdGl2ZXMgYW5kIG9iamVjdHMsXG4gICAgICAvLyBhcyBlcXVhbC4gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG4gICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG5cbiAgICBjYXNlIG1hcFRhZzpcbiAgICAgIHZhciBjb252ZXJ0ID0gbWFwVG9BcnJheTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRztcbiAgICAgIGNvbnZlcnQgfHwgKGNvbnZlcnQgPSBzZXRUb0FycmF5KTtcblxuICAgICAgaWYgKG9iamVjdC5zaXplICE9IG90aGVyLnNpemUgJiYgIWlzUGFydGlhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICBiaXRtYXNrIHw9IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUc7XG5cbiAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgdmFyIHJlc3VsdCA9IGVxdWFsQXJyYXlzKGNvbnZlcnQob2JqZWN0KSwgY29udmVydChvdGhlciksIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICBpZiAoc3ltYm9sVmFsdWVPZikge1xuICAgICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZi5jYWxsKG9iamVjdCkgPT0gc3ltYm9sVmFsdWVPZi5jYWxsKG90aGVyKTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWxCeVRhZztcbiIsInZhciBnZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fZ2V0QWxsS2V5cycpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDE7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBvYmpQcm9wcyA9IGdldEFsbEtleXMob2JqZWN0KSxcbiAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcbiAgICAgIG90aFByb3BzID0gZ2V0QWxsS2V5cyhvdGhlciksXG4gICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzUGFydGlhbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICBpZiAoIShpc1BhcnRpYWwgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XG5cbiAgdmFyIHNraXBDdG9yID0gaXNQYXJ0aWFsO1xuICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlLCBrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gKG9ialZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpXG4gICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG4gIH1cbiAgaWYgKHJlc3VsdCAmJiAhc2tpcEN0b3IpIHtcbiAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbE9iamVjdHM7XG4iLCIvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZyZWVHbG9iYWw7XG4iLCJ2YXIgYmFzZUdldEFsbEtleXMgPSByZXF1aXJlKCcuL19iYXNlR2V0QWxsS2V5cycpLFxuICAgIGdldFN5bWJvbHMgPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXMob2JqZWN0KSB7XG4gIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXMsIGdldFN5bWJvbHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFsbEtleXM7XG4iLCJ2YXIgYmFzZUdldEFsbEtleXMgPSByZXF1aXJlKCcuL19iYXNlR2V0QWxsS2V5cycpLFxuICAgIGdldFN5bWJvbHNJbiA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHNJbicpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4va2V5c0luJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsS2V5c0luKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzSW4sIGdldFN5bWJvbHNJbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QWxsS2V5c0luO1xuIiwidmFyIGlzS2V5YWJsZSA9IHJlcXVpcmUoJy4vX2lzS2V5YWJsZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWFwRGF0YTtcbiIsInZhciBpc1N0cmljdENvbXBhcmFibGUgPSByZXF1aXJlKCcuL19pc1N0cmljdENvbXBhcmFibGUnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3Mgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbWF0Y2ggZGF0YSBvZiBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gZ2V0TWF0Y2hEYXRhKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0ga2V5cyhvYmplY3QpLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICB2YXIga2V5ID0gcmVzdWx0W2xlbmd0aF0sXG4gICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICByZXN1bHRbbGVuZ3RoXSA9IFtrZXksIHZhbHVlLCBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE1hdGNoRGF0YTtcbiIsInZhciBiYXNlSXNOYXRpdmUgPSByZXF1aXJlKCcuL19iYXNlSXNOYXRpdmUnKSxcbiAgICBnZXRWYWx1ZSA9IHJlcXVpcmUoJy4vX2dldFZhbHVlJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TmF0aXZlO1xuIiwidmFyIG92ZXJBcmcgPSByZXF1aXJlKCcuL19vdmVyQXJnJyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFByb3RvdHlwZTtcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFJhd1RhZztcbiIsInZhciBhcnJheUZpbHRlciA9IHJlcXVpcmUoJy4vX2FycmF5RmlsdGVyJyksXG4gICAgc3R1YkFycmF5ID0gcmVxdWlyZSgnLi9zdHViQXJyYXknKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHMgPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHJldHVybiBhcnJheUZpbHRlcihuYXRpdmVHZXRTeW1ib2xzKG9iamVjdCksIGZ1bmN0aW9uKHN5bWJvbCkge1xuICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgc3ltYm9sKTtcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFN5bWJvbHM7XG4iLCJ2YXIgYXJyYXlQdXNoID0gcmVxdWlyZSgnLi9fYXJyYXlQdXNoJyksXG4gICAgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgZ2V0U3ltYm9scyA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHMnKSxcbiAgICBzdHViQXJyYXkgPSByZXF1aXJlKCcuL3N0dWJBcnJheScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzSW4gPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHdoaWxlIChvYmplY3QpIHtcbiAgICBhcnJheVB1c2gocmVzdWx0LCBnZXRTeW1ib2xzKG9iamVjdCkpO1xuICAgIG9iamVjdCA9IGdldFByb3RvdHlwZShvYmplY3QpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFN5bWJvbHNJbjtcbiIsInZhciBEYXRhVmlldyA9IHJlcXVpcmUoJy4vX0RhdGFWaWV3JyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyksXG4gICAgUHJvbWlzZSA9IHJlcXVpcmUoJy4vX1Byb21pc2UnKSxcbiAgICBTZXQgPSByZXF1aXJlKCcuL19TZXQnKSxcbiAgICBXZWFrTWFwID0gcmVxdWlyZSgnLi9fV2Vha01hcCcpLFxuICAgIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgdG9Tb3VyY2UgPSByZXF1aXJlKCcuL190b1NvdXJjZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcHJvbWlzZVRhZyA9ICdbb2JqZWN0IFByb21pc2VdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWFwcywgc2V0cywgYW5kIHdlYWttYXBzLiAqL1xudmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcbiAgICBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoTWFwKSxcbiAgICBwcm9taXNlQ3RvclN0cmluZyA9IHRvU291cmNlKFByb21pc2UpLFxuICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQpLFxuICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcCk7XG5cbi8qKlxuICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbnZhciBnZXRUYWcgPSBiYXNlR2V0VGFnO1xuXG4vLyBGYWxsYmFjayBmb3IgZGF0YSB2aWV3cywgbWFwcywgc2V0cywgYW5kIHdlYWsgbWFwcyBpbiBJRSAxMSBhbmQgcHJvbWlzZXMgaW4gTm9kZS5qcyA8IDYuXG5pZiAoKERhdGFWaWV3ICYmIGdldFRhZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpKSkgIT0gZGF0YVZpZXdUYWcpIHx8XG4gICAgKE1hcCAmJiBnZXRUYWcobmV3IE1hcCkgIT0gbWFwVGFnKSB8fFxuICAgIChQcm9taXNlICYmIGdldFRhZyhQcm9taXNlLnJlc29sdmUoKSkgIT0gcHJvbWlzZVRhZykgfHxcbiAgICAoU2V0ICYmIGdldFRhZyhuZXcgU2V0KSAhPSBzZXRUYWcpIHx8XG4gICAgKFdlYWtNYXAgJiYgZ2V0VGFnKG5ldyBXZWFrTWFwKSAhPSB3ZWFrTWFwVGFnKSkge1xuICBnZXRUYWcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBiYXNlR2V0VGFnKHZhbHVlKSxcbiAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWcgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgY3RvclN0cmluZyA9IEN0b3IgPyB0b1NvdXJjZShDdG9yKSA6ICcnO1xuXG4gICAgaWYgKGN0b3JTdHJpbmcpIHtcbiAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuICAgICAgICBjYXNlIGRhdGFWaWV3Q3RvclN0cmluZzogcmV0dXJuIGRhdGFWaWV3VGFnO1xuICAgICAgICBjYXNlIG1hcEN0b3JTdHJpbmc6IHJldHVybiBtYXBUYWc7XG4gICAgICAgIGNhc2UgcHJvbWlzZUN0b3JTdHJpbmc6IHJldHVybiBwcm9taXNlVGFnO1xuICAgICAgICBjYXNlIHNldEN0b3JTdHJpbmc6IHJldHVybiBzZXRUYWc7XG4gICAgICAgIGNhc2Ugd2Vha01hcEN0b3JTdHJpbmc6IHJldHVybiB3ZWFrTWFwVGFnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFRhZztcbiIsIi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFZhbHVlO1xuIiwidmFyIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBleGlzdHMgb24gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2sgcHJvcGVydGllcy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBmYWxzZTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XG4gICAgaWYgKCEocmVzdWx0ID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gIH1cbiAgaWYgKHJlc3VsdCB8fCArK2luZGV4ICE9IGxlbmd0aCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgbGVuZ3RoID0gb2JqZWN0ID09IG51bGwgPyAwIDogb2JqZWN0Lmxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiYgaXNJbmRleChrZXksIGxlbmd0aCkgJiZcbiAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc1BhdGg7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaERlbGV0ZTtcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hHZXQ7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoSGFzO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoU2V0O1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBhcnJheSBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNsb25lLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lQXJyYXkoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGFycmF5LmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgLy8gQWRkIHByb3BlcnRpZXMgYXNzaWduZWQgYnkgYFJlZ0V4cCNleGVjYC5cbiAgaWYgKGxlbmd0aCAmJiB0eXBlb2YgYXJyYXlbMF0gPT0gJ3N0cmluZycgJiYgaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgJ2luZGV4JykpIHtcbiAgICByZXN1bHQuaW5kZXggPSBhcnJheS5pbmRleDtcbiAgICByZXN1bHQuaW5wdXQgPSBhcnJheS5pbnB1dDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZUFycmF5O1xuIiwidmFyIGNsb25lQXJyYXlCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUFycmF5QnVmZmVyJyksXG4gICAgY2xvbmVEYXRhVmlldyA9IHJlcXVpcmUoJy4vX2Nsb25lRGF0YVZpZXcnKSxcbiAgICBjbG9uZU1hcCA9IHJlcXVpcmUoJy4vX2Nsb25lTWFwJyksXG4gICAgY2xvbmVSZWdFeHAgPSByZXF1aXJlKCcuL19jbG9uZVJlZ0V4cCcpLFxuICAgIGNsb25lU2V0ID0gcmVxdWlyZSgnLi9fY2xvbmVTZXQnKSxcbiAgICBjbG9uZVN5bWJvbCA9IHJlcXVpcmUoJy4vX2Nsb25lU3ltYm9sJyksXG4gICAgY2xvbmVUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fY2xvbmVUeXBlZEFycmF5Jyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZSBiYXNlZCBvbiBpdHMgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNsb25pbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNsb25lRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2xvbmUgdmFsdWVzLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVCeVRhZyhvYmplY3QsIHRhZywgY2xvbmVGdW5jLCBpc0RlZXApIHtcbiAgdmFyIEN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgIHJldHVybiBjbG9uZUFycmF5QnVmZmVyKG9iamVjdCk7XG5cbiAgICBjYXNlIGJvb2xUYWc6XG4gICAgY2FzZSBkYXRlVGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yKCtvYmplY3QpO1xuXG4gICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgIHJldHVybiBjbG9uZURhdGFWaWV3KG9iamVjdCwgaXNEZWVwKTtcblxuICAgIGNhc2UgZmxvYXQzMlRhZzogY2FzZSBmbG9hdDY0VGFnOlxuICAgIGNhc2UgaW50OFRhZzogY2FzZSBpbnQxNlRhZzogY2FzZSBpbnQzMlRhZzpcbiAgICBjYXNlIHVpbnQ4VGFnOiBjYXNlIHVpbnQ4Q2xhbXBlZFRhZzogY2FzZSB1aW50MTZUYWc6IGNhc2UgdWludDMyVGFnOlxuICAgICAgcmV0dXJuIGNsb25lVHlwZWRBcnJheShvYmplY3QsIGlzRGVlcCk7XG5cbiAgICBjYXNlIG1hcFRhZzpcbiAgICAgIHJldHVybiBjbG9uZU1hcChvYmplY3QsIGlzRGVlcCwgY2xvbmVGdW5jKTtcblxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yKG9iamVjdCk7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgIHJldHVybiBjbG9uZVJlZ0V4cChvYmplY3QpO1xuXG4gICAgY2FzZSBzZXRUYWc6XG4gICAgICByZXR1cm4gY2xvbmVTZXQob2JqZWN0LCBpc0RlZXAsIGNsb25lRnVuYyk7XG5cbiAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgIHJldHVybiBjbG9uZVN5bWJvbChvYmplY3QpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdENsb25lQnlUYWc7XG4iLCJ2YXIgYmFzZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX2Jhc2VDcmVhdGUnKSxcbiAgICBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyk7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lT2JqZWN0KG9iamVjdCkge1xuICByZXR1cm4gKHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNQcm90b3R5cGUob2JqZWN0KSlcbiAgICA/IGJhc2VDcmVhdGUoZ2V0UHJvdG90eXBlKG9iamVjdCkpXG4gICAgOiB7fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbml0Q2xvbmVPYmplY3Q7XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8IHJlSXNVaW50LnRlc3QodmFsdWUpKSAmJlxuICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0luZGV4O1xuIiwidmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlSXNEZWVwUHJvcCA9IC9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcXFxdfFxcXFwuKSo/XFwxKVxcXS8sXG4gICAgcmVJc1BsYWluUHJvcCA9IC9eXFx3KiQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSBhbmQgbm90IGEgcHJvcGVydHkgcGF0aC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5KHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8XG4gICAgICB2YWx1ZSA9PSBudWxsIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiByZUlzUGxhaW5Qcm9wLnRlc3QodmFsdWUpIHx8ICFyZUlzRGVlcFByb3AudGVzdCh2YWx1ZSkgfHxcbiAgICAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0KG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzS2V5O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzS2V5YWJsZTtcbiIsInZhciBjb3JlSnNEYXRhID0gcmVxdWlyZSgnLi9fY29yZUpzRGF0YScpO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbn0oKSk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTWFza2VkO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUHJvdG90eXBlO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaWYgc3VpdGFibGUgZm9yIHN0cmljdFxuICogIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlICYmICFpc09iamVjdCh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTdHJpY3RDb21wYXJhYmxlO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUNsZWFyO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2U7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICAtLXRoaXMuc2l6ZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlRGVsZXRlO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUdldDtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlSGFzO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgICsrdGhpcy5zaXplO1xuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlU2V0O1xuIiwidmFyIEhhc2ggPSByZXF1aXJlKCcuL19IYXNoJyksXG4gICAgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUNsZWFyO1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlRGVsZXRlO1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUdldDtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlSGFzO1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSxcbiAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZVNldDtcbiIsIi8qKlxuICogQ29udmVydHMgYG1hcGAgdG8gaXRzIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAqL1xuZnVuY3Rpb24gbWFwVG9BcnJheShtYXApIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShtYXAuc2l6ZSk7XG5cbiAgbWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwVG9BcnJheTtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBtYXRjaGVzUHJvcGVydHlgIGZvciBzb3VyY2UgdmFsdWVzIHN1aXRhYmxlXG4gKiBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUoa2V5LCBzcmNWYWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Rba2V5XSA9PT0gc3JjVmFsdWUgJiZcbiAgICAgIChzcmNWYWx1ZSAhPT0gdW5kZWZpbmVkIHx8IChrZXkgaW4gT2JqZWN0KG9iamVjdCkpKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZTtcbiIsInZhciBtZW1vaXplID0gcmVxdWlyZSgnLi9tZW1vaXplJyk7XG5cbi8qKiBVc2VkIGFzIHRoZSBtYXhpbXVtIG1lbW9pemUgY2FjaGUgc2l6ZS4gKi9cbnZhciBNQVhfTUVNT0laRV9TSVpFID0gNTAwO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tZW1vaXplYCB3aGljaCBjbGVhcnMgdGhlIG1lbW9pemVkIGZ1bmN0aW9uJ3NcbiAqIGNhY2hlIHdoZW4gaXQgZXhjZWVkcyBgTUFYX01FTU9JWkVfU0laRWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtZW1vaXplQ2FwcGVkKGZ1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IG1lbW9pemUoZnVuYywgZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKGNhY2hlLnNpemUgPT09IE1BWF9NRU1PSVpFX1NJWkUpIHtcbiAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG4gIH0pO1xuXG4gIHZhciBjYWNoZSA9IHJlc3VsdC5jYWNoZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplQ2FwcGVkO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUNyZWF0ZTtcbiIsInZhciBvdmVyQXJnID0gcmVxdWlyZSgnLi9fb3ZlckFyZycpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlS2V5cztcbiIsIi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlXG4gKiBbYE9iamVjdC5rZXlzYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBleGNlcHQgdGhhdCBpdCBpbmNsdWRlcyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBuYXRpdmVLZXlzSW4ob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUtleXNJbjtcbiIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbm9kZVV0aWw7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvYmplY3RUb1N0cmluZztcbiIsIi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG92ZXJBcmc7XG4iLCJ2YXIgZnJlZUdsb2JhbCA9IHJlcXVpcmUoJy4vX2ZyZWVHbG9iYWwnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJvb3Q7XG4iLCIvKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogQWRkcyBgdmFsdWVgIHRvIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgYWRkXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBhbGlhcyBwdXNoXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUFkZCh2YWx1ZSkge1xuICB0aGlzLl9fZGF0YV9fLnNldCh2YWx1ZSwgSEFTSF9VTkRFRklORUQpO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRDYWNoZUFkZDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRDYWNoZUhhcztcbiIsIi8qKlxuICogQ29udmVydHMgYHNldGAgdG8gYW4gYXJyYXkgb2YgaXRzIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG5cbiAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0VG9BcnJheTtcbiIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBTdGFja1xuICovXG5mdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0NsZWFyO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIHJlc3VsdCA9IGRhdGFbJ2RlbGV0ZSddKGtleSk7XG5cbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrRGVsZXRlO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrR2V0O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0hhcztcbiIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKSxcbiAgICBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyk7XG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKlxuICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xuICAgIHZhciBwYWlycyA9IGRhdGEuX19kYXRhX187XG4gICAgaWYgKCFNYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICB9XG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrU2V0O1xuIiwidmFyIG1lbW9pemVDYXBwZWQgPSByZXF1aXJlKCcuL19tZW1vaXplQ2FwcGVkJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUxlYWRpbmdEb3QgPSAvXlxcLi8sXG4gICAgcmVQcm9wTmFtZSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwkKSkvZztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xudmFyIHN0cmluZ1RvUGF0aCA9IG1lbW9pemVDYXBwZWQoZnVuY3Rpb24oc3RyaW5nKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKHJlTGVhZGluZ0RvdC50ZXN0KHN0cmluZykpIHtcbiAgICByZXN1bHQucHVzaCgnJyk7XG4gIH1cbiAgc3RyaW5nLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN0cmluZykge1xuICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdUb1BhdGg7XG4iLCJ2YXIgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAqL1xuZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvS2V5O1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvU291cmNlO1xuIiwidmFyIGJhc2VDbG9uZSA9IHJlcXVpcmUoJy4vX2Jhc2VDbG9uZScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xudmFyIENMT05FX1NZTUJPTFNfRkxBRyA9IDQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHNoYWxsb3cgY2xvbmUgb2YgYHZhbHVlYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvbiB0aGVcbiAqIFtzdHJ1Y3R1cmVkIGNsb25lIGFsZ29yaXRobV0oaHR0cHM6Ly9tZG4uaW8vU3RydWN0dXJlZF9jbG9uZV9hbGdvcml0aG0pXG4gKiBhbmQgc3VwcG9ydHMgY2xvbmluZyBhcnJheXMsIGFycmF5IGJ1ZmZlcnMsIGJvb2xlYW5zLCBkYXRlIG9iamVjdHMsIG1hcHMsXG4gKiBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLCBzZXRzLCBzdHJpbmdzLCBzeW1ib2xzLCBhbmQgdHlwZWRcbiAqIGFycmF5cy4gVGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYGFyZ3VtZW50c2Agb2JqZWN0cyBhcmUgY2xvbmVkXG4gKiBhcyBwbGFpbiBvYmplY3RzLiBBbiBlbXB0eSBvYmplY3QgaXMgcmV0dXJuZWQgZm9yIHVuY2xvbmVhYmxlIHZhbHVlcyBzdWNoXG4gKiBhcyBlcnJvciBvYmplY3RzLCBmdW5jdGlvbnMsIERPTSBub2RlcywgYW5kIFdlYWtNYXBzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gKiBAc2VlIF8uY2xvbmVEZWVwXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gW3sgJ2EnOiAxIH0sIHsgJ2InOiAyIH1dO1xuICpcbiAqIHZhciBzaGFsbG93ID0gXy5jbG9uZShvYmplY3RzKTtcbiAqIGNvbnNvbGUubG9nKHNoYWxsb3dbMF0gPT09IG9iamVjdHNbMF0pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBjbG9uZSh2YWx1ZSkge1xuICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9TWU1CT0xTX0ZMQUcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lO1xuIiwiLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXE7XG4iLCJ2YXIgYmFzZUZpbmRJbmRleCA9IHJlcXVpcmUoJy4vX2Jhc2VGaW5kSW5kZXgnKSxcbiAgICBiYXNlSXRlcmF0ZWUgPSByZXF1aXJlKCcuL19iYXNlSXRlcmF0ZWUnKSxcbiAgICB0b0ludGVnZXIgPSByZXF1aXJlKCcuL3RvSW50ZWdlcicpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3RcbiAqIGVsZW1lbnQgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMS4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgLTFgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiBmYWxzZSB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IHRydWUgfVxuICogXTtcbiAqXG4gKiBfLmZpbmRJbmRleCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby51c2VyID09ICdiYXJuZXknOyB9KTtcbiAqIC8vID0+IDBcbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kSW5kZXgodXNlcnMsIHsgJ3VzZXInOiAnZnJlZCcsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAqIC8vID0+IDFcbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmRJbmRleCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICogLy8gPT4gMFxuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kSW5kZXgodXNlcnMsICdhY3RpdmUnKTtcbiAqIC8vID0+IDJcbiAqL1xuZnVuY3Rpb24gZmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIHZhciBpbmRleCA9IGZyb21JbmRleCA9PSBudWxsID8gMCA6IHRvSW50ZWdlcihmcm9tSW5kZXgpO1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgaW5kZXggPSBuYXRpdmVNYXgobGVuZ3RoICsgaW5kZXgsIDApO1xuICB9XG4gIHJldHVybiBiYXNlRmluZEluZGV4KGFycmF5LCBiYXNlSXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgaW5kZXgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZpbmRJbmRleDtcbiIsInZhciBiYXNlR2V0ID0gcmVxdWlyZSgnLi9fYmFzZUdldCcpO1xuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzXG4gKiBgdW5kZWZpbmVkYCwgdGhlIGBkZWZhdWx0VmFsdWVgIGlzIHJldHVybmVkIGluIGl0cyBwbGFjZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuNy4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgZm9yIGB1bmRlZmluZWRgIHJlc29sdmVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAqXG4gKiBfLmdldChvYmplY3QsICdhWzBdLmIuYycpO1xuICogLy8gPT4gM1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgWydhJywgJzAnLCAnYicsICdjJ10pO1xuICogLy8gPT4gM1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2EuYi5jJywgJ2RlZmF1bHQnKTtcbiAqIC8vID0+ICdkZWZhdWx0J1xuICovXG5mdW5jdGlvbiBnZXQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0O1xuIiwidmFyIGJhc2VIYXNJbiA9IHJlcXVpcmUoJy4vX2Jhc2VIYXNJbicpLFxuICAgIGhhc1BhdGggPSByZXF1aXJlKCcuL19oYXNQYXRoJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBvciBpbmhlcml0ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0gXy5jcmVhdGUoeyAnYSc6IF8uY3JlYXRlKHsgJ2InOiAyIH0pIH0pO1xuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYS5iJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsIFsnYScsICdiJ10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYicpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaGFzSW4ob2JqZWN0LCBwYXRoKSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgYmFzZUhhc0luKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNJbjtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKlxuICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaWRlbnRpdHk7XG4iLCJ2YXIgYmFzZUlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9fYmFzZUlzQXJndW1lbnRzJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcmd1bWVudHM7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5O1xuIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheUxpa2U7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKSxcbiAgICBzdHViRmFsc2UgPSByZXF1aXJlKCcuL3N0dWJGYWxzZScpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNCdWZmZXI7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0Z1bmN0aW9uO1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTGVuZ3RoO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3Q7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdExpa2U7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTeW1ib2w7XG4iLCJ2YXIgYmFzZUlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vX2Jhc2VJc1R5cGVkQXJyYXknKSxcbiAgICBiYXNlVW5hcnkgPSByZXF1aXJlKCcuL19iYXNlVW5hcnknKSxcbiAgICBub2RlVXRpbCA9IHJlcXVpcmUoJy4vX25vZGVVdGlsJyk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVHlwZWRBcnJheTtcbiIsInZhciBhcnJheUxpa2VLZXlzID0gcmVxdWlyZSgnLi9fYXJyYXlMaWtlS2V5cycpLFxuICAgIGJhc2VLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUtleXMnKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG5mdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5cztcbiIsInZhciBhcnJheUxpa2VLZXlzID0gcmVxdWlyZSgnLi9fYXJyYXlMaWtlS2V5cycpLFxuICAgIGJhc2VLZXlzSW4gPSByZXF1aXJlKCcuL19iYXNlS2V5c0luJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXNJbihuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG5mdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QsIHRydWUpIDogYmFzZUtleXNJbihvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXNJbjtcbiIsInZhciBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyk7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcbiAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxuICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICpcbiAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGVcbiAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBjbGVhcmAsIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xuICpcbiAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiB2YWx1ZXMob3RoZXIpO1xuICogLy8gPT4gWzMsIDRdXG4gKlxuICogb2JqZWN0LmEgPSAyO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiAvLyBNb2RpZnkgdGhlIHJlc3VsdCBjYWNoZS5cbiAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWydhJywgJ2InXVxuICpcbiAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXG4gKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuICovXG5mdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IChyZXNvbHZlciAhPSBudWxsICYmIHR5cGVvZiByZXNvbHZlciAhPSAnZnVuY3Rpb24nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF0sXG4gICAgICAgIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGU7XG5cbiAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpIHx8IGNhY2hlO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIG1lbW9pemVkLmNhY2hlID0gbmV3IChtZW1vaXplLkNhY2hlIHx8IE1hcENhY2hlKTtcbiAgcmV0dXJuIG1lbW9pemVkO1xufVxuXG4vLyBFeHBvc2UgYE1hcENhY2hlYC5cbm1lbW9pemUuQ2FjaGUgPSBNYXBDYWNoZTtcblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplO1xuIiwidmFyIGJhc2VQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2Jhc2VQcm9wZXJ0eScpLFxuICAgIGJhc2VQcm9wZXJ0eURlZXAgPSByZXF1aXJlKCcuL19iYXNlUHJvcGVydHlEZWVwJyksXG4gICAgaXNLZXkgPSByZXF1aXJlKCcuL19pc0tleScpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbXG4gKiAgIHsgJ2EnOiB7ICdiJzogMiB9IH0sXG4gKiAgIHsgJ2EnOiB7ICdiJzogMSB9IH1cbiAqIF07XG4gKlxuICogXy5tYXAob2JqZWN0cywgXy5wcm9wZXJ0eSgnYS5iJykpO1xuICogLy8gPT4gWzIsIDFdXG4gKlxuICogXy5tYXAoXy5zb3J0Qnkob2JqZWN0cywgXy5wcm9wZXJ0eShbJ2EnLCAnYiddKSksICdhLmInKTtcbiAqIC8vID0+IFsxLCAyXVxuICovXG5mdW5jdGlvbiBwcm9wZXJ0eShwYXRoKSB7XG4gIHJldHVybiBpc0tleShwYXRoKSA/IGJhc2VQcm9wZXJ0eSh0b0tleShwYXRoKSkgOiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHByb3BlcnR5O1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBhcnJheXMgPSBfLnRpbWVzKDIsIF8uc3R1YkFycmF5KTtcbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXMpO1xuICogLy8gPT4gW1tdLCBbXV1cbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXNbMF0gPT09IGFycmF5c1sxXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBzdHViQXJyYXkoKSB7XG4gIHJldHVybiBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHViQXJyYXk7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R1YkZhbHNlO1xuIiwidmFyIHRvTnVtYmVyID0gcmVxdWlyZSgnLi90b051bWJlcicpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwLFxuICAgIE1BWF9JTlRFR0VSID0gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDg7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIGZpbml0ZSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEyLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b0Zpbml0ZSgzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b0Zpbml0ZShOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9GaW5pdGUoSW5maW5pdHkpO1xuICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAqXG4gKiBfLnRvRmluaXRlKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b0Zpbml0ZSh2YWx1ZSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiAwO1xuICB9XG4gIHZhbHVlID0gdG9OdW1iZXIodmFsdWUpO1xuICBpZiAodmFsdWUgPT09IElORklOSVRZIHx8IHZhbHVlID09PSAtSU5GSU5JVFkpIHtcbiAgICB2YXIgc2lnbiA9ICh2YWx1ZSA8IDAgPyAtMSA6IDEpO1xuICAgIHJldHVybiBzaWduICogTUFYX0lOVEVHRVI7XG4gIH1cbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/IHZhbHVlIDogMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0Zpbml0ZTtcbiIsInZhciB0b0Zpbml0ZSA9IHJlcXVpcmUoJy4vdG9GaW5pdGUnKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGludGVnZXIuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9JbnRlZ2VyYF0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvaW50ZWdlcikuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b0ludGVnZXIoMy4yKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLnRvSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDBcbiAqXG4gKiBfLnRvSW50ZWdlcihJbmZpbml0eSk7XG4gKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICpcbiAqIF8udG9JbnRlZ2VyKCczLjInKTtcbiAqIC8vID0+IDNcbiAqL1xuZnVuY3Rpb24gdG9JbnRlZ2VyKHZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSB0b0Zpbml0ZSh2YWx1ZSksXG4gICAgICByZW1haW5kZXIgPSByZXN1bHQgJSAxO1xuXG4gIHJldHVybiByZXN1bHQgPT09IHJlc3VsdCA/IChyZW1haW5kZXIgPyByZXN1bHQgLSByZW1haW5kZXIgOiByZXN1bHQpIDogMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0ludGVnZXI7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE5BTiA9IDAgLyAwO1xuXG4vKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLiAqL1xudmFyIHJlVHJpbSA9IC9eXFxzK3xcXHMrJC9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJpbmFyeSBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvY3RhbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG5cbi8qKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB3aXRob3V0IGEgZGVwZW5kZW5jeSBvbiBgcm9vdGAuICovXG52YXIgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b051bWJlcigzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gSW5maW5pdHlcbiAqXG4gKiBfLnRvTnVtYmVyKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gTkFOO1xuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gIH1cbiAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlVHJpbSwgJycpO1xuICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b051bWJlcjtcbiIsInZhciBiYXNlVG9TdHJpbmcgPSByZXF1aXJlKCcuL19iYXNlVG9TdHJpbmcnKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvU3RyaW5nKG51bGwpO1xuICogLy8gPT4gJydcbiAqXG4gKiBfLnRvU3RyaW5nKC0wKTtcbiAqIC8vID0+ICctMCdcbiAqXG4gKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAnMSwyLDMnXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvU3RyaW5nO1xuIiwiLyogZ2xvYmFscyBtb2R1bGU6IGZhbHNlLCByZXF1aXJlOiBmYWxzZSAqL1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdGxldCBfZmkgPSByZXF1aXJlKCdsb2Rhc2gvZmluZEluZGV4JylcclxuXHRcdC8vICwgX2lzZXEgPSByZXF1aXJlKCdsb2Rhc2gvaXNFcXVhbCcpXHJcblx0XHQsIF9jbG9uZSA9IHJlcXVpcmUoJ2xvZGFzaC9jbG9uZScpXHJcblx0XHQvL3V0aWxpdGllc1xyXG5cdFx0Ly8gY29uc3RcclxuXHJcblx0XHQsIF9pc2VxID0gKHgsIHkpID0+IHtcclxuXHJcblx0XHRcdGlmICghQXJyYXkuaXNBcnJheSh4KSB8fCAhQXJyYXkuaXNBcnJheSh5KSkge1xyXG5cdFx0XHRcdHJldHVybiB4ID09IHkvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxyXG5cdFx0XHRcdC8vIHJldHVybiB4ID09PSB5XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHgubGVuZ3RoICE9PSB5Lmxlbmd0aCkgcmV0dXJuIGZhbHNlXHJcblx0XHRcdGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB4Lmxlbmd0aDsgaW5kZXgrKykge1xyXG5cdFx0XHRcdGlmICghX2lzZXEoeFtpbmRleF0sIHlbaW5kZXhdKSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiB0cnVlXHJcblxyXG5cdFx0fVxyXG5cdFx0LCBteUluZGV4T2YgPSAoYSwgYikgPT4ge1xyXG5cdFx0XHRyZXR1cm4gX2ZpKGEsIGZ1bmN0aW9uICh4KSB7IHJldHVybiBfaXNlcSh4LCBiKSB9KTtcclxuXHRcdH1cclxuXHQvLyB0aGlzIHZlcnNpb24sIHdpdGhvdXQgdGhlIF9maSBkZXBlbmRlbmN5LCBkb2Vzbid0IHdvcmshdG9kb1xyXG5cdC8vICAsIG15SW5kZXhPZiA9IChhcnJheSwgaXRlbSkgPT4ge1xyXG5cdC8vIFx0XHRmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgYXJyYXkubGVuZ3RoOyBpbmRleCsrKSB7XHJcblx0Ly8gXHRcdFx0aWYgKF9pc2VxKGFycmF5W2luZGV4XSwgaXRlbSkpIHtcclxuXHQvLyBcdFx0XHRcdHJldHVybiBpbmRleDtcclxuXHJcblx0Ly8gXHRcdFx0fVxyXG5cdC8vIFx0XHRcdHJldHVybiAtMTtcclxuXHQvLyBcdFx0fVxyXG5cclxuXHQvLyBcdH1cclxuXHJcblx0Ly8gXHQsIF9jbG9uZSA9IHJlcXVpcmUoJ2xvZGFzaC9jbG9uZScpXHJcblxyXG5cclxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxyXG5cdC8vIGJvYXJkTW9kZSA9IG9wdGlvbnMuYm9hcmRNb2RlIHx8ICd0Jy8qdDp0b3JvaWQ7IGM6Y2xhc3NpYyDigKYqL1xyXG5cdC8vICwgYm9hcmREaW1lbnNpb25zID0gb3B0aW9ucy5ib2FyZERpbWVuc2lvbnMgfHwgWzExLCAxMV0vKm1vdmUgbGF0ZXIqL1xyXG5cdC8vICwgcnVsZXMgPSBvcHRpb25zLnJ1bGVzIHx8IHtcclxuXHQvLyBzdWljaWRlOiB0cnVlLFxyXG5cdC8vIHN1cGVya286IGZhbHNlXHJcblx0Ly8gfVxyXG5cdGxldCAkID0ge31cclxuXHQvLy8vcHJvYmxlbSB3aXRoIHRoZSBvYmplY3Qgc3ByZWFkIG9wZXJhdG9yIGFuZCB0aGUgYnVpbGQgc28gdXNpbmcgT2JqZWN0LmFzc2lnbiBpbnN0ZWFkLlxyXG5cdC8vICQucnVsZXMgPSB7XHJcblx0Ly8gXHRcdHN1aWNpZGU6IHRydWUsXHJcblx0Ly8gXHRcdC8vIHN1cGVya286IGZhbHNlIC8q4oeSdG9kbzogZW5mb3JjZSB3aGVuIHRydWU/Ki8sXHJcblx0Ly8gXHRcdGtvbWk6IDcuNSxcclxuXHQvLyBcdFx0Li4uIG9wdGlvbnMucnVsZXNcclxuXHQvLyBcdH1cclxuXHQkLnJ1bGVzID0gT2JqZWN0LmFzc2lnbih7fSwge1xyXG5cdFx0c3VpY2lkZTogdHJ1ZSxcclxuXHRcdC8vIHN1cGVya286IGZhbHNlIC8q4oeSdG9kbzogZW5mb3JjZSB3aGVuIHRydWU/Ki8sXHJcblx0XHRrb21pOiA3LjUsXHJcblx0fSwgb3B0aW9ucy5ydWxlcylcclxuXHJcblx0Ly8gJC5tb3ZlcyA9IG9wdGlvbnMubW92ZXMgfHwgW11cclxuXHQkLm9wdGlvbnMgPSBvcHRpb25zXHJcblx0b3B0aW9ucy5ib2FyZERpbWVuc2lvbnMgPSBvcHRpb25zLmJvYXJkRGltZW5zaW9ucyB8fCBbMTEsIDExXVxyXG5cdG9wdGlvbnMuYm9hcmRNb2RlID0gb3B0aW9ucy5ib2FyZE1vZGUgfHwgJ3QnLyp0OnRvcm9pZDsgYzpjbGFzc2ljIOKApiovXHJcblx0JC5ib2FyZCA9IHt9XHJcblx0JC5ib2FyZC5ibGFja1N0b25lcyA9IG9wdGlvbnMuYmxhY2tTdG9uZXMgfHwgW11cclxuXHQkLmJvYXJkLndoaXRlU3RvbmVzID0gb3B0aW9ucy53aGl0ZVN0b25lcyB8fCBbXVxyXG5cclxuXHQkLmJvYXJkLm5leHRQbGF5ZXIgPSBvcHRpb25zLm5leHRQbGF5ZXIgfHwgXCJiXCJcclxuXHQkLmJvYXJkLmNhcHR1cmVkID0gb3B0aW9ucy5jYXB0dXJlZCB8fCBbMCwgMF1cclxuXHJcblx0JC5leHBvcnREYXRhID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0YmxhY2tTdG9uZXM6ICQuYm9hcmQuYmxhY2tTdG9uZXMubWFwKF9jbG9uZSksXHJcblxyXG5cdFx0XHR3aGl0ZVN0b25lczogJC5ib2FyZC53aGl0ZVN0b25lcy5tYXAoX2Nsb25lKSxcclxuXHRcdFx0Y2FwdHVyZWQ6IF9jbG9uZSgkLmJvYXJkLmNhcHR1cmVkKSxcclxuXHRcdFx0bmV4dFBsYXllcjogJC5ib2FyZC5uZXh0UGxheWVyXHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQkLmxvYWREYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuXHRcdCQuYm9hcmQuYmxhY2tTdG9uZXMgPSBkYXRhLmJsYWNrU3RvbmVzXHJcblx0XHQkLmJvYXJkLndoaXRlU3RvbmVzID0gZGF0YS53aGl0ZVN0b25lc1xyXG5cdFx0JC5ib2FyZC5jYXB0dXJlZCA9IGRhdGEuY2FwdHVyZWRcclxuXHRcdCQuYm9hcmQubmV4dFBsYXllciA9IGRhdGEubmV4dFBsYXllclxyXG5cdH1cclxuXHJcblx0Ly90b3JvaWRcclxuXHRpZiAob3B0aW9ucy5ib2FyZE1vZGUgPT09ICd0JykgJC5ib2FyZC5nZXROZWlnaGJvdXJzID1cclxuXHRcdGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0XHRsZXQgcmVzdWx0ID0gW11cclxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcclxuXHRcdFx0XHRsZXQgbmV3UG9pbnRcclxuXHRcdFx0XHRzd2l0Y2ggKGkpIHtcclxuXHRcdFx0XHRcdGNhc2UgMDpcclxuXHRcdFx0XHRcdFx0bmV3UG9pbnQgPSBbcG9pbnRbMF0gKyAxLCBwb2ludFsxXV1cclxuXHRcdFx0XHRcdFx0YnJlYWtcclxuXHRcdFx0XHRcdGNhc2UgMTpcclxuXHRcdFx0XHRcdFx0bmV3UG9pbnQgPSBbcG9pbnRbMF0gLSAxLCBwb2ludFsxXV1cclxuXHRcdFx0XHRcdFx0YnJlYWtcclxuXHRcdFx0XHRcdGNhc2UgMjpcclxuXHRcdFx0XHRcdFx0bmV3UG9pbnQgPSBbcG9pbnRbMF0sIHBvaW50WzFdICsgMV1cclxuXHRcdFx0XHRcdFx0YnJlYWtcclxuXHRcdFx0XHRcdGNhc2UgMzpcclxuXHRcdFx0XHRcdFx0bmV3UG9pbnQgPSBbcG9pbnRbMF0sIHBvaW50WzFdIC0gMV1cclxuXHRcdFx0XHRcdFx0YnJlYWtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmVzdWx0LnB1c2goWyhuZXdQb2ludFswXSArIG9wdGlvbnMuYm9hcmREaW1lbnNpb25zWzBdKSAlIG9wdGlvbnMuYm9hcmREaW1lbnNpb25zWzBdLCAobmV3UG9pbnRbMV0gKyBvcHRpb25zLmJvYXJkRGltZW5zaW9uc1sxXSkgJSBvcHRpb25zLmJvYXJkRGltZW5zaW9uc1sxXV0pXHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHJlc3VsdFxyXG5cdFx0fVxyXG5cdGlmIChvcHRpb25zLmJvYXJkTW9kZSA9PT0gJ2MnKSAkLmJvYXJkLmdldE5laWdoYm91cnMgPVxyXG5cdFx0ZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRcdGxldCByZXN1bHQgPSBbXVxyXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xyXG5cdFx0XHRcdGxldCBuZXdQb2ludFxyXG5cdFx0XHRcdHN3aXRjaCAoaSkge1xyXG5cdFx0XHRcdFx0Y2FzZSAwOlxyXG5cdFx0XHRcdFx0XHRuZXdQb2ludCA9IFtwb2ludFswXSArIDEsIHBvaW50WzFdXVxyXG5cdFx0XHRcdFx0XHRicmVha1xyXG5cdFx0XHRcdFx0Y2FzZSAxOlxyXG5cdFx0XHRcdFx0XHRuZXdQb2ludCA9IFtwb2ludFswXSAtIDEsIHBvaW50WzFdXVxyXG5cdFx0XHRcdFx0XHRicmVha1xyXG5cdFx0XHRcdFx0Y2FzZSAyOlxyXG5cdFx0XHRcdFx0XHRuZXdQb2ludCA9IFtwb2ludFswXSwgcG9pbnRbMV0gKyAxXVxyXG5cdFx0XHRcdFx0XHRicmVha1xyXG5cdFx0XHRcdFx0Y2FzZSAzOlxyXG5cdFx0XHRcdFx0XHRuZXdQb2ludCA9IFtwb2ludFswXSwgcG9pbnRbMV0gLSAxXVxyXG5cdFx0XHRcdFx0XHRicmVha1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAobmV3UG9pbnRbMF0gPj0gMCAmJiBuZXdQb2ludFswXSA8IG9wdGlvbnMuYm9hcmREaW1lbnNpb25zWzBdXHJcblx0XHRcdFx0XHQmJiBuZXdQb2ludFsxXSA+PSAwICYmIG5ld1BvaW50WzFdIDwgb3B0aW9ucy5ib2FyZERpbWVuc2lvbnNbMV1cclxuXHRcdFx0XHQpXHJcblx0XHRcdFx0XHRyZXN1bHQucHVzaChuZXdQb2ludClcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gcmVzdWx0XHJcblx0XHR9XHJcblx0Ly90b2RvOiBrbGVpbiwgcHJvamVjdGl2ZSBwbGFuZSwg4oCmXHJcblxyXG5cdCQuYm9hcmQuaXNFbXB0eSA9IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIG15SW5kZXhPZigkLmJvYXJkLmJsYWNrU3RvbmVzLCBwb2ludCkgPCAwXHJcblx0XHRcdCYmIG15SW5kZXhPZigkLmJvYXJkLndoaXRlU3RvbmVzLCBwb2ludCkgPCAwXHJcblx0fVxyXG5cdCQuYm9hcmQuZ2V0Q29sb3VyID0gZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRpZiAobXlJbmRleE9mKCQuYm9hcmQuYmxhY2tTdG9uZXMsIHBvaW50KSA+PSAwKSByZXR1cm4gJ2InXHJcblx0XHRpZiAobXlJbmRleE9mKCQuYm9hcmQud2hpdGVTdG9uZXMsIHBvaW50KSA+PSAwKSByZXR1cm4gJ3cnXHJcblx0XHRyZXR1cm4gJ2UnXHJcblx0fVxyXG5cdC8qKlxyXG5cdCAqIERldGVybWluZXMgaWYgYSBwb2ludCBpcyBwYXJ0IG9mIGEgY2hhaW4gd2l0aCBhIGxpYmVydHk7IGlmIHRoZXJlIGFyZSBubyBsaWJlcnRpZXMgdGhlbiBpdCByZXR1cm5zIHRoZSBjaGFpbiBvZiBzdG9uZXMgb2YgdGhlIHNhbWUgY29sb3VyIHRoYXQgYXJlIGNvbm5lY3RlZCB0byBgc3RhcnRQb2ludGAuIEFsc28gdXNlZCBmb3IgY291bnRpbmcgdG8gcmV0dXJuIGNvbm5lY3RlZCBjb21wb25lbnRzIG9mIHNhbWUgY29sb3VyIChibGFjaywgd2hpdGUgb3IgZW1wdHkpLlxyXG5cdCAqIEBwYXJhbSB7Kn0gc3RhcnRQb2ludCBcclxuXHQgKiBAcGFyYW0ge3N0cmluZ3xudWxsfSBjaGFpbkNvbG91ciBpbmRpY2F0ZXMgdGhlIGNvbG91ciBvZiB0aGUgc3RhcnRpbmcgcG9pbnQuXHJcblx0ICogQHBhcmFtIHsqfSBbc3RvcENvbG91cj0nZSddIHN0b3Agd29ya2luZyBpZiB0aGUgY2hhaW4gbWVldHMgdGhpcyBjb2xvdXJcclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZ2V0Q29sb3VyPSQuYm9hcmQuZ2V0Q29sb3VyXSBGdW5jdGlvbiB1c2VkIHRvIGRldGVybWluZSB0aGUgY29sb3VyIG9mIGEgcG9pbnQuXHJcblx0ICogQHJldHVybnMge2Jvb2x8YXJyYXl9IFJldHVybnMgYHRydWVgIGlmIHRoZSB0aGUgY29tcG9uZW50IG1lZXRzIGBzdG9wQ29sb3VyYCwgYW5kIGFuIGFycmF5IGNvbnRhaW5pbmcgY29ubmVjdGVkIGNvbXBvbmVudCBvZiBwb2ludHMgbGlua2VkIHRvIGBzdGFydFBvaW50YCBvdGhlcndpc2UuIFxyXG5cdCAqL1x0XHJcblx0ZnVuY3Rpb24gY2hhaW5IYXNMaWJlcnR5IChzdGFydFBvaW50LCBjaGFpbkNvbG91ciwgc3RvcENvbG91ciwgZ2V0Q29sb3VyKSB7XHJcblx0XHRpZiAoc3RvcENvbG91ciA9PT0gdW5kZWZpbmVkKVxyXG5cdFx0XHRzdG9wQ29sb3VyID0gJ2UnLy9ieSBkZWZhdWx0LCBzdG9wIGdldHRpbmcgdGhlIGNoYWluIHdoZW4gdGhlcmUgaXMgYSBsaWJlcnR5LlxyXG5cdFx0aWYgKGdldENvbG91ciA9PT0gdW5kZWZpbmVkKVxyXG5cdFx0XHRnZXRDb2xvdXIgPSAkLmJvYXJkLmdldENvbG91ci8vYnkgZGVmYXVsdCwgdXNlIHRoZSB1c3VhbCBib2FyZCBjb2xvdXIgZnVuY3Rpb25cclxuXHJcblx0XHRpZiAoY2hhaW5Db2xvdXIgPT09IG51bGwpXHJcblx0XHRcdGNoYWluQ29sb3VyID0gZ2V0Q29sb3VyKHN0YXJ0UG9pbnQpXHJcblx0XHRsZXRcclxuXHRcdFx0Y2hhaW4gPSBbc3RhcnRQb2ludF1cclxuXHRcdFx0LCB0b0V4cGxvcmUgPSBbXVxyXG5cdFx0XHQsIHBvaW50ID0gc3RhcnRQb2ludCAvL2Fzc3VtZWQgdG8gYmUgb2YgY29sb3VyIGNoYWluQ29sb3VyXHJcblxyXG5cdFx0d2hpbGUgKHBvaW50ICE9PSB1bmRlZmluZWQpIHtcclxuXHJcblx0XHRcdGxldCBuZWlnaGJvdXJzID0gJC5ib2FyZC5nZXROZWlnaGJvdXJzKHBvaW50KVxyXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG5laWdoYm91cnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRsZXQgbmV3UG9pbnQgPSBuZWlnaGJvdXJzW2ldLFxyXG5cdFx0XHRcdFx0bmV3Q29sb3VyID0gZ2V0Q29sb3VyKG5ld1BvaW50KVxyXG5cdFx0XHRcdGlmIChuZXdDb2xvdXIgPT09IHN0b3BDb2xvdXIpIHJldHVybiB0cnVlO1xyXG5cdFx0XHRcdGlmIChuZXdDb2xvdXIgPT09IGNoYWluQ29sb3VyKSB7XHJcblx0XHRcdFx0XHRpZiAobXlJbmRleE9mKGNoYWluLCBuZXdQb2ludCkgPCAwKSB7XHJcblx0XHRcdFx0XHRcdGNoYWluLnB1c2gobmV3UG9pbnQpXHJcblx0XHRcdFx0XHRcdC8vIGlmIChteUluZGV4T2YodG9FeHBsb3JlLCBuZXdQb2ludCkgPCAwKVxyXG5cdFx0XHRcdFx0XHR0b0V4cGxvcmUucHVzaChuZXdQb2ludClcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0cG9pbnQgPSB0b0V4cGxvcmUucG9wKClcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gY2hhaW47XHJcblx0fVxyXG5cclxuXHQkLmJvYXJkLmNoYWluSGFzTGliZXJ0eSA9IGNoYWluSGFzTGliZXJ0eSBcclxuXHJcblx0JC5ib2FyZC5zY29yZSA9IGZ1bmN0aW9uIChkZWFkU3RvbmVzKSB7XHJcblx0XHQvKlxyXG5cdFx0Z28gdGhyb3VnaCB0aGUgd2hvbGUgYm9hcmQgXHJcblx0XHQqL1xyXG5cdFx0aWYgKGRlYWRTdG9uZXMgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRkZWFkU3RvbmVzID0gW11cclxuXHRcdH1cclxuXHJcblx0XHRsZXQgcmVzdWx0ID0ge1xyXG5cdFx0XHRibGFja0VtcHR5OiBbXVxyXG5cdFx0XHQsIHdoaXRlRW1wdHk6IFtdXHJcblx0XHRcdCwgZGFtZTogW11cclxuXHRcdFx0LCBibGFja0FsaXZlOiBbXVxyXG5cdFx0XHQsIHdoaXRlQWxpdmU6IFtdXHJcblx0XHRcdCwgYmxhY2tEZWFkOiBbXVxyXG5cdFx0XHQsIHdoaXRlRGVhZDogW11cclxuXHRcdFx0LCB0b3RhbEJsYWNrQ2FwdHVyZWQ6ICQuYm9hcmQuY2FwdHVyZWRbMF0gLy9uYiBCIHN0b25lcyByZW1vdmVkIGJ5IFcgZHVyaW5nIHRoZSBnYW1lXHJcblx0XHRcdCwgdG90YWxXaGl0ZUNhcHR1cmVkOiAkLmJvYXJkLmNhcHR1cmVkWzFdIC8vbmIgVyBzdG9uZXMgcmVtb3ZlZCBieSBCIGR1cmluZyB0aGUgZ2FtZVxyXG5cdFx0XHQvL3RvZG86Y291bGQgcmVwbGFjZSBieSBhbiBjbGFzcy4gZGF0YSBzdG9yZWQgaW4gYSBiaWcgYXJyYXkgb2YgcGFpcnMgW3BvaW50LCBzdGF0dXNdXHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGRlYWRTdG9uZXMubGVuZ3RoOyBpbmRleCsrKSB7XHJcblx0XHRcdGNvbnN0IGRlYWRTdG9uZSA9IGRlYWRTdG9uZXNbaW5kZXhdO1xyXG5cdFx0XHRsZXQgZGVhZENvbG91ciA9ICQuYm9hcmQuZ2V0Q29sb3VyKGRlYWRTdG9uZSlcclxuXHRcdFx0aWYgKGRlYWRDb2xvdXIgPT09ICdlJykgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIG1hcmtlZCBkZWFkIHN0b25lJylcclxuXHRcdFx0bGV0XHJcblx0XHRcdFx0ZGVhZFRvRmlsbCA9IGRlYWRDb2xvdXIgPT09ICdiJyA/IHJlc3VsdC5ibGFja0RlYWQgOiByZXN1bHQud2hpdGVEZWFkXHJcblx0XHRcdFx0LCBlbXB0eVRvRmlsbCA9IGRlYWRDb2xvdXIgPT09ICdiJyA/IHJlc3VsdC53aGl0ZUVtcHR5IDogcmVzdWx0LmJsYWNrRW1wdHlcclxuXHRcdFx0XHQsIGFsaXZlVG9GaWxsID0gZGVhZENvbG91ciA9PT0gJ2InID8gcmVzdWx0LndoaXRlQWxpdmUgOiByZXN1bHQuYmxhY2tBbGl2ZVxyXG5cdFx0XHRcdCwgcHJvY2Vzc1BvaW50ID0gKHBvaW50LCBjb2xvdXIpID0+IHtcclxuXHRcdFx0XHRcdGlmIChjb2xvdXIgPT09IGRlYWRDb2xvdXIgJiYgbXlJbmRleE9mKGRlYWRUb0ZpbGwsIHBvaW50KSA8IDApIHtcclxuXHRcdFx0XHRcdFx0ZGVhZFRvRmlsbC5wdXNoKHBvaW50KVxyXG5cdFx0XHRcdFx0XHRlbXB0eVRvRmlsbC5wdXNoKHBvaW50KVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKChjb2xvdXIgPT09IGRlYWRDb2xvdXIgfHwgY29sb3VyID09PSAnZScpICYmIG15SW5kZXhPZihlbXB0eVRvRmlsbCwgcG9pbnQpIDwgMCkge1xyXG5cdFx0XHRcdFx0XHRlbXB0eVRvRmlsbC5wdXNoKHBvaW50KVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKGNvbG91ciAhPT0gZGVhZENvbG91ciAmJiBjb2xvdXIgIT09ICdlJyAmJiBteUluZGV4T2YoYWxpdmVUb0ZpbGwsIHBvaW50KSA8IDApIHtcclxuXHRcdFx0XHRcdFx0YWxpdmVUb0ZpbGwucHVzaChwb2ludClcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0LCBnZXRDb2xvdXJGb3JEZWFkQ29tcG9uZW50ID0gKHBvaW50KSA9PiB7XHJcblx0XHRcdFx0XHRsZXQgY29sb3VyID0gJC5ib2FyZC5nZXRDb2xvdXIocG9pbnQpXHJcblx0XHRcdFx0XHRwcm9jZXNzUG9pbnQocG9pbnQsIGNvbG91cilcclxuXHRcdFx0XHRcdHJldHVybiBjb2xvdXIgPT09IGRlYWRDb2xvdXIgPyAnZScgOiBjb2xvdXJcclxuXHRcdFx0XHR9XHJcblx0XHRcdHByb2Nlc3NQb2ludChkZWFkU3RvbmUsIGRlYWRDb2xvdXIpXHJcblx0XHRcdCQuYm9hcmQuY2hhaW5IYXNMaWJlcnR5KGRlYWRTdG9uZSwgJ2UnLCAnJywgZ2V0Q29sb3VyRm9yRGVhZENvbXBvbmVudClcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKGxldCBpID0gMCxleGl0TG9vcCA9IGZhbHNlOyBpIDwgb3B0aW9ucy5ib2FyZERpbWVuc2lvbnNbMF07IGkrKykge1xyXG5cdFx0XHRpZiAoZXhpdExvb3ApIHtcclxuXHRcdFx0XHRicmVha1xyXG5cdFx0XHR9XHJcblx0XHRcdGZvciAobGV0IGogPSAwOyBqIDwgb3B0aW9ucy5ib2FyZERpbWVuc2lvbnNbMV07IGorKykge1xyXG5cdFx0XHRcdGlmIChyZXN1bHQuYmxhY2tFbXB0eS5sZW5ndGhcclxuXHRcdFx0XHRcdCsgcmVzdWx0LndoaXRlRW1wdHkubGVuZ3RoXHJcblx0XHRcdFx0XHQrIHJlc3VsdC5kYW1lLmxlbmd0aFxyXG5cdFx0XHRcdFx0KyByZXN1bHQuYmxhY2tBbGl2ZS5sZW5ndGhcclxuXHRcdFx0XHRcdCsgcmVzdWx0LndoaXRlQWxpdmUubGVuZ3RoXHJcblx0XHRcdFx0XHQvLyArIHJlc3VsdC5ibGFja0RlYWQubGVuZ3RoXHJcblx0XHRcdFx0XHQvLyArIHJlc3VsdC53aGl0ZURlYWQubGVuZ3RoXHJcblx0XHRcdFx0XHQ9PT0gb3B0aW9ucy5ib2FyZERpbWVuc2lvbnNbMF0gKiBvcHRpb25zLmJvYXJkRGltZW5zaW9uc1sxXVxyXG5cdFx0XHRcdCkge1xyXG5cdFx0XHRcdFx0ZXhpdExvb3AgPSB0cnVlXHJcblx0XHRcdFx0XHRicmVha1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRjb25zdCBwb2ludCA9IFtpLCBqXSwgY29sb3VyID0gJC5ib2FyZC5nZXRDb2xvdXIocG9pbnQpXHJcblxyXG5cdFx0XHRcdGlmIChjb2xvdXIgPT09ICdiJ1xyXG5cdFx0XHRcdCkge1xyXG5cdFx0XHRcdFx0aWYgKG15SW5kZXhPZihyZXN1bHQuYmxhY2tBbGl2ZSwgcG9pbnQpIDwgMFxyXG5cdFx0XHRcdFx0XHQmJiBteUluZGV4T2YocmVzdWx0LmJsYWNrRGVhZCwgcG9pbnQpIDwgMCkge1xyXG5cdFx0XHRcdFx0XHRyZXN1bHQuYmxhY2tBbGl2ZS5wdXNoKHBvaW50KVxyXG5cdFx0XHRcdFx0fSBlbHNlIGNvbnRpbnVlXHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmIChjb2xvdXIgPT09ICd3Jykge1xyXG5cdFx0XHRcdFx0aWYgKG15SW5kZXhPZihyZXN1bHQud2hpdGVBbGl2ZSwgcG9pbnQpIDwgMFxyXG5cdFx0XHRcdFx0XHQmJiBteUluZGV4T2YocmVzdWx0LndoaXRlRGVhZCwgcG9pbnQpIDwgMCkge1xyXG5cdFx0XHRcdFx0XHRyZXN1bHQud2hpdGVBbGl2ZS5wdXNoKHBvaW50KVxyXG5cdFx0XHRcdFx0fSBlbHNlIGNvbnRpbnVlXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoY29sb3VyID09PSAnZScpIHtcclxuXHRcdFx0XHRcdGlmIChteUluZGV4T2YocmVzdWx0LmJsYWNrRW1wdHksIHBvaW50KSA+PSAwXHJcblx0XHRcdFx0XHRcdHx8IG15SW5kZXhPZihyZXN1bHQud2hpdGVFbXB0eSwgcG9pbnQpID49IDBcclxuXHRcdFx0XHRcdFx0fHwgbXlJbmRleE9mKHJlc3VsdC5kYW1lLCBwb2ludCkgPj0gMCkge1xyXG5cdFx0XHRcdFx0XHRjb250aW51ZVxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGxldFxyXG5cdFx0XHRcdFx0XHRtZWV0c0JsYWNrID0gZmFsc2VcclxuXHRcdFx0XHRcdFx0LCBtZWV0c1doaXRlID0gZmFsc2VcclxuXHRcdFx0XHRcdFx0LCBpc0JsYWNrVGVycml0b3J5ID0gZmFsc2VcclxuXHRcdFx0XHRcdFx0LCBpc1doaXRlVGVycml0b3J5ID0gZmFsc2VcclxuXHRcdFx0XHRcdFx0LCBnZXRDb2xvdXJGb3JTY29yaW5nID0gKHBvaW50KSA9PiB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGxldCBjb2xvdXIgPSAkLmJvYXJkLmdldENvbG91cihwb2ludClcclxuXHRcdFx0XHRcdFx0XHRzd2l0Y2ggKGNvbG91cikge1xyXG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSAnYic6XHJcblx0XHRcdFx0XHRcdFx0XHRcdGlmIChteUluZGV4T2YocmVzdWx0LmJsYWNrRGVhZCwgcG9pbnQpID49IDApIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjb2xvdXIgPSAnZSdcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpc1doaXRlVGVycml0b3J5ID0gdHJ1ZVxyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG1lZXRzQmxhY2sgPSB0cnVlXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKG15SW5kZXhPZihyZXN1bHQuYmxhY2tBbGl2ZSwgcG9pbnQpIDwgMCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzdWx0LmJsYWNrQWxpdmUucHVzaChwb2ludClcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0XHRjYXNlICd3JzpcclxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKG15SW5kZXhPZihyZXN1bHQud2hpdGVEZWFkLCBwb2ludCkgPj0gMCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNvbG91ciA9ICdlJ1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlzQmxhY2tUZXJyaXRvcnkgPSB0cnVlXHJcblx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0bWVldHNXaGl0ZSA9IHRydWVcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAobXlJbmRleE9mKHJlc3VsdC53aGl0ZUFsaXZlLCBwb2ludCkgPCAwKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXN1bHQud2hpdGVBbGl2ZS5wdXNoKHBvaW50KVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0Oi8vbm90aGluZyBuZWVkZWQgZm9yICdlJ1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGNvbG91clxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRsZXQgZW1wdHlDb21wb25lbnQgPSAkLmJvYXJkLmNoYWluSGFzTGliZXJ0eShwb2ludCwgJ2UnLCAnJywgZ2V0Q29sb3VyRm9yU2NvcmluZylcclxuXHRcdFx0XHRcdGlmICghbWVldHNCbGFjayAmJiAhbWVldHNXaGl0ZSkge1xyXG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2NvdW50aW5nIGFuIGVtcHR5IGJvYXJkIScpXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiAoaXNCbGFja1RlcnJpdG9yeSAmJiBpc1doaXRlVGVycml0b3J5KSB7XHJcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcigndG9vIG1hbnkgc3RvbmVzIG1hcmtlZCBhcyBkZWFkJylcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdC8vY291bGQgc3RvcmUgdGhlIGRpZmZlcmVudCBlbXB0eSBjb21wb25lbnRzOiBWMiBcclxuXHRcdFx0XHRcdGlmIChtZWV0c0JsYWNrICYmIG1lZXRzV2hpdGUpIHtcclxuXHRcdFx0XHRcdFx0cmVzdWx0LmRhbWUgPSByZXN1bHQuZGFtZS5jb25jYXQoZW1wdHlDb21wb25lbnQpXHJcblx0XHRcdFx0XHRcdGNvbnRpbnVlXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiAobWVldHNCbGFjaykge1xyXG5cdFx0XHRcdFx0XHRyZXN1bHQuYmxhY2tFbXB0eSA9IHJlc3VsdC5ibGFja0VtcHR5LmNvbmNhdChlbXB0eUNvbXBvbmVudClcclxuXHRcdFx0XHRcdFx0Y29udGludWVcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmIChtZWV0c1doaXRlKSB7XHJcblx0XHRcdFx0XHRcdHJlc3VsdC53aGl0ZUVtcHR5ID0gcmVzdWx0LndoaXRlRW1wdHkuY29uY2F0KGVtcHR5Q29tcG9uZW50KVxyXG5cdFx0XHRcdFx0XHRjb250aW51ZVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0Ly90b3RhbHNcclxuXHRcdHJlc3VsdC50b3RhbEJsYWNrRGVhZCA9IHJlc3VsdC5ibGFja0RlYWQubGVuZ3RoXHJcblx0XHRyZXN1bHQudG90YWxXaGl0ZURlYWQgPSByZXN1bHQud2hpdGVEZWFkLmxlbmd0aFxyXG5cdFx0cmVzdWx0LnRvdGFsQmxhY2tUZXJyaXRvcnkgPSByZXN1bHQuYmxhY2tFbXB0eS5sZW5ndGhcclxuXHRcdHJlc3VsdC50b3RhbFdoaXRlVGVycml0b3J5ID0gcmVzdWx0LndoaXRlRW1wdHkubGVuZ3RoXHJcblxyXG5cclxuXHRcdC8vdG9kbzogaW1wbGVtZW50IG90aGVyIHJ1bGVzZXRzLiBGb3Igbm93LCBqdXN0IGRvIHRlcnJpdG9yeSArIHByaXNvbmVycyAoSmFwYW5lc2Ugc3R5bGUgY291bnRpbmcpXHJcblx0XHRyZXN1bHQuYmxhY2tTY29yZSA9XHJcblx0XHRcdHJlc3VsdC50b3RhbFdoaXRlRGVhZFxyXG5cdFx0XHQrIHJlc3VsdC50b3RhbFdoaXRlQ2FwdHVyZWRcclxuXHRcdFx0KyByZXN1bHQudG90YWxCbGFja1RlcnJpdG9yeVxyXG5cdFx0cmVzdWx0LndoaXRlU2NvcmUgPVxyXG5cdFx0XHRyZXN1bHQudG90YWxCbGFja0RlYWRcclxuXHRcdFx0KyByZXN1bHQudG90YWxCbGFja0NhcHR1cmVkXHJcblx0XHRcdCsgcmVzdWx0LnRvdGFsV2hpdGVUZXJyaXRvcnlcclxuXHRcdFx0KyAkLnJ1bGVzLmtvbWlcclxuXHRcdGxldCByID0gcmVzdWx0LmJsYWNrU2NvcmUgLSByZXN1bHQud2hpdGVTY29yZVxyXG5cdFx0aWYgKHIgPT09IDApIHJlc3VsdC5SRSA9ICcwJ1xyXG5cdFx0ZWxzZSBpZiAociA+IDApIHJlc3VsdC5SRSA9ICdCKycgKyByXHJcblx0XHRlbHNlIHJlc3VsdC5SRSA9ICdXKycgKyAoLXIpXHJcblx0XHRyZXR1cm4gcmVzdWx0XHJcblx0fVxyXG5cclxuXHQkLmJvYXJkLmVtcHR5ID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0JC5ib2FyZC53aGl0ZVN0b25lcyA9IFtdXHJcblx0XHQkLmJvYXJkLmJsYWNrU3RvbmVzID0gW11cclxuXHRcdCQuYm9hcmQuY2FwdHVyZWQgPSBbMCwgMF1cclxuXHJcblx0fVxyXG5cclxuXHQkLnJlbW92ZUNoYWluID0gZnVuY3Rpb24gKGNoYWluLCBjb2xvdXIpIHtcclxuXHRcdGxldCB0b1JlbW92ZUZyb20gPSBjb2xvdXIgPT09ICd3JyA/ICQuYm9hcmQud2hpdGVTdG9uZXMgOiAkLmJvYXJkLmJsYWNrU3RvbmVzXHJcblx0XHRmb3IgKGxldCBqID0gMDsgaiA8IGNoYWluLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdGxldCBpbmRleCA9IG15SW5kZXhPZih0b1JlbW92ZUZyb20sIGNoYWluW2pdKVxyXG5cdFx0XHR0b1JlbW92ZUZyb20uc3BsaWNlKGluZGV4LCAxKVxyXG5cdFx0XHRpZiAoY29sb3VyID09PSAndycpICQuYm9hcmQuY2FwdHVyZWRbMV0gPSAkLmJvYXJkLmNhcHR1cmVkWzFdICsgMVxyXG5cdFx0XHRlbHNlICQuYm9hcmQuY2FwdHVyZWRbMF0gPSAkLmJvYXJkLmNhcHR1cmVkWzBdICsgMVxyXG5cdFx0fVxyXG5cdH1cclxuXHQkLnBsYXkgPSBmdW5jdGlvbiAocGxheWVyQ29sb3VyLCBwb2ludCkge1xyXG5cclxuXHJcblxyXG5cdFx0Ly8gbGV0IHJlc3VsdCA9IFwib2tcIlxyXG5cdFx0aWYgKCEkLmJvYXJkLmlzRW1wdHkocG9pbnQpKVxyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ3BvaW50IGlzIG5vdCBlbXB0eScpXHJcblx0XHQvLyBjb25zb2xlLmxvZygncG9pbnQgaXMgbm90IGVtcHR5JyArIHBvaW50KVxyXG5cclxuXHRcdGlmIChwbGF5ZXJDb2xvdXIgPT09ICdiJykgJC5ib2FyZC5ibGFja1N0b25lcy5wdXNoKHBvaW50KVxyXG5cdFx0ZWxzZSAkLmJvYXJkLndoaXRlU3RvbmVzLnB1c2gocG9pbnQpXHJcblxyXG5cdFx0bGV0IG5laWdoYm91cnMgPSAkLmJvYXJkLmdldE5laWdoYm91cnMocG9pbnQpXHJcblx0XHRcdCwgcmVtb3ZlZCA9IFtdLy9jaGFpbnMgcmVtb3ZlZFxyXG5cclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbmVpZ2hib3Vycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRsZXQgbmVpZ2hib3VyID0gbmVpZ2hib3Vyc1tpXSwgY29sb3VyID0gJC5ib2FyZC5nZXRDb2xvdXIobmVpZ2hib3VyKVxyXG5cdFx0XHRpZiAoY29sb3VyID09PSBwbGF5ZXJDb2xvdXIgfHwgY29sb3VyID09PSAnZScpIGNvbnRpbnVlXHJcblx0XHRcdGxldCBvcHBDb2xvdXIgPSAkLmdldE9wcG9zaXRlQ29sb3VyKHBsYXllckNvbG91ciksXHJcblx0XHRcdFx0ciA9ICQuYm9hcmQuY2hhaW5IYXNMaWJlcnR5KG5laWdoYm91ciwgb3BwQ29sb3VyKVxyXG5cdFx0XHRpZiAociA9PT0gdHJ1ZSkgY29udGludWVcclxuXHRcdFx0Ly8vL3JlbW92ZSAtIG5vIGxpYmVydGllc1xyXG5cdFx0XHRyZW1vdmVkW3JlbW92ZWQubGVuZ3RoXSA9IHJcclxuXHJcblx0XHRcdCQucmVtb3ZlQ2hhaW4ociwgb3BwQ29sb3VyKVxyXG5cclxuXHRcdFx0Ly8gbGV0IGNoYWluVG9SZW1vdmUgPSByWzFdLFxyXG5cdFx0XHQvLyB0b1JlbW92ZUZyb20gPSBwbGF5ZXJDb2xvdXIgPT09ICdiJyA/ICQuYm9hcmQud2hpdGVTdG9uZXMgOiAkLmJvYXJkLmJsYWNrU3RvbmVzXHJcblx0XHRcdC8vIGZvciAobGV0IGogPSAwOyBqPGNoYWluVG9SZW1vdmUubGVuZ3RoOyBqKyspXHJcblx0XHRcdC8vIHtcclxuXHRcdFx0Ly8gbGV0IGluZGV4ID0gbXlJbmRleE9mKHRvUmVtb3ZlRnJvbSxjaGFpblRvUmVtb3ZlW2pdKVxyXG5cdFx0XHQvLyB0b1JlbW92ZUZyb20uc3BsaWNlKGluZGV4LCAxKVxyXG5cdFx0XHQvLyBpZiAocGxheWVyQ29sb3VyID09PSAnYicpICQuYm9hcmQuY2FwdHVyZWRbMV0gPSAkLmJvYXJkLmNhcHR1cmVkWzFdICsgMVxyXG5cdFx0XHQvLyBlbHNlICQuYm9hcmQuY2FwdHVyZWRbMF0gPSAkLmJvYXJkLmNhcHR1cmVkWzBdICsgMVxyXG5cdFx0XHQvLyB9XHJcblx0XHRcdC8vIHJlbW92ZWQgPSB0cnVlXHJcblx0XHR9XHJcblx0XHRsZXQgc3VpY2lkZSA9IGZhbHNlXHJcblx0XHRpZiAocmVtb3ZlZC5sZW5ndGggPT09IDApIHtcclxuXHRcdFx0bGV0IHMgPSAkLmJvYXJkLmNoYWluSGFzTGliZXJ0eShwb2ludCwgcGxheWVyQ29sb3VyKVxyXG5cdFx0XHRpZiAocyAhPT0gdHJ1ZSkge1xyXG5cdFx0XHRcdGlmICgkLnJ1bGVzLnN1aWNpZGUpIHtcclxuXHRcdFx0XHRcdCQucmVtb3ZlQ2hhaW4ocywgcGxheWVyQ29sb3VyKVxyXG5cdFx0XHRcdFx0c3VpY2lkZSA9IHNcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ3N1aWNpZGUnKS8vaXNu4oCZdCBhbGxvd2VkXHJcblx0XHRcdFx0XHQvL3RvZG86IHJlbW92ZSBwb2ludCBmcm9tIHdoaXRlU3RvbmVzIG9yIGJsYWNrU3RvbmVzXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0LypcclxuXHRcdFx0c3RvcmluZyB0aGUgc2l0dWF0aW9uIGluIG1lbW9yeSAtIHdvdWxkIGJlIHVzZWZ1bCB3aGVuIGltcGxlbWVudGluZyBnb2luZyBiYWNrIGEgbW92ZSwgc3VwZXJrbywg4oCmXHJcblx0XHRcdG5vdCBuZWVkZWQgZm9yIG5vd1xyXG5cdFx0Ki9cclxuXHRcdC8vJC5tb3Zlcy5wdXNoKFtwbGF5ZXJDb2xvdXIscG9pbnQsXy5jbG9uZSgkLmJvYXJkLndoaXRlU3RvbmVzKSxfLmNsb25lKCQuYm9hcmQuYmxhY2tTdG9uZXMpXSlcclxuXHRcdC8vICQubW92ZXMucHVzaChbcGxheWVyQ29sb3VyLHBvaW50XSlcclxuXHJcblx0XHQvLyBnZXROZWlnaGJvdXJzW2ldID0gW2dldE5laWdoYm91cnNbaV0sICQuYm9hcmQuZ2V0Q29sb3VyW2dldE5laWdoYm91cnNbaV1dXHJcblx0XHQvLyAvL+KAplxyXG5cclxuXHJcblx0XHRyZXR1cm4geyByZW1vdmVkLCBzdWljaWRlIH1cclxuXHR9XHJcblx0JC5nZXRPcHBvc2l0ZUNvbG91ciA9IGZ1bmN0aW9uIChjb2xvdXIpIHtcclxuXHRcdHN3aXRjaCAoY29sb3VyKSB7XHJcblx0XHRcdGNhc2UgJ2InOlxyXG5cdFx0XHRcdHJldHVybiAndydcclxuXHRcdFx0Y2FzZSAndyc6XHJcblx0XHRcdFx0cmV0dXJuICdiJ1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG51bGxcclxuXHR9XHJcblx0cmV0dXJuICRcclxuXHJcbn0iLCJ2YXIgYmFzZUluZGV4T2YgPSByZXF1aXJlKCcuL19iYXNlSW5kZXhPZicpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5pbmNsdWRlc2AgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBzcGVjaWZ5aW5nIGFuIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHRhcmdldGAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlJbmNsdWRlcyhhcnJheSwgdmFsdWUpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiYgYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCAwKSA+IC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5SW5jbHVkZXM7XG4iLCIvKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXJyYXlJbmNsdWRlc2AgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhIGNvbXBhcmF0b3IuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdGFyZ2V0YCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheUluY2x1ZGVzV2l0aChhcnJheSwgdmFsdWUsIGNvbXBhcmF0b3IpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChjb21wYXJhdG9yKHZhbHVlLCBhcnJheVtpbmRleF0pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5SW5jbHVkZXNXaXRoO1xuIiwidmFyIGFycmF5UHVzaCA9IHJlcXVpcmUoJy4vX2FycmF5UHVzaCcpLFxuICAgIGlzRmxhdHRlbmFibGUgPSByZXF1aXJlKCcuL19pc0ZsYXR0ZW5hYmxlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmxhdHRlbmAgd2l0aCBzdXBwb3J0IGZvciByZXN0cmljdGluZyBmbGF0dGVuaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkZXB0aCBUaGUgbWF4aW11bSByZWN1cnNpb24gZGVwdGguXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwcmVkaWNhdGU9aXNGbGF0dGVuYWJsZV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU3RyaWN0XSBSZXN0cmljdCB0byB2YWx1ZXMgdGhhdCBwYXNzIGBwcmVkaWNhdGVgIGNoZWNrcy5cbiAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHQ9W11dIFRoZSBpbml0aWFsIHJlc3VsdCB2YWx1ZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZUZsYXR0ZW4oYXJyYXksIGRlcHRoLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgcHJlZGljYXRlIHx8IChwcmVkaWNhdGUgPSBpc0ZsYXR0ZW5hYmxlKTtcbiAgcmVzdWx0IHx8IChyZXN1bHQgPSBbXSk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKGRlcHRoID4gMCAmJiBwcmVkaWNhdGUodmFsdWUpKSB7XG4gICAgICBpZiAoZGVwdGggPiAxKSB7XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGZsYXR0ZW4gYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIGJhc2VGbGF0dGVuKHZhbHVlLCBkZXB0aCAtIDEsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcnJheVB1c2gocmVzdWx0LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghaXNTdHJpY3QpIHtcbiAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGbGF0dGVuO1xuIiwidmFyIGJhc2VGaW5kSW5kZXggPSByZXF1aXJlKCcuL19iYXNlRmluZEluZGV4JyksXG4gICAgYmFzZUlzTmFOID0gcmVxdWlyZSgnLi9fYmFzZUlzTmFOJyksXG4gICAgc3RyaWN0SW5kZXhPZiA9IHJlcXVpcmUoJy4vX3N0cmljdEluZGV4T2YnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pbmRleE9mYCB3aXRob3V0IGBmcm9tSW5kZXhgIGJvdW5kcyBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZVxuICAgID8gc3RyaWN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleClcbiAgICA6IGJhc2VGaW5kSW5kZXgoYXJyYXksIGJhc2VJc05hTiwgZnJvbUluZGV4KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSW5kZXhPZjtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYU5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbnVtYmVyIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYE5hTmAsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTmFOO1xuIiwidmFyIFNldENhY2hlID0gcmVxdWlyZSgnLi9fU2V0Q2FjaGUnKSxcbiAgICBhcnJheUluY2x1ZGVzID0gcmVxdWlyZSgnLi9fYXJyYXlJbmNsdWRlcycpLFxuICAgIGFycmF5SW5jbHVkZXNXaXRoID0gcmVxdWlyZSgnLi9fYXJyYXlJbmNsdWRlc1dpdGgnKSxcbiAgICBjYWNoZUhhcyA9IHJlcXVpcmUoJy4vX2NhY2hlSGFzJyksXG4gICAgY3JlYXRlU2V0ID0gcmVxdWlyZSgnLi9fY3JlYXRlU2V0JyksXG4gICAgc2V0VG9BcnJheSA9IHJlcXVpcmUoJy4vX3NldFRvQXJyYXknKTtcblxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmlxQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuaXEoYXJyYXksIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgaXNDb21tb24gPSB0cnVlLFxuICAgICAgcmVzdWx0ID0gW10sXG4gICAgICBzZWVuID0gcmVzdWx0O1xuXG4gIGlmIChjb21wYXJhdG9yKSB7XG4gICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXNXaXRoO1xuICB9XG4gIGVsc2UgaWYgKGxlbmd0aCA+PSBMQVJHRV9BUlJBWV9TSVpFKSB7XG4gICAgdmFyIHNldCA9IGl0ZXJhdGVlID8gbnVsbCA6IGNyZWF0ZVNldChhcnJheSk7XG4gICAgaWYgKHNldCkge1xuICAgICAgcmV0dXJuIHNldFRvQXJyYXkoc2V0KTtcbiAgICB9XG4gICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICBpbmNsdWRlcyA9IGNhY2hlSGFzO1xuICAgIHNlZW4gPSBuZXcgU2V0Q2FjaGU7XG4gIH1cbiAgZWxzZSB7XG4gICAgc2VlbiA9IGl0ZXJhdGVlID8gW10gOiByZXN1bHQ7XG4gIH1cbiAgb3V0ZXI6XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUpIDogdmFsdWU7XG5cbiAgICB2YWx1ZSA9IChjb21wYXJhdG9yIHx8IHZhbHVlICE9PSAwKSA/IHZhbHVlIDogMDtcbiAgICBpZiAoaXNDb21tb24gJiYgY29tcHV0ZWQgPT09IGNvbXB1dGVkKSB7XG4gICAgICB2YXIgc2VlbkluZGV4ID0gc2Vlbi5sZW5ndGg7XG4gICAgICB3aGlsZSAoc2VlbkluZGV4LS0pIHtcbiAgICAgICAgaWYgKHNlZW5bc2VlbkluZGV4XSA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGl0ZXJhdGVlKSB7XG4gICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFpbmNsdWRlcyhzZWVuLCBjb21wdXRlZCwgY29tcGFyYXRvcikpIHtcbiAgICAgIGlmIChzZWVuICE9PSByZXN1bHQpIHtcbiAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVW5pcTtcbiIsInZhciBTZXQgPSByZXF1aXJlKCcuL19TZXQnKSxcbiAgICBub29wID0gcmVxdWlyZSgnLi9ub29wJyksXG4gICAgc2V0VG9BcnJheSA9IHJlcXVpcmUoJy4vX3NldFRvQXJyYXknKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc2V0IG9iamVjdCBvZiBgdmFsdWVzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYWRkIHRvIHRoZSBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgc2V0LlxuICovXG52YXIgY3JlYXRlU2V0ID0gIShTZXQgJiYgKDEgLyBzZXRUb0FycmF5KG5ldyBTZXQoWywtMF0pKVsxXSkgPT0gSU5GSU5JVFkpID8gbm9vcCA6IGZ1bmN0aW9uKHZhbHVlcykge1xuICByZXR1cm4gbmV3IFNldCh2YWx1ZXMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVTZXQ7XG4iLCIvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZyZWVHbG9iYWw7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzcHJlYWRhYmxlU3ltYm9sID0gU3ltYm9sID8gU3ltYm9sLmlzQ29uY2F0U3ByZWFkYWJsZSA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGZsYXR0ZW5hYmxlIGBhcmd1bWVudHNgIG9iamVjdCBvciBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmbGF0dGVuYWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0ZsYXR0ZW5hYmxlKHZhbHVlKSB7XG4gIHJldHVybiBpc0FycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkgfHxcbiAgICAhIShzcHJlYWRhYmxlU3ltYm9sICYmIHZhbHVlICYmIHZhbHVlW3NwcmVhZGFibGVTeW1ib2xdKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0ZsYXR0ZW5hYmxlO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uaW5kZXhPZmAgd2hpY2ggcGVyZm9ybXMgc3RyaWN0IGVxdWFsaXR5XG4gKiBjb21wYXJpc29ucyBvZiB2YWx1ZXMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gc3RyaWN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICB2YXIgaW5kZXggPSBmcm9tSW5kZXggLSAxLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0cmljdEluZGV4T2Y7XG4iLCJ2YXIgYmFzZUZsYXR0ZW4gPSByZXF1aXJlKCcuL19iYXNlRmxhdHRlbicpO1xuXG4vKipcbiAqIEZsYXR0ZW5zIGBhcnJheWAgYSBzaW5nbGUgbGV2ZWwgZGVlcC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmZsYXR0ZW4oWzEsIFsyLCBbMywgWzRdXSwgNV1dKTtcbiAqIC8vID0+IFsxLCAyLCBbMywgWzRdXSwgNV1cbiAqL1xuZnVuY3Rpb24gZmxhdHRlbihhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gIHJldHVybiBsZW5ndGggPyBiYXNlRmxhdHRlbihhcnJheSwgMSkgOiBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmbGF0dGVuO1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGB1bmRlZmluZWRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi4zLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5ub29wKTtcbiAqIC8vID0+IFt1bmRlZmluZWQsIHVuZGVmaW5lZF1cbiAqL1xuZnVuY3Rpb24gbm9vcCgpIHtcbiAgLy8gTm8gb3BlcmF0aW9uIHBlcmZvcm1lZC5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBub29wO1xuIiwidmFyIGJhc2VJdGVyYXRlZSA9IHJlcXVpcmUoJy4vX2Jhc2VJdGVyYXRlZScpLFxuICAgIGJhc2VVbmlxID0gcmVxdWlyZSgnLi9fYmFzZVVuaXEnKTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaXFgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IGluIGBhcnJheWAgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaFxuICogdW5pcXVlbmVzcyBpcyBjb21wdXRlZC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXMgZGV0ZXJtaW5lZCBieSB0aGVcbiAqIG9yZGVyIHRoZXkgb2NjdXIgaW4gdGhlIGFycmF5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDpcbiAqICh2YWx1ZSkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnVuaXFCeShbMi4xLCAxLjIsIDIuM10sIE1hdGguZmxvb3IpO1xuICogLy8gPT4gWzIuMSwgMS4yXVxuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy51bmlxQnkoW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCAneCcpO1xuICogLy8gPT4gW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH1dXG4gKi9cbmZ1bmN0aW9uIHVuaXFCeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYmFzZVVuaXEoYXJyYXksIGJhc2VJdGVyYXRlZShpdGVyYXRlZSwgMikpIDogW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdW5pcUJ5O1xuIiwiLyoqXG4gKiBDb252ZXJ0IFNHRiBmaWxlcyB0byBhIEpTIG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IHNnZiBBIHZhbGlkIFNHRiBmaWxlLlxuICogQHNlZSBodHRwOi8vd3d3LnJlZC1iZWFuLmNvbS9zZ2Yvc2dmNC5odG1sXG4gKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBTR0YgZmlsZSByZXByZXNlbnRlZCBhcyBhIEpTIG9iamVjdFxuICovXG5leHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKHNnZikge1xuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIHBhcnNlO1xuXHR2YXIgcGFyc2VyO1xuXHR2YXIgY29sbGVjdGlvbiA9IHt9O1xuXG5cdC8vIHRyYWNrcyB0aGUgY3VycmVudCBzZXF1ZW5jZVxuXHR2YXIgc2VxdWVuY2U7XG5cblx0Ly8gdHJhY2tzIHRoZSBjdXJyZW50IG5vZGVcblx0dmFyIG5vZGU7XG5cblx0Ly8gdHJhY2tzIHRoZSBsYXN0IFByb3BJZGVudFxuXHR2YXIgbGFzdFByb3BJZGVudDtcblxuXHQvLyBBIG1hcCBvZiBmdW5jdGlvbnMgdG8gcGFyc2UgdGhlIGRpZmZlcmVudCBjb21wb25lbnRzIG9mIGFuIFNHRiBmaWxlXG5cdHBhcnNlciA9IHtcblxuXHRcdGJlZ2luU2VxdWVuY2U6IGZ1bmN0aW9uIChzZ2YpIHtcblx0XHRcdHZhciBrZXkgPSAnc2VxdWVuY2VzJztcblxuXHRcdFx0Ly8gVG9wLWxldmVsIHNlcXVlbmNlcyBhcmUgZ2FtZVRyZWVzXG5cdFx0XHRpZiAoIXNlcXVlbmNlKSB7XG5cdFx0XHRcdHNlcXVlbmNlID0gY29sbGVjdGlvbjtcblx0XHRcdFx0a2V5ID0gJ2dhbWVUcmVlcyc7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChzZXF1ZW5jZS5nYW1lVHJlZXMpIHtcblx0XHRcdFx0a2V5ID0gJ2dhbWVUcmVlcyc7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBuZXdTZXF1ZW5jZSA9IHtcblx0XHRcdFx0cGFyZW50OiBzZXF1ZW5jZVxuXHRcdFx0fTtcblxuXHRcdFx0c2VxdWVuY2Vba2V5XSA9IHNlcXVlbmNlW2tleV0gfHwgW107XG5cdFx0XHRzZXF1ZW5jZVtrZXldLnB1c2gobmV3U2VxdWVuY2UpO1xuXHRcdFx0c2VxdWVuY2UgPSBuZXdTZXF1ZW5jZTtcblxuXHRcdFx0cmV0dXJuIHNnZi5zdWJzdHJpbmcoMSk7XG5cdFx0fSxcblxuXHRcdGVuZFNlcXVlbmNlOiBmdW5jdGlvbiAoc2dmKSB7XG5cdFx0XHRpZiAoc2VxdWVuY2UucGFyZW50KSB7XG5cdFx0XHRcdHNlcXVlbmNlID0gc2VxdWVuY2UucGFyZW50O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2VxdWVuY2UgPSBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHNnZi5zdWJzdHJpbmcoMSk7XG5cdFx0fSxcblxuXHRcdG5vZGU6IGZ1bmN0aW9uIChzZ2YpIHtcblx0XHRcdG5vZGUgPSB7fTtcblx0XHRcdHNlcXVlbmNlLm5vZGVzID0gc2VxdWVuY2Uubm9kZXMgfHwgW107XG5cdFx0XHRzZXF1ZW5jZS5ub2Rlcy5wdXNoKG5vZGUpO1xuXHRcdFx0cmV0dXJuIHNnZi5zdWJzdHJpbmcoMSk7XG5cdFx0fSxcblxuXHRcdHByb3BlcnR5OiBmdW5jdGlvbiAoc2dmKSB7XG5cdFx0XHR2YXIgcHJvcFZhbHVlO1xuXG5cdFx0XHQvLyBTZWFyY2ggZm9yIHRoZSBmaXJzdCB1bmVzY2FwZWQgXVxuXHRcdFx0dmFyIGZpcnN0UHJvcEVuZCA9IHNnZi5tYXRjaCgvKFteXFxcXFxcXV18XFxcXCgufFxcbnxcXHIpKSpcXF0vKTtcblxuXHRcdFx0aWYgKCFmaXJzdFByb3BFbmQubGVuZ3RoKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignbWFsZm9ybWVkIHNnZicpO1xuXHRcdFx0fVxuXG5cdFx0XHRmaXJzdFByb3BFbmQgPSBmaXJzdFByb3BFbmRbMF0ubGVuZ3RoO1xuXG5cdFx0XHR2YXIgcHJvcGVydHkgPSBzZ2Yuc3Vic3RyaW5nKDAsIGZpcnN0UHJvcEVuZCk7XG5cdFx0XHR2YXIgcHJvcFZhbHVlQmVnaW4gPSBwcm9wZXJ0eS5pbmRleE9mKCdbJyk7XG5cdFx0XHR2YXIgcHJvcElkZW50ID0gcHJvcGVydHkuc3Vic3RyaW5nKDAsIHByb3BWYWx1ZUJlZ2luKTtcblxuXHRcdFx0Ly8gUG9pbnQgbGlzdHMgZG9uJ3QgZGVjbGFyZSBhIFByb3BJZGVudCBmb3IgZWFjaCBQcm9wVmFsdWVcblx0XHRcdC8vIEluc3RlYWQsIHRoZXkgc2hvdWxkIHVzZSB0aGUgbGFzdCBkZWNsYXJlZCBwcm9wZXJ0eVxuXHRcdFx0Ly8gU2VlOiBodHRwOi8vd3d3LnJlZC1iZWFuLmNvbS9zZ2Yvc2dmNC5odG1sI21vdmUvcG9zXG5cdFx0XHRpZiAoIXByb3BJZGVudCkge1xuXHRcdFx0XHRwcm9wSWRlbnQgPSBsYXN0UHJvcElkZW50O1xuXG5cdFx0XHRcdC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IHByb3BlcnR5IGluIGEgbGlzdCBvZiBtdWx0aXBsZVxuXHRcdFx0XHQvLyBwcm9wZXJ0aWVzLCB3ZSBuZWVkIHRvIHdyYXAgdGhlIFByb3BWYWx1ZSBpbiBhbiBhcnJheVxuXHRcdFx0XHRpZiAoIUFycmF5LmlzQXJyYXkobm9kZVtwcm9wSWRlbnRdKSkge1xuXHRcdFx0XHRcdG5vZGVbcHJvcElkZW50XSA9IFtub2RlW3Byb3BJZGVudF1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGxhc3RQcm9wSWRlbnQgPSBwcm9wSWRlbnQ7XG5cblx0XHRcdHByb3BWYWx1ZSA9IHByb3BlcnR5LnN1YnN0cmluZyhwcm9wVmFsdWVCZWdpbiArIDEsIHByb3BlcnR5Lmxlbmd0aCAtIDEpO1xuXG5cdFx0XHQvLyBXZSBoYXZlIG5vIHByb2JsZW0gcGFyc2luZyBQcm9wSWRlbnRzIG9mIGFueSBsZW5ndGgsIGJ1dCB0aGUgc3BlY1xuXHRcdFx0Ly8gc2F5cyB0aGV5IHNob3VsZCBiZSBubyBsb25nZXIgdGhhbiB0d28gY2hhcmFjdGVycy5cblx0XHRcdC8vXG5cdFx0XHQvLyBodHRwOi8vd3d3LnJlZC1iZWFuLmNvbS9zZ2Yvc2dmNC5odG1sIzIuMlxuXHRcdFx0aWYgKHByb3BJZGVudC5sZW5ndGggPiAyKSB7XG5cdFx0XHRcdC8vIFRPRE86IFdoYXQncyB0aGUgYmVzdCB3YXkgdG8gaXNzdWUgYSB3YXJuaW5nP1xuXHRcdFx0XHRjb25zb2xlLndhcm4oXG5cdFx0XHRcdFx0J1NHRiBQcm9wSWRlbnRzIHNob3VsZCBiZSBubyBsb25nZXIgdGhhbiB0d28gY2hhcmFjdGVyczonLCBwcm9wSWRlbnRcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkobm9kZVtwcm9wSWRlbnRdKSkge1xuXHRcdFx0XHRub2RlW3Byb3BJZGVudF0ucHVzaChwcm9wVmFsdWUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bm9kZVtwcm9wSWRlbnRdID0gcHJvcFZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc2dmLnN1YnN0cmluZyhmaXJzdFByb3BFbmQpO1xuXHRcdH0sXG5cblx0XHQvLyBXaGl0ZXNwYWNlLCB0YWJzLCBvciBhbnl0aGluZyBlbHNlIHdlIGRvbid0IHJlY29nbml6ZVxuXHRcdHVucmVjb2duaXplZDogZnVuY3Rpb24gKHNnZikge1xuXG5cdFx0XHQvLyBNYXJjaCBhaGVhZCB0byB0aGUgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdHJldHVybiBzZ2Yuc3Vic3RyaW5nKDEpO1xuXHRcdH1cblx0fTtcblxuXHQvLyBQcm9jZXNzZXMgYW4gU0dGIGZpbGUgY2hhcmFjdGVyIGJ5IGNoYXJhY3RlclxuXHRwYXJzZSA9IGZ1bmN0aW9uIChzZ2YpIHtcblx0XHR3aGlsZSAoc2dmKSB7XG5cdFx0XHR2YXIgaW5pdGlhbCA9IHNnZi5zdWJzdHJpbmcoMCwgMSk7XG5cdFx0XHR2YXIgdHlwZTtcblxuXHRcdFx0Ly8gVXNlIHRoZSBpbml0aWFsICh0aGUgZmlyc3QgY2hhcmFjdGVyIGluIHRoZSByZW1haW5pbmcgc2dmIGZpbGUpIHRvXG5cdFx0XHQvLyBkZWNpZGUgd2hpY2ggcGFyc2VyIGZ1bmN0aW9uIHRvIHVzZVxuXHRcdFx0aWYgKGluaXRpYWwgPT09ICcoJykge1xuXHRcdFx0XHR0eXBlID0gJ2JlZ2luU2VxdWVuY2UnO1xuXHRcdFx0fSBlbHNlIGlmIChpbml0aWFsID09PSAnKScpIHtcblx0XHRcdFx0dHlwZSA9ICdlbmRTZXF1ZW5jZSc7XG5cdFx0XHR9IGVsc2UgaWYgKGluaXRpYWwgPT09ICc7Jykge1xuXHRcdFx0XHR0eXBlID0gJ25vZGUnO1xuXHRcdFx0fSBlbHNlIGlmIChpbml0aWFsLnNlYXJjaCgvW0EtWlxcW10vKSAhPT0gLTEpIHtcblx0XHRcdFx0dHlwZSA9ICdwcm9wZXJ0eSc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0eXBlID0gJ3VucmVjb2duaXplZCc7XG5cdFx0XHR9XG5cblx0XHRcdHNnZiA9IHBhcnNlclt0eXBlXShzZ2YpO1xuXHRcdH1cblxuXHRcdHJldHVybiBjb2xsZWN0aW9uO1xuXHR9O1xuXG5cdC8vIEJlZ2luIHBhcnNpbmcgdGhlIFNHRiBmaWxlXG5cdHJldHVybiBwYXJzZShzZ2YpO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhbiBTR0YgZmlsZSBmcm9tIGEgU21hcnRHYW1lIFJlY29yZCBKYXZhU2NyaXB0IE9iamVjdFxuICogQHBhcmFtIHtvYmplY3R9IHJlY29yZCBBIHJlY29yZCBvYmplY3QuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSByZWNvcmQgYXMgYSBzdHJpbmcgc3VpdGFibGUgZm9yIHNhdmluZyBhcyBhbiBTR0YgZmlsZVxuICovXG5leHBvcnRzLmdlbmVyYXRlID0gZnVuY3Rpb24gKHJlY29yZCkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0ZnVuY3Rpb24gc3RyaW5naWZ5U2VxdWVuY2VzKHNlcXVlbmNlcykge1xuXHRcdHZhciBjb250ZW50cyA9ICcnO1xuXG5cdFx0c2VxdWVuY2VzLmZvckVhY2goZnVuY3Rpb24gKHNlcXVlbmNlKSB7XG5cdFx0XHRjb250ZW50cyArPSAnKCc7XG5cblx0XHRcdC8vIFBhcnNlIGFsbCBub2RlcyBpbiB0aGlzIHNlcXVlbmNlXG5cdFx0XHRpZiAoc2VxdWVuY2Uubm9kZXMpIHtcblx0XHRcdFx0c2VxdWVuY2Uubm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuXHRcdFx0XHRcdHZhciBub2RlU3RyaW5nID0gJzsnO1xuXHRcdFx0XHRcdGZvciAodmFyIHByb3BlcnR5IGluIG5vZGUpIHtcblx0XHRcdFx0XHRcdGlmIChub2RlLmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuXHRcdFx0XHRcdFx0XHR2YXIgcHJvcCA9IG5vZGVbcHJvcGVydHldO1xuXHRcdFx0XHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheShwcm9wKSkge1xuXHRcdFx0XHRcdFx0XHRcdHByb3AgPSBwcm9wLmpvaW4oJ11bJyk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0bm9kZVN0cmluZyArPSBwcm9wZXJ0eSArICdbJyArIHByb3AgKyAnXSc7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNvbnRlbnRzICs9IG5vZGVTdHJpbmc7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYWxsIHRoZSBmdW5jdGlvbiB3ZSdyZSBpbiByZWN1cnNpdmVseSBmb3IgYW55IGNoaWxkIHNlcXVlbmNlc1xuXHRcdFx0aWYgKHNlcXVlbmNlLnNlcXVlbmNlcykge1xuXHRcdFx0XHRjb250ZW50cyArPSBzdHJpbmdpZnlTZXF1ZW5jZXMoc2VxdWVuY2Uuc2VxdWVuY2VzKTtcblx0XHRcdH1cblxuXHRcdFx0Y29udGVudHMgKz0gJyknO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIGNvbnRlbnRzO1xuXHR9XG5cblx0cmV0dXJuIHN0cmluZ2lmeVNlcXVlbmNlcyhyZWNvcmQuZ2FtZVRyZWVzKTtcbn07XG5cbiIsIi8qKlxuICogSW50ZXJhY3Qgd2l0aCBzbWFydGdhbWUgb2JqZWN0cy5cbiAqIEBwYXJhbSB7b2JqZWN0fSBzbWFydGdhbWUgQSBKUyBPYmplY3QgcmVwcmVzZW50aW5nIGEgc21hcnRnYW1lXG4gKiBAc2VlIGh0dHA6Ly93d3cucmVkLWJlYW4uY29tL3NnZi9zZ2Y0Lmh0bWxcbiAqIEByZXR1cm4ge29iamVjdH0gQW4gb2JqZWN0IHdpdGggbWV0aG9kcyBmb3IgbmF2aWdhdGluZyBhbmQgbWFuaXB1bGF0aW5nIGFcbiAqIHNtYXJ0Z2FtZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzbWFydGdhbWUpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBzZXF1ZW5jZTtcblx0dmFyIG5vZGU7XG5cblx0dmFyIFNtYXJ0Z2FtZXIgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5pbml0KCk7XG5cdH07XG5cblx0U21hcnRnYW1lci5wcm90b3R5cGUgPSB7XG5cdFx0aW5pdDogZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKHNtYXJ0Z2FtZSkge1xuXHRcdFx0XHR0aGlzLmdhbWUgPSBzbWFydGdhbWUuZ2FtZVRyZWVzWzBdO1xuXHRcdFx0XHR0aGlzLnJlc2V0KCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vIExvYWQgYSBzbWFydGdhbWUgdG8gbWFrZSBpdCBwb3NzaWJsZSB0byBsb2FkIG5ldyBnYW1lcyBvciBhZGQgb25lIGFmdGVyXG5cdFx0Ly8gaW5pdGlhbGl6YXRpb24sIGlmIGRlc2lyZWRcblx0XHRsb2FkOiBmdW5jdGlvbiAobmV3U21hcnRnYW1lKSB7XG5cdFx0XHRzbWFydGdhbWUgPSBuZXdTbWFydGdhbWU7XG5cdFx0XHR0aGlzLmluaXQoKTtcblx0XHR9LFxuXG5cdFx0Ly8gSGF2aW5nIG11bHRpcGxlIGdhbWVzIGluIGEgY29sbGVjdGlvbiBpcyBub3QgY29tbW9uLCBidXQgaXQncyBwYXJ0IG9mXG5cdFx0Ly8gdGhlIHNwZWNcblx0XHRnYW1lczogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIHNtYXJ0Z2FtZS5nYW1lVHJlZXM7XG5cdFx0fSxcblxuXHRcdHNlbGVjdEdhbWU6IGZ1bmN0aW9uIChpKSB7XG5cdFx0XHRpZiAoaSA8IHNtYXJ0Z2FtZS5nYW1lVHJlZXMubGVuZ3RoKSB7XG5cdFx0XHRcdHRoaXMuZ2FtZSA9IHNtYXJ0Z2FtZS5nYW1lVHJlZXNbaV07XG5cdFx0XHRcdHRoaXMucmVzZXQoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcigndGhlIGNvbGxlY3Rpb24gZG9lc25cXCd0IGNvbnRhaW4gdGhhdCBtYW55IGdhbWVzJyk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cblx0XHRyZXNldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0c2VxdWVuY2UgPSB0aGlzLmdhbWU7XG5cdFx0XHRub2RlID0gc2VxdWVuY2Uubm9kZXNbMF07XG5cdFx0XHR0aGlzLnBhdGggPSB7IG06IDAgfTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXHRcdGdldFNtYXJ0Z2FtZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIHNtYXJ0Z2FtZTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJuIGFueSB2YXJpYXRpb25zIGF2YWlsYWJsZSBhdCB0aGUgY3VycmVudCBtb3ZlXG5cdFx0ICoqL1xuXHRcdHZhcmlhdGlvbnM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmIChzZXF1ZW5jZSkge1xuXHRcdFx0XHR2YXIgbG9jYWxOb2RlcyA9IHNlcXVlbmNlLm5vZGVzO1xuXHRcdFx0XHR2YXIgbG9jYWxJbmRleCA9IChsb2NhbE5vZGVzKSA/IGxvY2FsTm9kZXMuaW5kZXhPZihub2RlKSA6IG51bGw7XG5cblx0XHRcdFx0aWYgKGxvY2FsTm9kZXMpIHtcblx0XHRcdFx0XHRpZiAobG9jYWxJbmRleCA9PT0gKGxvY2FsTm9kZXMubGVuZ3RoIC0gMSkpIHtcblx0XHRcdFx0XHRcdHJldHVybiBzZXF1ZW5jZS5zZXF1ZW5jZXMgfHwgW107XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogR28gdG8gdGhlIG5leHQgbW92ZVxuXHRcdCAqKi9cblx0XHRuZXh0OiBmdW5jdGlvbiAodmFyaWF0aW9uKSB7XG5cdFx0XHR2YXJpYXRpb24gPSB2YXJpYXRpb24gfHwgMDtcblxuXHRcdFx0dmFyIGxvY2FsTm9kZXMgPSBzZXF1ZW5jZS5ub2Rlcztcblx0XHRcdHZhciBsb2NhbEluZGV4ID0gKGxvY2FsTm9kZXMpID8gbG9jYWxOb2Rlcy5pbmRleE9mKG5vZGUpIDogbnVsbDtcblxuXHRcdFx0Ly8gSWYgdGhlcmUgYXJlIG5vIGFkZGl0aW9uYWwgbm9kZXMgaW4gdGhpcyBzZXF1ZW5jZSxcblx0XHRcdC8vIGFkdmFuY2UgdG8gdGhlIG5leHQgb25lXG5cdFx0XHRpZiAobG9jYWxJbmRleCA9PT0gbnVsbCB8fCBsb2NhbEluZGV4ID49IChsb2NhbE5vZGVzLmxlbmd0aCAtIDEpKSB7XG5cdFx0XHRcdGlmIChzZXF1ZW5jZS5zZXF1ZW5jZXMpIHtcblx0XHRcdFx0XHRpZiAoc2VxdWVuY2Uuc2VxdWVuY2VzW3ZhcmlhdGlvbl0pIHtcblx0XHRcdFx0XHRcdHNlcXVlbmNlID0gc2VxdWVuY2Uuc2VxdWVuY2VzW3ZhcmlhdGlvbl07XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNlcXVlbmNlID0gc2VxdWVuY2Uuc2VxdWVuY2VzWzBdO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG5vZGUgPSBzZXF1ZW5jZS5ub2Rlc1swXTtcblxuXHRcdFx0XHRcdC8vIE5vdGUgdGhlIGZvcmsgY2hvc2VuIGZvciB0aGlzIHZhcmlhdGlvbiBpbiB0aGUgcGF0aFxuXHRcdFx0XHRcdHRoaXMucGF0aFt0aGlzLnBhdGgubV0gPSB2YXJpYXRpb247XG5cdFx0XHRcdFx0dGhpcy5wYXRoLm0gKz0gMTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBFbmQgb2Ygc2VxdWVuY2UgLyBnYW1lXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5vZGUgPSBsb2NhbE5vZGVzW2xvY2FsSW5kZXggKyAxXTtcblx0XHRcdFx0dGhpcy5wYXRoLm0gKz0gMTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEdvIHRvIHRoZSBwcmV2aW91cyBtb3ZlXG5cdFx0ICoqL1xuXHRcdHByZXZpb3VzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgbG9jYWxOb2RlcyA9IHNlcXVlbmNlLm5vZGVzO1xuXHRcdFx0dmFyIGxvY2FsSW5kZXggPSAobG9jYWxOb2RlcykgPyBsb2NhbE5vZGVzLmluZGV4T2Yobm9kZSkgOiBudWxsO1xuXG5cdFx0XHQvLyBEZWxldGUgYW55IHZhcmlhdGlvbiBmb3JrcyBhdCB0aGlzIHBvaW50XG5cdFx0XHQvLyBUT0RPOiBNYWtlIHRoaXMgY29uZmlndXJhYmxlLi4uIHdlIHNob3VsZCBrZWVwIHRoaXMgaWYgd2UncmVcblx0XHRcdC8vIHJlbWVtYmVyaW5nIGNob3NlbiBwYXRoc1xuXHRcdFx0ZGVsZXRlIHRoaXMucGF0aFt0aGlzLnBhdGgubV07XG5cblx0XHRcdGlmICghbG9jYWxJbmRleCB8fCBsb2NhbEluZGV4ID09PSAwKSB7XG5cdFx0XHRcdGlmIChzZXF1ZW5jZS5wYXJlbnQgJiYgIXNlcXVlbmNlLnBhcmVudC5nYW1lVHJlZXMpIHtcblx0XHRcdFx0XHRzZXF1ZW5jZSA9IHNlcXVlbmNlLnBhcmVudDtcblx0XHRcdFx0XHRpZiAoc2VxdWVuY2Uubm9kZXMpIHtcblx0XHRcdFx0XHRcdG5vZGUgPSBzZXF1ZW5jZS5ub2Rlc1tzZXF1ZW5jZS5ub2Rlcy5sZW5ndGggLSAxXTtcblx0XHRcdFx0XHRcdHRoaXMucGF0aC5tIC09IDE7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG5vZGUgPSBudWxsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBBbHJlYWR5IGF0IHRoZSBiZWdpbm5pbmdcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bm9kZSA9IGxvY2FsTm9kZXNbbG9jYWxJbmRleCAtIDFdO1xuXHRcdFx0XHR0aGlzLnBhdGgubSAtPSAxO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0Ly8gR28gdG8gdGhlIGxhc3QgbW92ZSBvZiB0aGUgZ2FtZVxuXHRcdGxhc3Q6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciB0b3RhbE1vdmVzID0gdGhpcy50b3RhbE1vdmVzKCk7XG5cblx0XHRcdHdoaWxlKHRoaXMucGF0aC5tIDwgdG90YWxNb3Zlcykge1xuXHRcdFx0XHR0aGlzLm5leHQoKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXHRcdC8vIEdvIHRvIHRoZSBmaXJzdCBtb3ZlIG9mIHRoZSBnYW1lXG5cdFx0Zmlyc3Q6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMucmVzZXQoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBHbyB0byBhIHBhcnRpY3VsYXIgbW92ZSwgc3BlY2lmaWVkIGFzIGFcblx0XHQgKiBhKSBudW1iZXJcblx0XHQgKiBiKSBwYXRoIHN0cmluZ1xuXHRcdCAqIGMpIHBhdGggb2JqZWN0XG5cdFx0ICoqL1xuXHRcdGdvVG86IGZ1bmN0aW9uIChwYXRoKSB7XG5cdFx0XHRpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdHBhdGggPSB0aGlzLnBhdGhUcmFuc2Zvcm0ocGF0aCwgJ29iamVjdCcpO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgcGF0aCA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0cGF0aCA9IHsgbTogcGF0aCB9O1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnJlc2V0KCk7XG5cblx0XHRcdHZhciBuID0gbm9kZTtcblxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLm0gJiYgbjsgaSArPSAxKSB7XG5cdFx0XHRcdC8vIENoZWNrIGZvciBhIHZhcmlhdGlvbiBpbiB0aGUgcGF0aCBmb3IgdGhlIHVwY29taW5nIG1vdmVcblx0XHRcdFx0dmFyIHZhcmlhdGlvbiA9IHBhdGhbaSArIDFdIHx8IDA7XG5cdFx0XHRcdG4gPSB0aGlzLm5leHQodmFyaWF0aW9uKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXHRcdGdldEdhbWVJbmZvOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nYW1lLm5vZGVzWzBdO1xuXHRcdH0sXG5cblx0XHQvLyBQcm92aWRlIHRoZSBjdXJyZW50IG5vZGVcblx0XHRub2RlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gbm9kZTtcblx0XHR9LFxuXG5cdFx0Ly8gR2V0IHRoZSB0b3RhbCBudW1iZXIgb2YgbW92ZXMgaW4gYSBnYW1lXG5cdFx0dG90YWxNb3ZlczogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGxvY2FsU2VxdWVuY2UgPSB0aGlzLmdhbWU7XG5cdFx0XHR2YXIgbW92ZXMgPSAwO1xuXHRcdFx0d2hpbGUobG9jYWxTZXF1ZW5jZSkge1xuXHRcdFx0XHRtb3ZlcyArPSBsb2NhbFNlcXVlbmNlLm5vZGVzLmxlbmd0aDtcblxuXHRcdFx0XHRpZiAobG9jYWxTZXF1ZW5jZS5zZXF1ZW5jZXMpIHtcblx0XHRcdFx0XHRsb2NhbFNlcXVlbmNlID0gbG9jYWxTZXF1ZW5jZS5zZXF1ZW5jZXNbMF07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bG9jYWxTZXF1ZW5jZSA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVE9ETzogUmlnaHQgbm93IHdlJ3JlICphc3N1bWluZyogdGhhdCB0aGUgcm9vdCBub2RlIGRvZXNuJ3QgaGF2ZSBhXG5cdFx0XHQvLyBtb3ZlIGluIGl0LCB3aGljaCBpcyAqcmVjb21tZW5kZWQqIGJ1dCBub3QgcmVxdWlyZWQgcHJhY3RpY2UuXG5cdFx0XHQvLyBAc2VlIGh0dHA6Ly93d3cucmVkLWJlYW4uY29tL3NnZi9zZ2Y0Lmh0bWxcblx0XHRcdC8vIFwiTm90ZTogaXQncyBiYWQgc3R5bGUgdG8gaGF2ZSBtb3ZlIHByb3BlcnRpZXMgaW4gcm9vdCBub2Rlcy5cblx0XHRcdC8vIChpdCBpc24ndCBmb3JiaWRkZW4gdGhvdWdoKVwiXG5cdFx0XHRyZXR1cm4gbW92ZXMgLSAxO1xuXHRcdH0sXG5cblx0XHQvLyBHZXQgb3Igc2V0IGEgY29tbWVudCBvbiB0aGUgY3VycmVudCBub2RlXG5cdFx0Ly8gQHNlZSBodHRwOi8vd3d3LnJlZC1iZWFuLmNvbS9zZ2Yvc2dmNC5odG1sI3RleHRcblx0XHRjb21tZW50OiBmdW5jdGlvbiAodGV4dCkge1xuXHRcdFx0aWYgKHR5cGVvZiB0ZXh0ID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHQvLyBVbmVzY2FwZSBjaGFyYWN0ZXJzXG5cdFx0XHRcdGlmIChub2RlLkMpIHtcblx0XHRcdFx0XHRyZXR1cm4gbm9kZS5DLnJlcGxhY2UoL1xcXFwoW1xcXFw6XFxdXSkvZywgJyQxJyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuICcnO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBFc2NhcGUgY2hhcmFjdGVyc1xuXHRcdFx0XHRub2RlLkMgPSB0ZXh0LnJlcGxhY2UoL1tcXFxcOlxcXV0vZywgJ1xcXFwkJicpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBUcmFuc2xhdGUgYWxwaGEgY29vcmRpbmF0ZXMgaW50byBhbiBhcnJheVxuXHRcdCAqIEBwYXJhbSBzdHJpbmcgYWxwaGFDb29yZGluYXRlc1xuXHRcdCAqIEByZXR1cm4gYXJyYXkgW3gsIHldXG5cdFx0ICoqL1xuXHRcdHRyYW5zbGF0ZUNvb3JkaW5hdGVzOiBmdW5jdGlvbiAoYWxwaGFDb29yZGluYXRlcykge1xuXHRcdFx0dmFyIGNvb3JkaW5hdGVMYWJlbHMgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xuXHRcdFx0dmFyIGludGVyc2VjdGlvbiA9IFtdO1xuXG5cdFx0XHRpbnRlcnNlY3Rpb25bMF0gPSBjb29yZGluYXRlTGFiZWxzLmluZGV4T2YoYWxwaGFDb29yZGluYXRlcy5zdWJzdHJpbmcoMCwgMSkpO1xuXHRcdFx0aW50ZXJzZWN0aW9uWzFdID0gY29vcmRpbmF0ZUxhYmVscy5pbmRleE9mKGFscGhhQ29vcmRpbmF0ZXMuc3Vic3RyaW5nKDEsIDIpKTtcblxuXHRcdFx0cmV0dXJuIGludGVyc2VjdGlvbjtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQ29udmVydCBwYXRoIG9iamVjdHMgdG8gc3RyaW5ncyBhbmQgcGF0aCBzdHJpbmdzIHRvIG9iamVjdHNcblx0XHQgKiovXG5cdFx0cGF0aFRyYW5zZm9ybTogZnVuY3Rpb24gKGlucHV0LCBvdXRwdXRUeXBlLCB2ZXJib3NlKSB7XG5cdFx0XHR2YXIgb3V0cHV0O1xuXG5cdFx0XHQvLyBJZiBubyBvdXRwdXQgdHlwZSBoYXMgYmVlbiBzcGVjaWZpZWQsIHRyeSB0byBzZXQgaXQgdG8gdGhlXG5cdFx0XHQvLyBvcHBvc2l0ZSBvZiB0aGUgaW5wdXRcblx0XHRcdGlmICh0eXBlb2Ygb3V0cHV0VHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0b3V0cHV0VHlwZSA9ICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSA/ICdvYmplY3QnIDogJ3N0cmluZyc7XG5cdFx0XHR9XG5cblx0XHRcdC8qKlxuXHRcdFx0ICogVHVybiBhIHBhdGggb2JqZWN0IGludG8gYSBzdHJpbmcuXG5cdFx0XHQgKi9cblx0XHRcdGZ1bmN0aW9uIHN0cmluZ2lmeShpbnB1dCkge1xuXHRcdFx0XHRpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdHJldHVybiBpbnB1dDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICghaW5wdXQpIHtcblx0XHRcdFx0XHRyZXR1cm4gJyc7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRvdXRwdXQgPSBpbnB1dC5tO1xuXG5cdFx0XHRcdHZhciB2YXJpYXRpb25zID0gW107XG5cdFx0XHRcdGZvciAodmFyIGtleSBpbiBpbnB1dCkge1xuXHRcdFx0XHRcdGlmIChpbnB1dC5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIGtleSAhPT0gJ20nKSB7XG5cdFx0XHRcdFx0XHQvLyBPbmx5IHNob3cgdmFyaWF0aW9ucyB0aGF0IGFyZSBub3QgdGhlIHByaW1hcnkgb25lLCBzaW5jZVxuXHRcdFx0XHRcdFx0Ly8gcHJpbWFyeSB2YXJpYXRpb25zIGFyZSBjaG9zZW4gYnkgZGVmYXVsdFxuXHRcdFx0XHRcdFx0aWYgKGlucHV0W2tleV0gPiAwKSB7XG5cdFx0XHRcdFx0XHRcdGlmICh2ZXJib3NlKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyaWF0aW9ucy5wdXNoKCcsIHZhcmlhdGlvbiAnICsgaW5wdXRba2V5XSArICcgYXQgbW92ZSAnICsga2V5KTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR2YXJpYXRpb25zLnB1c2goJy0nICsga2V5ICsgJzonICsgaW5wdXRba2V5XSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRvdXRwdXQgKz0gdmFyaWF0aW9ucy5qb2luKCcnKTtcblx0XHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHRcdH1cblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUdXJuIGEgcGF0aCBzdHJpbmcgaW50byBhbiBvYmplY3QuXG5cdFx0XHQgKi9cblx0XHRcdGZ1bmN0aW9uIHBhcnNlKGlucHV0KSB7XG5cdFx0XHRcdGlmICh0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdFx0aW5wdXQgPSBzdHJpbmdpZnkoaW5wdXQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCFpbnB1dCkge1xuXHRcdFx0XHRcdHJldHVybiB7IG06IDAgfTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBwYXRoID0gaW5wdXQuc3BsaXQoJy0nKTtcblx0XHRcdFx0b3V0cHV0ID0ge1xuXHRcdFx0XHRcdG06IE51bWJlcihwYXRoLnNoaWZ0KCkpXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0aWYgKHBhdGgubGVuZ3RoKSB7XG5cdFx0XHRcdFx0cGF0aC5mb3JFYWNoKGZ1bmN0aW9uICh2YXJpYXRpb24sIGkpIHtcblx0XHRcdFx0XHRcdHZhcmlhdGlvbiA9IHZhcmlhdGlvbi5zcGxpdCgnOicpO1xuXHRcdFx0XHRcdFx0b3V0cHV0W051bWJlcih2YXJpYXRpb25bMF0pXSA9IHBhcnNlSW50KHZhcmlhdGlvblsxXSwgMTApO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG91dHB1dFR5cGUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdG91dHB1dCA9IHN0cmluZ2lmeShpbnB1dCk7XG5cdFx0XHR9IGVsc2UgaWYgKG91dHB1dFR5cGUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdG91dHB1dCA9IHBhcnNlKGlucHV0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dCA9IHVuZGVmaW5lZDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIG5ldyBTbWFydGdhbWVyKCk7XG59O1xuIiwi77u/LyogZ2xvYmFscyBtb2R1bGU6IGZhbHNlLCByZXF1aXJlOiBmYWxzZVxyXG5cclxuKi9cclxuLyoqXHJcbiAqIFByb3ZpZGVzIGEgZnVuY3Rpb24gZm9yIHRyYW5zZm9ybWluZyBTR0YgZm9yIGEgR28gdmFyaWFudCB0byBTR0YgZm9yIGEgc3RhbmRhcmQgR28gdmlld2VyOyBhbHNvIHByb3ZpZGVzIGEgZnVuY3Rpb24gZm9yIHRoZSBpbnZlcnNlIHRyYW5zZm9ybWF0aW9uLlxyXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnM9XSBEZWZpbmVzIHZhcmlvdXMgb3B0aW9ucyBmb3IgdGhlIG91dHB1dCBTR0YuIE1heSBiZSBvbWl0dGVkLCBpbiB3aGljaCBjYXNlIHRoZSBkZWZhdWx0IG9wdGlvbnMgKHNlZSBiZWxvdykgYXJlIHVzZWQuXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYWRkQ29tbWVudHMgPSBmYWxzZV0gV2hlbiBmbGFnZ2VkLCBjb21tZW50cyBhcmUgYWRkZWQgdG8gZWFjaCBub2RlIGdpdmluZyB0aGUgbW92ZSBudW1iZXIgYW5kIHRoZSBudW1iZXIgb2Ygc3RvbmVzIGNhcHR1cmVkIGJ5IEJsYWNrIGFuZCBXaGl0ZS5cclxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5hZGRQYXNzZXMgPSB0cnVlXSBXaGVuIGZsYWdnZWQsIGEgcGFzcyBpcyBhZGRlZCB0byBlYWNoIG5vZGUgY29ycmVzcG9uZGluZyB0byBhIG1vdmUgYnkgYSBwbGF5ZXIuIFRoaXMgY2FuIG1ha2UgdGhlIG91dHB1dCBtb3JlIGVhc3kgdG8gbmF2aWdhdGUgaW4gc29tZSB2aWV3ZXJzLlxyXG4gKiBAcGFyYW0ge2FycmF5fSBbb3B0aW9ucy5ib2FyZERpbWVuc2lvbnMgPSBbMTEsIDExXV0gTWF5IGJlIHVzZWQgZm9yIHJlY3Rhbmd1bGFyIHQtR28uIFNob3VsZCBiZSBvbW1pdHRlZCBmb3IgW24sIG5dIHQtR28sIHdoZXJlIG4gaXMgc3BlY2lmaWVkIGluIHRoZSBpbnB1dCBTR0YgKEBwYXJhbSB2YXJpYW50U2dmKS5cclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmNvb3JkaW5hdGVzVHlwZSA9IDBdIDA6IG5vbmU7XHJcbiAqIDE6ICjihpLihpE7QXwxLUt8MTEpOiBXZXN0ZXJuO1xyXG4gKiAyOiAo4oaS4oaRO0F8MS1MfDExKTogV2VzdGVybiwgbm8g4oCcSeKAnTtcclxuICogMzogKOKGkuKGkzsxfDEtMTF8MTEpOiBMYXRpbi9MYXRpbiwgdG9wIHRvIGJvdHRvbTtcclxuICogNDogKOKGkuKGkzsxfDEtMTF85Y2B5LiAKTogTGF0aW4vQ2hpbmVzZSwgdG9wIHRvIGJvdHRvbTtcclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLndyYXBhcm91bmRNYXJrZXJzVHlwZSA9IDFdIDA6IG5vbmU7XHJcbiAqIDE6IEZ1bGwgb3V0bGluZSwgdXNpbmcgdW5pY29kZSBCb3ggRHJhd2luZyBzeW1ib2xzO1xyXG4gKiAyOiBjb3JuZXJzIGFuZCBtaWRkbGVzLCB1c2luZyB1bmljb2RlIEJveCBEcmF3aW5nIHN5bWJvbHM7XHJcbiAqIDM6IGp1c3QgY29ybmVycywgdXNpbmcgdW5pY29kZSBCb3ggRHJhd2luZyBzeW1ib2xzO1xyXG4gKiA0OiBqdXN0IG1pZGRsZXMsIHVzaW5nIHVuaWNvZGUgQm94IERyYXdpbmcgc3ltYm9scztcclxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLnByb2plY3Rpb25TZXR0aW5ncz1dIEZ1cnRoZXIgb3B0aW9uYWwgc2V0dGluZ3MgZm9yIGhvdyB0aGUgKHRvcm9pZGFsLCBvciBvdGhlciBzb3J0IG9mKSBib2FyZCBpcyBwcm9qZWN0ZWQgdG8gYSBmbGF0IGdyaWQuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5wcm9qZWN0aW9uU2V0dGluZ3Mud3JhcGFyb3VuZCA9IDRdICBOdW1iZXIgb2YgbGluZXMgdG8gYWRkIGZvciB0aGUg4oCcd3JhcGFyb3VuZOKAnS5cclxuICogQHBhcmFtIHthcnJheX0gW29wdGlvbnMucHJvamVjdGlvblNldHRpbmdzLm9mZnNldCA9IFswLDBdXSAgVHJhbnNsYXRpb24gdG8gYXBwbHkgdG8gYWxsIG1vdmVzLlxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYW5zZm9ybVRvU3RyaW5nPXRydWVdIFdoZW4gc2V0IHRvIGZhbHNlLCB0aGUgb3V0cHV0IGlzIGFuIG9iamVjdCAoYW4gaW5zdGFuY2Ugb2YgYSBTbWFydGdhbWUpLlxyXG4gKiBAcHVibGljXHJcbiAqIEByZXR1cm4ge29iamVjdH0gQW4gb2JqZWN0IGV4cG9zaW5nIGZ1bmN0aW9ucyBmb3IgZ29pbmcgYmFjayBhbmQgZm9ydGggYmV0d2VlbiBTR0YgZm9yIGEgc3RhbmRhcmQgdmlld2VyLCBhbmQgU0dGIGZvciBhIGdhbWUgb2YgdG9yb2lkYWwgR29cclxuICovLyp0b2Rvczpcclxub3B0aW9ucy5tYXJrTGFzdE1vdmUgRGVmYXVsdCB2YWx1ZTogJ0NSJ1xyXG5vcGlvbnMucGxhY2VzVG9Db3VudCBEZWZhdWx0OiB1bmRlZmluZWQuIE1heSBiZTogJ2xhc3QnfFtjb3VudEluZm8xLCAuLiBjb3VudEluZm8xXS4gY291bnRJbmZvIGlzIGEgcGF0aCBwbHVzIGFuIGFycmF5IHdpdGggYSBwb2ludCBmb3IgZWFjaCBjaGFpbiB0byBiZSBjb25zaWRlcmVkIGFzIGRlYWQuIHtwYXRoLCBkZWFkQ2hhaW5zOiBbLi4uXX1cclxub3B0aW9ucy5wcm9qZWN0aW9uU2V0dGluZ3Mucm90YXRpb24ge2ludGVnZXJ9IERlZmF1bHQgdmFsdWU6IDAuIEFsbG93ZWQgdmFsdWVzOiAwIC4uIDNcclxub3B0aW9ucy5wcm9qZWN0aW9uU2V0dGluZ3Mubm9ybWFsaXplUGxhY2UgYXJyYXksIG9yIG9uZSBvZjogQywgVEwgVFIgQkwgQlIgKGNlbnRyZSwgdG9wIGxlZnQsIHRvcCByaWdodCwgYm90dG9tIGxlZnQsIGJvdHRvbSByaWdodClcclxub3B0aW9ucy5wcm9qZWN0aW9uU2V0dGluZ3Mubm9ybWFsaXplIHtib29sZWFufSBcclxuXHJcbiovXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybWVyKG9wdGlvbnNcclxuKSB7XHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdGNvbnN0XHJcblx0XHRfZmxhdHRlbiA9IHJlcXVpcmUoJ2xvZGFzaC9mbGF0dGVuJylcclxuXHRcdCwgX3VuaXFCeSA9IHJlcXVpcmUoJ2xvZGFzaC91bmlxQnknKVxyXG5cdFx0LCBfZmkgPSByZXF1aXJlKCdsb2Rhc2gvZmluZEluZGV4JylcclxuXHRcdCwgbW9kdWxvID0gKHgsIHkpID0+ICh4ICUgeSArIHkpICUgeVxyXG5cdFx0LCBzb3VyY2VTZ2ZNZXNzYWdlID0gJ3NvdXJjZSBzZ2YgZm9yIHRvcm9pZGFsIEdvIGhhcyBiZWVuIGFkYXB0ZWQgYnkgZ28tdmFyaWFudHMtdHJhbnNmb3JtZXIgc28gYXMgdG8gYmUgcmVuZGVyZWQgYnkgYW55IHN0YW5kYXJkIEdvIGFwcGxpY2F0aW9uJ1xyXG5cdG9wdGlvbnMgPSB7XHJcblx0XHRhZGRQYXNzZXM6IHRydWVcclxuXHRcdCwgYm9hcmREaW1lbnNpb25zOiBbMTEsIDExXVxyXG5cdFx0LCB0cmFuc2Zvcm1Ub1N0cmluZzogdHJ1ZVxyXG5cdFx0LCBhZGRDb21tZW50czogdHJ1ZVxyXG5cdFx0LCBjb29yZGluYXRlc1R5cGU6IDBcclxuXHRcdCwgd3JhcGFyb3VuZE1hcmtlcnNUeXBlOiAxXHJcblx0XHQvL2Fib3ZlIGFyZSB0aGUgZGVmYXVsdHNcclxuXHRcdCwgLi4ub3B0aW9uc1xyXG5cdH1cclxuXHRvcHRpb25zLnByb2plY3Rpb25TZXR0aW5ncyA9XHJcblx0XHR7XHJcblx0XHRcdHdyYXBhcm91bmQ6IDQsXHJcblx0XHRcdG9mZnNldDogWzAsIDBdLFxyXG5cdFx0XHQuLi5vcHRpb25zLnByb2plY3Rpb25TZXR0aW5nc1xyXG5cdFx0fVxyXG5cclxuXHRpZiAob3B0aW9ucy5hZGRQYXNzZXMgPT09IHVuZGVmaW5lZClcclxuXHRcdG9wdGlvbnMuYWRkUGFzc2VzID0gdHJ1ZTtcclxuXHJcblx0b3B0aW9ucy5ib2FyZERpbWVuc2lvbnMgPSBvcHRpb25zLmJvYXJkRGltZW5zaW9ucyB8fCBbMTEsIDExXVxyXG5cclxuXHRpZiAob3B0aW9ucy50cmFuc2Zvcm1Ub1N0cmluZyA9PT0gdW5kZWZpbmVkKVxyXG5cdFx0b3B0aW9ucy50cmFuc2Zvcm1Ub1N0cmluZyA9IHRydWU7XHJcblxyXG5cdGlmIChvcHRpb25zLmFkZENvbW1lbnRzID09PSB1bmRlZmluZWQpXHJcblx0XHRvcHRpb25zLmFkZENvbW1lbnRzID0gdHJ1ZTtcclxuXHQvLyBvcHRpb25zLnByb2plY3Rpb25TZXR0aW5ncyA9IFxyXG5cclxuXHRsZXQgd3JhcGFyb3VuZCA9IG9wdGlvbnMucHJvamVjdGlvblNldHRpbmdzLndyYXBhcm91bmRcclxuXHJcblx0bGV0ICQgPSB7fVxyXG5cdFx0Ly8gLCBfbWFya2Vyc0ZvcldyYXBhcm91bmQgPSBudWxsXHJcblx0XHQsIGNvb3JkaW5hdGVMYWJlbHMgPSBmdW5jdGlvbiAoaSkge1xyXG5cdFx0XHQvLyA5Ny4uMTIyIGFuZCA2NS4uOTBcclxuXHRcdFx0cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA8IDI2ID8gaSArIDk3IDogaSArIDM5KVxyXG5cdFx0XHQvLzY1IC0gMjYgPVxyXG5cdFx0fVxyXG5cdFx0LFxyXG5cdFx0dHJhbnNsYXRlQ29vcmRpbmF0ZSA9IChjKSA9PiB7XHJcblx0XHRcdGxldCByID0gYy5jaGFyQ29kZUF0KDApXHJcblx0XHRcdHJldHVybiByID49IDk3ID8gciAtIDk3IDogciAtIDI2XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiBUcmFuc2xhdGUgYWxwaGEgY29vcmRpbmF0ZXMgaW50byBhbiBhcnJheVxyXG5cdFx0ICogQHBhcmFtIHN0cmluZyBhbHBoYUNvb3JkaW5hdGVzXHJcblx0XHQgKiBAcmV0dXJuIGFycmF5IFt4LCB5XVxyXG5cdFx0ICoqL1xyXG5cdFx0dHJhbnNsYXRlQ29vcmRpbmF0ZXMgPSAoYWxwaGFDb29yZGluYXRlcykgPT4ge1xyXG5cdFx0XHRyZXR1cm4gW3RyYW5zbGF0ZUNvb3JkaW5hdGUoYWxwaGFDb29yZGluYXRlcy5zdWJzdHJpbmcoMCwgMSkpXHJcblx0XHRcdFx0LCB0cmFuc2xhdGVDb29yZGluYXRlKGFscGhhQ29vcmRpbmF0ZXMuc3Vic3RyaW5nKDEsIDIpKV1cclxuXHJcblx0XHR9XHJcblxyXG5cclxuXHQkLmNvb3JkaW5hdGVMYWJlbHMgPSBjb29yZGluYXRlTGFiZWxzXHJcblx0JC50cmFuc2xhdGVDb29yZGluYXRlcyA9IHRyYW5zbGF0ZUNvb3JkaW5hdGVzXHJcblx0LyoqXHJcblx0ICogQHB1YmxpY1xyXG5cdCAqL1xyXG5cdCQub3B0aW9ucyA9IG9wdGlvbnNcclxuXHJcblx0JC5wcm9qZWN0T25MaW5lID0gZnVuY3Rpb24gKGEsIGlzVmVydGljYWwpIHtcclxuXHRcdC8qXHJcblx0XHRtOiBib2FyZERpbWVuc2lvbnNbMF0gOiAxMVxyXG5cdFx0bjogd3JhcGFyb3VuZCA6IDRcclxuXHRcdGxpbmU6IDAsLi4uLChtLTEpXHJcblx0XHQ9PlxyXG5cdFx0MCwuLi4sKG4tMSksIChzdGFydCBsaW5lKSBuLCAuLi4gLCAobiArIG0gLSAxKSBlbmQgbGluZSwgIChuK20pLCAuLi4gLCAoMm4gKyBtIC0gMSlcclxuXHJcblx0XHRjb29yZGluYXRlIGEg4oiIIHswIC4uIG0tMX0gcHJvamVjdHMgdG8gbiArIGEgaW4gbWFpbiBhcmVhXHJcblx0XHRhbGwgcHJvamVjdGlvbnMgYXJlIG9mIHRoZSBmb3JtIG4gKyBhICsgeG0sIHgg4oiIIOKEpCBzLnQuIDAg4omkIG4gKyBhICsgeG0g4omkIDJuICsgbSAtMVxyXG5cdFx0LXhtIOKJpCBuICsgYVxyXG5cdFx0XHRzbWFsbGVzdCBzdWNoIHggPCAwIGlzIGNlaWwoLShuK2EpL20pXHJcblx0XHQgeG0g4omkIG4gKyBtIC0gMSAtYVxyXG5cdFx0XHRsYXJnZXN0IHN1Y2ggeCBpcyBmbG9vcigobiArIG0gLSAxIC1hKSAvIG0pXHJcblxyXG5cclxuXHRcdCovXHJcblxyXG5cdFx0Y29uc3QgbSAvLz0gb3B0aW9ucy5ib2FyZERpbWVuc2lvbnNbMF1cclxuXHRcdFx0PSBvcHRpb25zLmJvYXJkRGltZW5zaW9uc1tpc1ZlcnRpY2FsID8gMSA6IDBdXHJcblxyXG5cdFx0XHQsIHIgPSBbXVxyXG5cclxuXHRcdGZvciAobGV0IGkgPSBNYXRoLmNlaWwoLSh3cmFwYXJvdW5kICsgYSkgLyBtKTsgaSA8PSAod3JhcGFyb3VuZCArIG0gLSAxIC0gYSkgLyBtOyBpKyspXHJcblx0XHRcdHIucHVzaCh3cmFwYXJvdW5kICsgYSArIGkgKiBtKVxyXG5cdFx0cmV0dXJuIHJcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoaXMgaXMgdGhlIGludmVyc2UgZnVuY3Rpb24gdG8gdGhlIGZ1bmN0aW9uIOKAnHByb2plY3RPbkZsYXTigJ0g4oCTIGF0IGxlYXN0IGl0IGlzIHdoZW4g4oCcbXVsdGlwbGXigJ0gaXMgZmFsc2UuXHJcblx0ICogQHBhcmFtIHtBcnJheX0gcG9pbnRzIFRoZSBwb2ludCBvciBhcnJheSBvZiBwb2ludHMgcHJvamVjdGVkIG9udG8gdGhlIGdyaWQuXHJcblx0ICogQHBhcmFtIHtCb29sZWFuPWZhbHNlfSBtdWx0aXBsZSBXaGV0aGVyIHRoZSBhcmd1bWVudCDigJxwb2ludHPigJ0gaXMgdGhlIGltYWdlIG9mIGEgc2luZ2xlIHBvaW50ICjigJxtdWx0aXBsZT1mYWxzZeKAnSkgb3Igb2YgbXVsdGlwbGUgcG9pbnRzLlxyXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gV2hlbiB0aGUgZmxhZyDigJxtdWx0aXBsZeKAnSBpcyBmbGFnZ2VkLCByZXR1cm5zIGFuIGFycmF5IG9mIHBvaW50czsgb3RoZXJ3aXNlIHJldHVybnMgYSBzaW5nbGUgcG9pbnQgKGkuZS4gYW4gYXJyYXkgb2YgdHdvIGludGVnZXJzKS5cclxuXHQgKi9cclxuXHRmdW5jdGlvbiBpbnZlcnNlUHJvamVjdE9uRmxhdChwb2ludHMsIG11bHRpcGxlKSB7XHJcblx0XHRpZiAoIUFycmF5LmlzQXJyYXkocG9pbnRzWzBdKSkgcG9pbnRzID0gW3BvaW50c11cclxuXHRcdGlmICghbXVsdGlwbGUpXHJcblx0XHRcdHJldHVybiBbbW9kdWxvKHBvaW50c1swXVswXSAtIG9wdGlvbnMucHJvamVjdGlvblNldHRpbmdzLm9mZnNldFswXSAtIHdyYXBhcm91bmQsIG9wdGlvbnMuYm9hcmREaW1lbnNpb25zWzBdKVxyXG5cdFx0XHRcdCwgbW9kdWxvKHBvaW50c1swXVsxXSAtIG9wdGlvbnMucHJvamVjdGlvblNldHRpbmdzLm9mZnNldFsxXSAtIHdyYXBhcm91bmQsIG9wdGlvbnMuYm9hcmREaW1lbnNpb25zWzFdKV1cclxuXHRcdHJldHVybiBfdW5pcUJ5KHBvaW50cy5tYXAoeCA9PiBpbnZlcnNlUHJvamVjdE9uRmxhdChbeF0pKSwgKHgpID0+IGAke3hbMF19XyR7eFsxXX1gKVxyXG5cdH1cclxuXHQkLmludmVyc2VQcm9qZWN0T25GbGF0ID0gaW52ZXJzZVByb2plY3RPbkZsYXRcclxuXHJcblx0LyoqXHJcblx0ICogUHJvamVjdHMgYSBwb2ludCBvbiB0aGUgdC1HbyBib2FyZCB0byB0aGUgYXJyYXkgb2YgcG9pbnRzIG9uIHRoZSBzdGFuZGFyZCBncmlkL2JvYXJkLlxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHAgVGhlIHBvaW50IGluIHRoZSB0LUdvIGJvYXJkIHRvIGJlIHByb2plY3RlZCBvbiB0byB0aGUgZ3JpZC5cclxuXHQgKiBAcmV0dXJucyB7QXJyYXl9XHJcblx0ICovXHJcblx0ZnVuY3Rpb24gcHJvamVjdE9uRmxhdChwKSB7XHJcblx0XHRjb25zdCBhID0gJC5wcm9qZWN0T25MaW5lKHBbMF0gKyBvcHRpb25zLnByb2plY3Rpb25TZXR0aW5ncy5vZmZzZXRbMF0pXHJcblx0XHRcdCwgYiA9ICQucHJvamVjdE9uTGluZShwWzFdICsgb3B0aW9ucy5wcm9qZWN0aW9uU2V0dGluZ3Mub2Zmc2V0WzFdKVxyXG5cdFx0XHQsIHIgPSBbXVxyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKVxyXG5cdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IGIubGVuZ3RoOyBqKyspXHJcblx0XHRcdFx0ci5wdXNoKFthW2ldLCBiW2pdXSlcclxuXHRcdHJldHVybiByXHJcblx0fVxyXG5cdCQucHJvamVjdE9uRmxhdCA9IHByb2plY3RPbkZsYXRcclxuXHJcblx0JC5tb2RYID0gKHgpID0+IG1vZHVsbyh4LCBvcHRpb25zLmJvYXJkRGltZW5zaW9uc1swXSlcclxuXHQkLm1vZFkgPSAoeSkgPT4gbW9kdWxvKHksIG9wdGlvbnMuYm9hcmREaW1lbnNpb25zWzFdKVxyXG5cclxuXHRsZXQgc2V0VXBNYXJrZXJzID0gKCkgPT4ge1xyXG5cdFx0JC53cmFwYXJvdW5kQW5kQ29vcmRzID0gW11cclxuXHJcblx0XHQvLyAkLmdldE1hcmtlcnNGb3JXcmFwYXJvdW5kID0gZnVuY3Rpb24gKCl7XHJcblx0XHRpZiAob3B0aW9ucy5wcm9qZWN0aW9uU2V0dGluZ3Mud3JhcGFyb3VuZCA+IDApIHtcclxuXHRcdFx0Y29uc3QgbSA9IG9wdGlvbnMuYm9hcmREaW1lbnNpb25zWzBdLFxyXG5cdFx0XHRcdG4gPSBvcHRpb25zLmJvYXJkRGltZW5zaW9uc1sxXVxyXG5cclxuXHRcdFx0LypcclxuXHRcdFx0bTogYm9hcmREaW1lbnNpb25zWzBdIDogMTFcclxuXHRcdFx0dzogd3JhcGFyb3VuZCA6IDRcclxuXHRcdFx0bGluZTogMCwuLi4sKG0tMSlcclxuXHRcdFx0PT5cclxuXHRcdFx0MCwuLi4sKHctMSksIChzdGFydCBsaW5lKSB3LCAuLi4gLCAodyArIG0gLSAxKSBlbmQgbGluZSwgKHcrbSksIC4uLiAsICgydyArIG0gLSAxKVxyXG5cdFx0XHQqL1xyXG5cclxuXHRcdFx0bGV0IGJvYXJkID0gW11cclxuXHRcdFx0aWYgKFsxLCAyLCA0XS5pbmRleE9mKG9wdGlvbnMud3JhcGFyb3VuZE1hcmtlcnNUeXBlKSA+IC0xKSB7XHJcblx0XHRcdFx0bGV0IG1pZGRsZXMgPSBvcHRpb25zLndyYXBhcm91bmRNYXJrZXJzVHlwZSA+IDEgP1xyXG5cdFx0XHRcdFx0W01hdGguZmxvb3IoKG0gLSAxKSAvIDIpICsgMSwgTWF0aC5jZWlsKChtIC0gMSkgLyAyKSArIDEsXHJcblx0XHRcdFx0XHRNYXRoLmZsb29yKChuIC0gMSkgLyAyKSArIDEsIE1hdGguY2VpbCgobiAtIDEpIC8gMikgKyAxXVxyXG5cdFx0XHRcdFx0OiBbLTEsIDk5LCAtMSwgOTldXHJcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDE7IGkgPD0gbTsgaSsrKSB7XHJcblx0XHRcdFx0XHRpZiAoaSA8IG1pZGRsZXNbMF0gfHwgaSA+IG1pZGRsZXNbMV0pIHtcclxuXHRcdFx0XHRcdFx0Y29udGludWVcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGxldCBsYWJlbCA9ICfilIAnLy9VKzI1MDAgQm94IERyYXdpbmdzIExpZ2h0IEhvcml6b250YWxcclxuXHJcblx0XHRcdFx0XHRib2FyZC5wdXNoKGNvb3JkaW5hdGVMYWJlbHMod3JhcGFyb3VuZCAtIDEgKyBpKSArIGNvb3JkaW5hdGVMYWJlbHMod3JhcGFyb3VuZCAtIDEpICsgXCI6XCIgKyBsYWJlbClcclxuXHRcdFx0XHRcdGJvYXJkLnB1c2goY29vcmRpbmF0ZUxhYmVscyh3cmFwYXJvdW5kIC0gMSArIGkpICsgY29vcmRpbmF0ZUxhYmVscyh3cmFwYXJvdW5kICsgbSkgKyBcIjpcIiArIGxhYmVsKVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRmb3IgKGxldCBpID0gMTsgaSA8PSBuOyBpKyspIHtcclxuXHRcdFx0XHRcdGlmIChpIDwgbWlkZGxlc1syXSB8fCBpID4gbWlkZGxlc1szXSkge1xyXG5cdFx0XHRcdFx0XHRjb250aW51ZVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0bGV0IGxhYmVsID0gJ+KUgicvL3VuaWNvZGUgdG9vXHJcblx0XHRcdFx0XHRib2FyZC5wdXNoKGNvb3JkaW5hdGVMYWJlbHMod3JhcGFyb3VuZCAtIDEpICsgY29vcmRpbmF0ZUxhYmVscyh3cmFwYXJvdW5kIC0gMSArIGkpICsgXCI6XCIgKyBsYWJlbClcclxuXHRcdFx0XHRcdGJvYXJkLnB1c2goY29vcmRpbmF0ZUxhYmVscyh3cmFwYXJvdW5kICsgbikgKyBjb29yZGluYXRlTGFiZWxzKHdyYXBhcm91bmQgLSAxICsgaSkgKyBcIjpcIiArIGxhYmVsKVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoWzEsIDIsIDNdLmluZGV4T2Yob3B0aW9ucy53cmFwYXJvdW5kTWFya2Vyc1R5cGUpID4gLTEpIHtcclxuXHRcdFx0XHQvL+KUmCAg4pSMICDilJQg4pSQXHJcblx0XHRcdFx0Ym9hcmQucHVzaChjb29yZGluYXRlTGFiZWxzKHdyYXBhcm91bmQgLSAxKSArIGNvb3JkaW5hdGVMYWJlbHMod3JhcGFyb3VuZCArIG4pICsgXCI64pSUXCIpXHJcblx0XHRcdFx0Ym9hcmQucHVzaChjb29yZGluYXRlTGFiZWxzKHdyYXBhcm91bmQgKyBtKSArIGNvb3JkaW5hdGVMYWJlbHMod3JhcGFyb3VuZCArIG4pICsgXCI64pSYXCIpXHJcblx0XHRcdFx0Ym9hcmQucHVzaChjb29yZGluYXRlTGFiZWxzKHdyYXBhcm91bmQgLSAxKSArIGNvb3JkaW5hdGVMYWJlbHMod3JhcGFyb3VuZCAtIDEpICsgXCI64pSMXCIpXHJcblx0XHRcdFx0Ym9hcmQucHVzaChjb29yZGluYXRlTGFiZWxzKHdyYXBhcm91bmQgKyBtKSArIGNvb3JkaW5hdGVMYWJlbHMod3JhcGFyb3VuZCAtIDEpICsgXCI64pSQXCIpXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChvcHRpb25zLmNvb3JkaW5hdGVzVHlwZSA+IDAgJiYgd3JhcGFyb3VuZCA+IDEpIHtcclxuXHRcdFx0XHRmb3IgKGxldCBpID0gMTsgaSA8IDIgKiB3cmFwYXJvdW5kICsgbSAtIDE7IGkrKykge1xyXG5cclxuXHRcdFx0XHRcdGxldCBjb29yZEluZGV4ID0gJC5tb2RYKC1vcHRpb25zLnByb2plY3Rpb25TZXR0aW5ncy5vZmZzZXRbMF0gLSB3cmFwYXJvdW5kICsgaSlcclxuXHJcblx0XHRcdFx0XHRpZiAob3B0aW9ucy5jb29yZGluYXRlc1R5cGUgPT09IDIgJiYgY29vcmRJbmRleCA+PSA4KSB7XHJcblx0XHRcdFx0XHRcdC8vb21pdCB0aGUgSSAtIGhpc3RvcmljYWwgY29vcmRpbmF0ZXMgZm9yIEdvLi4uXHJcblx0XHRcdFx0XHRcdC8vSTogOXRoIGxldHRlclxyXG5cdFx0XHRcdFx0XHRjb29yZEluZGV4KytcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGxldCBsYWJlbCA9XHJcblx0XHRcdFx0XHRcdG9wdGlvbnMuY29vcmRpbmF0ZXNUeXBlIDwgM1xyXG5cdFx0XHRcdFx0XHRcdD8gY29vcmRpbmF0ZUxhYmVscyhjb29yZEluZGV4KS50b1VwcGVyQ2FzZSgpXHJcblx0XHRcdFx0XHRcdFx0OiAnJyArIChjb29yZEluZGV4ICsgMSlcclxuXHRcdFx0XHRcdGJvYXJkLnB1c2goY29vcmRpbmF0ZUxhYmVscyhpKSArIGNvb3JkaW5hdGVMYWJlbHMoMCkgKyBcIjpcIiArIGxhYmVsKVxyXG5cdFx0XHRcdFx0Ym9hcmQucHVzaChjb29yZGluYXRlTGFiZWxzKGkpICsgY29vcmRpbmF0ZUxhYmVscygyICogd3JhcGFyb3VuZCArIG4gLSAxKSArIFwiOlwiICsgbGFiZWwpXHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGxldCBjamtOdW1iZXJzID0gJ+S4gOS6jOS4ieWbm+S6lOWFreS4g+WFq+S5nSdcclxuXHRcdFx0XHRmb3IgKGxldCBpID0gMTsgaSA8IDIgKiB3cmFwYXJvdW5kICsgbiAtIDE7IGkrKykge1xyXG5cdFx0XHRcdFx0LypcclxuXHRcdFx0XHRcdDBcdFx0LXdcclxuXHRcdFx0XHRcdC4uLlxyXG5cdFx0XHRcdFx0dy0xXHQtMVxyXG5cdFx0XHRcdFx0d1x0XHQwXHJcblx0XHRcdFx0XHQuLi5cclxuXHRcdFx0XHRcdHcgKyBuIC0xXHJcblx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdCovXHJcblx0XHRcdFx0XHRsZXQgY29vcmRJbmRleCA9XHJcblx0XHRcdFx0XHRcdG9wdGlvbnMuY29vcmRpbmF0ZXNUeXBlIDwgM1xyXG5cdFx0XHRcdFx0XHRcdD8gJC5tb2RZKG4gKyBvcHRpb25zLnByb2plY3Rpb25TZXR0aW5ncy5vZmZzZXRbMV0gKyB3cmFwYXJvdW5kIC0gaSAtIDEpXHJcblx0XHRcdFx0XHRcdFx0OiAkLm1vZFkoaSAtIHdyYXBhcm91bmQgLSBvcHRpb25zLnByb2plY3Rpb25TZXR0aW5ncy5vZmZzZXRbMV0pXHJcblx0XHRcdFx0XHRsZXQgbGFiZWwgPSAnJ1xyXG5cdFx0XHRcdFx0c3dpdGNoIChvcHRpb25zLmNvb3JkaW5hdGVzVHlwZSkge1xyXG5cdFx0XHRcdFx0XHRjYXNlIDE6XHJcblx0XHRcdFx0XHRcdGNhc2UgMjpcclxuXHRcdFx0XHRcdFx0Y2FzZSAzOlxyXG5cdFx0XHRcdFx0XHRcdGxhYmVsID0gJycgKyAoY29vcmRJbmRleCArIDEpXHJcblx0XHRcdFx0XHRcdFx0YnJlYWtcclxuXHRcdFx0XHRcdFx0Y2FzZSA0OlxyXG5cdFx0XHRcdFx0XHRcdGxhYmVsID0gbW9kdWxvKGNvb3JkSW5kZXgsIDEwKSA9PT0gOSA/ICcnIDogY2prTnVtYmVyc1ttb2R1bG8oY29vcmRJbmRleCwgMTApXVxyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoY29vcmRJbmRleCA+IDgpIHtcclxuXHRcdFx0XHRcdFx0XHRcdGxhYmVsID0gKGNvb3JkSW5kZXggPiAxOCA/IGNqa051bWJlcnNbTWF0aC5mbG9vcigoY29vcmRJbmRleCArIDEpIC8gMTApIC0gMV0gOiAnJykgKyAn5Y2BJyArIGxhYmVsXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdGJyZWFrXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRib2FyZC5wdXNoKGNvb3JkaW5hdGVMYWJlbHMoMCkgKyBjb29yZGluYXRlTGFiZWxzKGkpICsgXCI6XCIgKyBsYWJlbClcclxuXHRcdFx0XHRcdGJvYXJkLnB1c2goY29vcmRpbmF0ZUxhYmVscygyICogd3JhcGFyb3VuZCArIG0gLSAxKSArIGNvb3JkaW5hdGVMYWJlbHMoaSkgKyBcIjpcIiArIGxhYmVsKVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0JC53cmFwYXJvdW5kQW5kQ29vcmRzID0gYm9hcmRcclxuXHRcdH1cclxuXHR9XHJcblx0c2V0VXBNYXJrZXJzKClcclxuXHJcblxyXG5cdCQuY29vcmRzMlN0cmluZyA9XHJcblx0XHQvKipcclxuXHRcdCAqIGNvbnZlcnRzIGNvb3JkaW5hdGVzIHRvIGEgc3RyaW5nXHJcblx0XHQgKi9cclxuXHRcdGZ1bmN0aW9uIGNvb3JkczJTdHJpbmcoY29vcmRzKSB7XHJcblx0XHRcdHJldHVybiBjb29yZGluYXRlTGFiZWxzKGNvb3Jkc1swXSkgKyBjb29yZGluYXRlTGFiZWxzKGNvb3Jkc1sxXSlcclxuXHRcdH1cclxuXHJcblx0ZnVuY3Rpb24gZ29UaHJvdWdoVHJlZShzdGF0ZSkge1xyXG5cdFx0bGV0IHsgd3JhcHBlZEdhbWUsIG5vZGUsIHBlbmRpbmcsIGN1cnJlbnRQYXRoLCB0R28gfSA9IHN0YXRlXHJcblx0XHRcdCwgbmJWYXJpYXRpb25zID0gd3JhcHBlZEdhbWUudmFyaWF0aW9ucygpLmxlbmd0aFxyXG5cdFx0aWYgKGN1cnJlbnRQYXRoLm0gPiAxMDAwKSB0aHJvdyBuZXcgRXJyb3IoJ3NlZW0gdG8gYmUgc3R1Y2shJyk7XHJcblx0XHRzdGF0ZS5oYXNTaWJsaW5ncyA9IG5iVmFyaWF0aW9ucyA+IDBcclxuXHRcdGlmIChzdGF0ZS5oYXNTaWJsaW5ncykge1xyXG5cdFx0XHQvLyBpZihjdXJyZW50UGF0aFttXSA9PT0gdW5kZWZpbmVkKVxyXG5cdFx0XHQvLyBjdXJyZW50UGF0aFttXSA9IDBcclxuXHRcdFx0Ly8gZWxzZVxyXG5cdFx0XHQvLyBjdXJyZW50UGF0aFttXSArPSAxXHJcblx0XHRcdC8vIGN1cnJlbnRQYXRoLm0gKz0gMVxyXG5cdFx0XHRmb3IgKGxldCBpID0gbmJWYXJpYXRpb25zIC0gMTsgaSA+IDA7IGktLSlcclxuXHRcdFx0Ly9waWxlIHVwIGluIHRoaXMgb3JkZXIsIGFzIGl0J3MgRklMTyBhbmQgd2Ugd2FudCB0aGUgbGFzdCB2YXJpYXRpb24sIHdoaWNoIG1heSBjb250YWluIGEgbW9kZSBhZGRlZCBieSBDR29ib2FyZCB0byBnbyBsYXN0XHJcblx0XHRcdHtcclxuXHRcdFx0XHRsZXQgcGF0aEZvckxhdGVyID0geyAuLi5jdXJyZW50UGF0aCB9Ly9PYmplY3QuYXNzaWduKHt9LCBjdXJyZW50UGF0aClcclxuXHRcdFx0XHRwYXRoRm9yTGF0ZXJbY3VycmVudFBhdGgubSArIDFdID0gaVxyXG5cdFx0XHRcdHBhdGhGb3JMYXRlci5tICs9IDFcclxuXHJcblx0XHRcdFx0aWYgKHRHbyAhPT0gdW5kZWZpbmVkKVxyXG5cdFx0XHRcdFx0cGVuZGluZy5wdXNoKHsgcGF0aDogcGF0aEZvckxhdGVyLCB0R29EYXRhOiB0R28uZXhwb3J0RGF0YSgpIH0pXHJcblx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0cGVuZGluZy5wdXNoKHsgcGF0aDogcGF0aEZvckxhdGVyIH0pXHJcblxyXG5cdFx0XHR9XHJcblx0XHRcdHN0YXRlLm5vZGUgPSB3cmFwcGVkR2FtZS5uZXh0KCkubm9kZSgpXHJcblx0XHRcdGN1cnJlbnRQYXRoW2N1cnJlbnRQYXRoLm0gKyAxXSA9IDBcclxuXHRcdFx0Y3VycmVudFBhdGgubSArPSAxXHJcblx0XHRcdHJldHVybiBzdGF0ZS5ub2RlXHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IG5leHROb2RlID0gd3JhcHBlZEdhbWUubmV4dCgpLm5vZGUoKVxyXG5cdFx0aWYgKG5vZGUgPT09IG5leHROb2RlKSB7Ly9hdCBhIGxlYWY6XHJcblx0XHRcdGlmIChwZW5kaW5nLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0XHRcdHN0YXRlLm5vZGUgPSBudWxsXHJcblx0XHRcdFx0cmV0dXJuIHN0YXRlLm5vZGUvL2ZpbmlzaGVkXHJcblx0XHRcdH1cclxuXHRcdFx0bGV0IGZyb21TdGFjayA9IHBlbmRpbmcucG9wKClcclxuXHRcdFx0c3RhdGUuaGFzU2libGluZ3MgPSB0cnVlXHJcblx0XHRcdC8vIGlmIChmcm9tU3RhY2sgPT09IG51bGwpIHtcclxuXHRcdFx0Ly8gXHRub2RlID0gbnVsbFxyXG5cdFx0XHQvLyBcdHJldHVybi8vZmluaXNoZWQhXHJcblx0XHRcdC8vIH1cclxuXHRcdFx0aWYgKHRHbyAhPT0gdW5kZWZpbmVkKSB0R28ubG9hZERhdGEoZnJvbVN0YWNrLnRHb0RhdGEpXHJcblx0XHRcdHN0YXRlLm5vZGUgPSB3cmFwcGVkR2FtZS5nb1RvKGZyb21TdGFjay5wYXRoKS5ub2RlKClcclxuXHRcdFx0c3RhdGUuY3VycmVudFBhdGggPSBmcm9tU3RhY2sucGF0aFxyXG5cdFx0XHRyZXR1cm4gc3RhdGUubm9kZVxyXG5cdFx0fVxyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdGN1cnJlbnRQYXRoLm0gKz0gMVxyXG5cdFx0XHRzdGF0ZS5ub2RlID0gbmV4dE5vZGVcclxuXHRcdFx0cmV0dXJuIHN0YXRlLm5vZGVcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEFwYXJ0IGZyb20gYSBmZXcgZGV0YWlscywgdGhpcyBpcyBhbiBpbnZlcnNlIG9mIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24uXHJcblx0ICogQHBhcmFtIHtzbWFydGdhbWV8c3RyaW5nfSB3cmFwcGVkR2FtZVxyXG5cdCAqIEBwYXJhbSB7c21hcnRnYW1lfSBzbWFydGdhbWVcclxuXHQgKiBAcHVibGljXHJcblx0ICovXHJcblx0ZnVuY3Rpb24gaW52ZXJzZVRyYW5zZm9ybShcclxuXHRcdHdyYXBwZWRHYW1lLCBzbWFydGdhbWUpIHtcclxuXHJcblx0XHRpZiAoc21hcnRnYW1lID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0c21hcnRnYW1lID0gcmVxdWlyZSgnc21hcnRnYW1lJylcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodHlwZW9mIHdyYXBwZWRHYW1lID09PSAnc3RyaW5nJykge1xyXG5cdFx0XHR2YXIgc21hcnRnYW1lciA9IHJlcXVpcmUoJ3NtYXJ0Z2FtZXInKVxyXG5cdFx0XHR3cmFwcGVkR2FtZSA9IHNtYXJ0Z2FtZXIoc21hcnRnYW1lLnBhcnNlKHdyYXBwZWRHYW1lKSlcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgbm9kZSA9IHdyYXBwZWRHYW1lLmZpcnN0KCkubm9kZSgpXHJcblx0XHRcdCwgcGVuZGluZyA9IFtdXHJcblx0XHRcdCwgY3VycmVudFBhdGggPSB7IG06IDAgfVxyXG5cdFx0XHQsIGNsZWFuZXJSZWdFeCA9IC9eW2EtekEtWiA6MC05XFwtKFxcclxcbl0rR29WYXJpYW50c1RyYW5zZm9ybWVyXFwpLS1bXFxyXFxuXSovXHJcblx0XHRcdCwgY2xlYW5Db21tZW50cyA9ICgpID0+IHtcclxuXHRcdFx0XHRpZiAobm9kZS5DICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRcdG5vZGUuQyA9IG5vZGUuQy5yZXBsYWNlKGNsZWFuZXJSZWdFeCwgJycpXHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmIChub2RlLkMgPT09ICcnKVxyXG5cdFx0XHRcdFx0ZGVsZXRlIG5vZGUuQ1xyXG5cdFx0XHR9XHJcblx0XHRcdCxcclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIEZ1bmN0aW9uIHRvOlxyXG5cdFx0XHQgKiBcdC0gcmVtb3ZlIHRoZSDigJxib3JkZXLigJ0gKHVuaWNvZGUgc3ltYm9scyBhZGRlZCBieSB0aGUgdHJhbnNmb3JtIHRvIGluZGljYXRlIHdoZXJlIHRoZSB3cmFwYXJvdW5kIGFyZWEgbWVldHMgdGhlIG1haW4gZ3JpZCkuXHJcblx0XHRcdCAqIFx0LSByZW1vdmUgQ00gKGNvbG91ciBtYXApIGFuZCBDVCAoY29sb3VyIHRhYmxlKSB3aGljaCBhcmUgbm9uc3RhbmRhcmQgU0dGIGFkZGVkIGJ5IENHb2JvYXJkIGZvciBiYWNrZ3JvdW5kIGNvbG91ciAoY291bGQgYmUgaW50ZXJlc3RpbmcgdG8gdXNlIHRoaXMgZmVhdHVyZSBsYXRlciBvbikuXHJcblx0XHRcdCAqL1xyXG5cdFx0XHRjbGVhbkxhYmVscyA9ICgpID0+IHtcclxuXHJcblx0XHRcdFx0bGV0IGxhYmVscyA9IFtdXHJcblx0XHRcdFx0aWYgKG5vZGUuTEIgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdFx0bGFiZWxzID0gbm9kZS5MQlxyXG5cdFx0XHRcdFx0aWYgKCFBcnJheS5pc0FycmF5KGxhYmVscykpXHJcblx0XHRcdFx0XHRcdGxhYmVscyA9IFtsYWJlbHNdXHJcblx0XHRcdFx0XHRsYWJlbHMgPSBsYWJlbHMuZmlsdGVyKGkgPT4gISQud3JhcGFyb3VuZEFuZENvb3Jkcy5pbmNsdWRlcyhpKSlcclxuXHRcdFx0XHRcdC8qIGpzaGludCBsb29wZnVuYzogdHJ1ZSAqL1xyXG5cdFx0XHRcdFx0bGFiZWxzID1cclxuXHRcdFx0XHRcdFx0X3VuaXFCeShcclxuXHRcdFx0XHRcdFx0XHRsYWJlbHNcclxuXHRcdFx0XHRcdFx0XHRcdC5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguc3BsaXQoJzonLCAyKSB9KS8vYXNzdW1lIHRoZSBsYWJlbCBkb2VzbuKAmXQgY29udGFpbiDigJw64oCdXHJcblx0XHRcdFx0XHRcdFx0XHQubWFwKCh4KSA9PiBbJC5jb29yZHMyU3RyaW5nKCQuaW52ZXJzZVByb2plY3RPbkZsYXQodHJhbnNsYXRlQ29vcmRpbmF0ZXMoeFswXSkpKSwgeFsxXV0pXHJcblx0XHRcdFx0XHRcdFx0LCAoeCkgPT4geFswXSlcclxuXHRcdFx0XHRcdFx0XHQubWFwKCh4KSA9PiBgJHt4WzBdfToke3hbMV19YClcclxuXHJcblxyXG5cdFx0XHRcdFx0Ly8gbGFiZWxzID0gW11cclxuXHRcdFx0XHRcdC8vIGZvciAobGV0IGkgPSAwOyBpIDwgbGFiZWxzMi5sZW5ndGg7IGkrKylcclxuXHRcdFx0XHRcdC8vIFx0bGFiZWxzID0gbGFiZWxzLmNvbmNhdChsYWJlbHMyKVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0bm9kZS5MQiA9IGxhYmVsc1xyXG5cdFx0XHRcdGlmIChub2RlLkxCLmxlbmd0aCA9PT0gMClcclxuXHRcdFx0XHRcdGRlbGV0ZSBub2RlLkxCXHJcblxyXG5cdFx0XHRcdGlmIChub2RlLkNNKVxyXG5cdFx0XHRcdFx0ZGVsZXRlIG5vZGUuQ01cclxuXHRcdFx0XHRpZiAobm9kZS5DVClcclxuXHRcdFx0XHRcdGRlbGV0ZSBub2RlLkNUXHJcblx0XHRcdH1cclxuXHJcblx0XHRjbGVhbkxhYmVscygpXHJcblx0XHRub2RlLlNaID0gb3B0aW9ucy5ib2FyZERpbWVuc2lvbnNbMF1cclxuXHRcdG5vZGUuQVAgPSBcImdvLXZhcmlhbnRzLXRyYW5zZm9ybWVyXCJcclxuXHJcblx0XHRpZiAobm9kZS5TTyAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdGxldCBjbGVhblNvdXJjZVJlZ2V4ID0gbmV3IFJlZ0V4cChgIFxcXFwoJHtzb3VyY2VTZ2ZNZXNzYWdlfVxcXFwpYClcclxuXHRcdFx0bm9kZS5TTyA9IG5vZGUuU08ucmVwbGFjZShjbGVhblNvdXJjZVJlZ2V4LCAnJylcclxuXHRcdFx0Ly8gaWYgKG5vZGUuU08gPT09ICcnKVxyXG5cdFx0XHQvLyBcdGRlbGV0ZSBub2RlLlNPXHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IHN0YXRlID0ge1xyXG5cdFx0XHR3cmFwcGVkR2FtZSwgbm9kZSwgcGVuZGluZywgY3VycmVudFBhdGgsIHNpYmxpbmdNb3Zlczoge30vLywgcGFyZW50c1dpdGhDaGlsZFRvRGVsZXRlOiBbXSBcclxuXHRcdH1cclxuXHJcblx0XHRub2RlID0gZ29UaHJvdWdoVHJlZShzdGF0ZSlcclxuXHRcdHdoaWxlIChub2RlICE9PSBudWxsKSB7XHJcblx0XHRcdGNsZWFuTGFiZWxzKClcclxuXHRcdFx0Y2xlYW5Db21tZW50cygpXHJcblxyXG5cdFx0XHRjb25zdFxyXG5cdFx0XHRcdGlzQmxhY2sgPSBub2RlLkFCICE9PSB1bmRlZmluZWQgfHwgbm9kZS5CICE9PSB1bmRlZmluZWRcclxuXHRcdFx0XHQsIGFkZGVkU3RvbmVzID0gaXNCbGFjayA/IG5vZGUuQUIgOiBub2RlLkFXXHJcblx0XHRcdFx0LCBwbGF5ZWRTdG9uZSA9IGlzQmxhY2sgPyBub2RlLkIgOiBub2RlLldcclxuXHRcdFx0XHQsIG1vdmUgPSBhZGRlZFN0b25lcyA/IGFkZGVkU3RvbmVzIDogcGxheWVkU3RvbmVcclxuXHRcdFx0XHQsIG1vdmVBc0FycmF5ID0gQXJyYXkuaXNBcnJheShtb3ZlKSA/IG1vdmUgOiBbbW92ZV1cclxuXHRcdFx0XHQsIGlzQVBhc3MgPSBpc0JsYWNrID8gbm9kZS5CID09PSAnJyA6IG5vZGUuVyA9PT0gJydcclxuXHRcdFx0XHQsIG1vdmVIYXNDb29yZHMgPSBtb3ZlICE9PSB1bmRlZmluZWQgJiYgbW92ZSAhPT0gJydcclxuXHRcdFx0XHQsIGNvb3JkcyA9ICFtb3ZlSGFzQ29vcmRzID8gdW5kZWZpbmVkIDogJC5jb29yZHMyU3RyaW5nKCQuaW52ZXJzZVByb2plY3RPbkZsYXQobW92ZUFzQXJyYXkubWFwKHRyYW5zbGF0ZUNvb3JkaW5hdGVzKSkpXHJcblxyXG5cdFx0XHQvL2FsdGVyIHRoZSBub2RlXHJcblxyXG5cdFx0XHQvKlxyXG5cdFx0XHRsb2dpYyByZW1vdmluZyBhIG5vZGUgYWRkZWQgYnkgQ0dvYm9hcmQsIGlmIHRoZXJlIGFscmVhZHkgaXMgdGhlIHNhbWUgbW92ZSBhcyBBQiBvciBBVyBpbiBhIHByaW9yIHZhcmlhdGlvbjsgYXNzdW1pbmcgXHJcblx0XHRcdHRoZSB2YXJpYXRpb24gdG8gYmUgcmVtb3ZlZCBpcyB0aGUgbGFzdCBvZiB0aGUgc2libGluZ3MgLSB3aGljaCBkb2VzIHNlZW0gdG8gYmUgdGhlIHdheSBDR29ib2FyZCBiZWhhdmVzIHdoZW4gYSBjbGljayBcclxuXHRcdFx0aXMgbWFkZSBvbiBhIHBvaW50IHdoZXJlIHRoZSBuZXh0IG5vZGUgaXMgQUIgb3IgQVcuICBcclxuXHRcdFx0Ki9cclxuXHRcdFx0aWYgKHN0YXRlLmhhc1NpYmxpbmdzKSB7XHJcblx0XHRcdFx0bGV0IHBhdGhGb3JQYXJlbnQgPSB7IC4uLndyYXBwZWRHYW1lLnBhdGggfSAvL09iamVjdC5hc3NpZ24oe30sIHdyYXBwZWRHYW1lLnBhdGgpXHJcblx0XHRcdFx0cGF0aEZvclBhcmVudC5tLS1cclxuXHRcdFx0XHRkZWxldGUgcGF0aEZvclBhcmVudFtwYXRoRm9yUGFyZW50Lm1dXHJcblx0XHRcdFx0cGF0aEZvclBhcmVudCA9IHdyYXBwZWRHYW1lLnBhdGhUcmFuc2Zvcm0ocGF0aEZvclBhcmVudClcclxuXHRcdFx0XHQvLyB3cmFwcGVkR2FtZS5wcmV2aW91cygpXHJcblx0XHRcdFx0aWYgKHN0YXRlLnNpYmxpbmdNb3Zlc1twYXRoRm9yUGFyZW50XSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHRzdGF0ZS5zaWJsaW5nTW92ZXNbcGF0aEZvclBhcmVudF0gPSBbXVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAoYWRkZWRTdG9uZXMpIHtcclxuXHRcdFx0XHRcdHN0YXRlLnNpYmxpbmdNb3Zlc1twYXRoRm9yUGFyZW50XS5wdXNoKGNvb3JkcylcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0aWYgKHBsYXllZFN0b25lICYmIHN0YXRlLnNpYmxpbmdNb3Zlc1twYXRoRm9yUGFyZW50XS5pbmRleE9mKGNvb3JkcykgPiAtMSkge1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gc3RhdGUucGFyZW50c1dpdGhDaGlsZFRvRGVsZXRlLnB1c2gocGF0aEZvclBhcmVudClcclxuXHRcdFx0XHRcdFx0bm9kZS5YWCA9IFwiaW52ZXJzZVRyYW5zZm9ybVRvRGVsZXRlXCJcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHQvLyB3cmFwcGVkR2FtZS5nb1RvKGN1cnJlbnRQYXRoKVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRkZWxldGUgbm9kZVtpc0JsYWNrID8gJ0FCJyA6ICdBVyddXHJcblx0XHRcdGRlbGV0ZSBub2RlW2lzQmxhY2sgPyAnQicgOiAnVyddXHJcblx0XHRcdGRlbGV0ZSBub2RlLkNSXHJcblx0XHRcdGRlbGV0ZSBub2RlLkFFXHJcblxyXG5cdFx0XHRpZiAoaXNBUGFzcykge1xyXG5cdFx0XHRcdG5vZGVbaXNCbGFjayA/ICdCJyA6ICdXJ10gPSAnJ1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAobW92ZUhhc0Nvb3Jkcykge1xyXG5cdFx0XHRcdG5vZGVbaXNCbGFjayA/ICdCJyA6ICdXJ10gPSBjb29yZHNcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Oy8qbm90ZTogdGhpcyBuZXh0IHNlbWljb2xvbiBpcyBuZWVkZWQhICovWy8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXh0cmEtc2VtaVxyXG5cdFx0XHRcdC8vJ0NSJyx0b2RvOiBhZGQgaWYgbm90IG1hcmtpbmcgdGhlIG1vdmVcclxuXHRcdFx0XHQnREQnLCAnTUEnLCAnU0wnLCAnU1EnLCAnVFInXS5mb3JFYWNoKGZ1bmN0aW9uIChzZ2ZQcm9wZXJ0eSkge1xyXG5cdFx0XHRcdFx0Ly8gXy5tYXAoWydERCcsJ01BJywnU0wnLCdTUScsJ1RSJ10sIGZ1bmN0aW9uKHNnZlByb3BlcnR5KXtcclxuXHRcdFx0XHRcdGlmIChub2RlW3NnZlByb3BlcnR5XSA9PT0gdW5kZWZpbmVkKSByZXR1cm5cclxuXHRcdFx0XHRcdGxldCBwb2ludHMgPSBbXVxyXG5cdFx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkobm9kZVtzZ2ZQcm9wZXJ0eV0pKSB7XHJcblx0XHRcdFx0XHRcdHBvaW50cyA9IG5vZGVbc2dmUHJvcGVydHldXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdFx0cG9pbnRzID0gW25vZGVbc2dmUHJvcGVydHldXVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0cG9pbnRzID1cclxuXHRcdFx0XHRcdFx0JC5pbnZlcnNlUHJvamVjdE9uRmxhdChcclxuXHRcdFx0XHRcdFx0XHRwb2ludHMubWFwKHRyYW5zbGF0ZUNvb3JkaW5hdGVzKSwgdHJ1ZVxyXG5cdFx0XHRcdFx0XHQpXHJcblx0XHRcdFx0XHRcdFx0Lm1hcCgkLmNvb3JkczJTdHJpbmcpXHJcblx0XHRcdFx0XHRub2RlW3NnZlByb3BlcnR5XSA9IHBvaW50c1xyXG5cdFx0XHRcdH0pXHJcblx0XHRcdC8vIG1vdmUgdG8gbmV4dCBub2RlXHJcblx0XHRcdG5vZGUgPSBnb1Rocm91Z2hUcmVlKHN0YXRlKVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHN0YXRlLnBhcmVudHNXaXRoQ2hpbGRUb0RlbGV0ZS5mb3JFYWNoKChwYXRoKSA9PiB7XHJcblx0XHQvLyBcdC8vcmVtb3ZlIHRoZSBzZ2Ygbm9kZVxyXG5cdFx0Ly8gXHR3cmFwcGVkR2FtZS5nb1RvKHBhdGgpXHJcblx0XHQvLyBcdGxldCBzZXF1ZW5jZXMgPSB3cmFwcGVkR2FtZS5nYW1lLnNlcXVlbmNlc1xyXG5cdFx0Ly8gXHRsZXQgaW5kZXggPSBfZmkoc2VxdWVuY2VzLCAoc2VxKSA9PiBzZXEubm9kZXNbMF0uaW52ZXJzZVRyYW5zZm9ybVRvRGVsZXRlKVxyXG5cdFx0Ly8gXHRcdCwgdG1wSSA9IDBcclxuXHRcdC8vIFx0d2hpbGUgKGluZGV4ID4gLTEpIHtcclxuXHRcdC8vIFx0XHRzZXF1ZW5jZXMuc3BsaWNlKGluZGV4LCAxKVxyXG5cdFx0Ly8gXHRcdGluZGV4ID0gX2ZpKHNlcXVlbmNlcywgKHNlcSkgPT4gc2VxLm5vZGVzWzBdLmludmVyc2VUcmFuc2Zvcm1Ub0RlbGV0ZSlcclxuXHRcdC8vIFx0XHR0bXBJKytcclxuXHRcdC8vIFx0XHRpZiAodG1wSSA+IDEwMCkgdGhyb3cgbmV3IEVycm9yKCdzZWVtIHRvIGJlIHN0dWNrIScpO1xyXG5cdFx0Ly8gXHR9XHJcblxyXG5cdFx0Ly8gXHQvLyBjb25zb2xlLmxvZyhwYXRoKVxyXG5cdFx0Ly8gfSlcclxuXHJcblx0XHRsZXQgZGVsZXRlTm9kZXMgPSAoc2VxdWVuY2UpID0+IHtcclxuXHRcdFx0aWYgKHNlcXVlbmNlLnNlcXVlbmNlcykge1xyXG5cclxuXHRcdFx0XHRsZXRcclxuXHRcdFx0XHRcdHNlcXVlbmNlcyA9IHNlcXVlbmNlLnNlcXVlbmNlc1xyXG5cdFx0XHRcdFx0LCBpbmRleCA9IF9maShzZXF1ZW5jZXMsIChzZXEpID0+IHNlcS5ub2Rlc1swXS5YWCA9PT0gJ2ludmVyc2VUcmFuc2Zvcm1Ub0RlbGV0ZScpXHJcblx0XHRcdFx0XHQsIHRtcEkgPSAwLCBtYXggPSBzZXF1ZW5jZXMubGVuZ3RoXHJcblx0XHRcdFx0d2hpbGUgKGluZGV4ID4gLTEpIHtcclxuXHRcdFx0XHRcdHNlcXVlbmNlcy5zcGxpY2UoaW5kZXgsIDEpXHJcblx0XHRcdFx0XHRpbmRleCA9IF9maShzZXF1ZW5jZXMsIChzZXEpID0+IHNlcS5ub2Rlc1swXS5YWCA9PT0gJ2ludmVyc2VUcmFuc2Zvcm1Ub0RlbGV0ZScpXHJcblx0XHRcdFx0XHR0bXBJKytcclxuXHRcdFx0XHRcdGlmICh0bXBJID4gbWF4KSB0aHJvdyBuZXcgRXJyb3IoJ3NlZW0gdG8gYmUgc3R1Y2shJyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGZvciAobGV0IGluZGV4MiA9IDA7IGluZGV4MiA8IHNlcXVlbmNlcy5sZW5ndGg7IGluZGV4MisrKSB7XHJcblx0XHRcdFx0XHQvLyBkZWxldGVOb2RlcyhzZXF1ZW5jZXNbaW5kZXgyXS5ub2Rlc1tzZXF1ZW5jZXNbaW5kZXgyXS5ub2Rlcy5sZW5ndGggLSAxXSk7XHJcblx0XHRcdFx0XHRkZWxldGVOb2RlcyhzZXF1ZW5jZXNbaW5kZXgyXSk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIGlmIChzZXF1ZW5jZS5ub2RlcylcclxuXHRcdFx0XHRkZWxldGVOb2RlcyhzZXF1ZW5jZS5ub2Rlc1tzZXF1ZW5jZS5ub2Rlcy5sZW5ndGggLSAxXSlcclxuXHRcdH1cclxuXHRcdGRlbGV0ZU5vZGVzKHdyYXBwZWRHYW1lLmdhbWUpXHJcblxyXG5cdFx0aWYgKG9wdGlvbnMudHJhbnNmb3JtVG9TdHJpbmcpXHJcblx0XHRcdHJldHVybiBzbWFydGdhbWUuZ2VuZXJhdGUoeyBnYW1lVHJlZXM6IFt3cmFwcGVkR2FtZS5nYW1lXSB9KTtcclxuXHRcdGVsc2UgcmV0dXJuIHdyYXBwZWRHYW1lXHJcblxyXG5cdH1cclxuXHQkLmludmVyc2VUcmFuc2Zvcm0gPSBpbnZlcnNlVHJhbnNmb3JtXHJcblxyXG5cdC8qKlxyXG5cdCAqIE1haW4gZnVuY3Rpb247IGNvbnZlcnRzIFNHRiBmb3IgYSBHbyB2YXJpYW50IChzbyBmYXIsIGp1c3QgdG9yb2lkYWwgR28gb3IgdC1HbykuXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IHRTZ2ZcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gdEdvIEVuZ2luZSBmb3IgY291bnRpbmcgbGliZXJ0aWVzIGluIHQtR28uIEFuIGluc3RhbmNlIG9mIGdvLXZhcmlhbnRzLWVuZ2luZS5cclxuXHQgKiBAcGFyYW0geyp9IHNtYXJ0Z2FtZVxyXG5cdCAqIEBwYXJhbSB7Kn0gc21hcnRnYW1lclxyXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd8b2JqZWN0fSBTR0YgdGhhdCBjYW4gYmUgdmlld2VkIGluIGEgc3RhbmRhcmQgU0dGIHZpZXdlci4gKFNlZSBgb3B0aW9ucy50cmFuc2Zvcm1Ub1N0cmluZ2AgZm9yIHRoZSBkYXRhIHR5cGUgb2YgdGhlIHZhbHVlIHJldHVybmVkLilcclxuXHQgKiBAcHVibGljXHJcblx0ICovXHJcblx0ZnVuY3Rpb24gdHJhbnNmb3JtKFxyXG5cdFx0dFNnZiAvL2VnIDExeDExIHNnZiBmcm9tIExpdHRsZUdvbGVtXHJcblx0XHQsIHRHbyAvL2FwcCBpbXBsZW1lbnRpbmcgdC1Hb1xyXG5cdFx0LCBzbWFydGdhbWVcclxuXHRcdCwgc21hcnRnYW1lcikge1xyXG5cclxuXHRcdGlmICh0R28gPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHQvLyAgdEdvID0gcmVxdWlyZSgnLi4vZGlzdC9ub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL3NyYy9lbmdpbmUubWluLmpzJykoe1xyXG5cdFx0XHQvLyAgdEdvID0gcmVxdWlyZSgnLi4vLi4vZW5naW5lL2Rpc3QvZW5naW5lLm1pbi5qcycpKHtcclxuXHRcdFx0XHR0R28gPSByZXF1aXJlKCdnby12YXJpYW50cy1lbmdpbmUnKSh7XHJcblx0XHRcdFx0XHQvLyB0R28gPSByZXF1aXJlKCcuLi9ub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL3NyYy9lbmdpbmUnKSh7XHJcblx0XHRcdFx0Ly8gYm9hcmRNb2RlOid0JyxcclxuXHRcdFx0XHRib2FyZERpbWVuc2lvbnM6IG9wdGlvbnMuYm9hcmREaW1lbnNpb25zXHJcblx0XHRcdH0pXHJcblx0XHRcdC8vIHRHbyA9IHJlcXVpcmUoJy4uL25vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUnKSh7Ym9hcmRNb2RlOid0JywgYm9hcmREaW1lbnNpb25zOm9wdGlvbnMuYm9hcmREaW1lbnNpb25zfSlcclxuXHRcdFx0Ly8gdEdvID0gcmVxdWlyZSgnLi4vbm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9zcmMvZW5naW5lJykoe2JvYXJkTW9kZTondCcsIGJvYXJkRGltZW5zaW9uczpvcHRpb25zLmJvYXJkRGltZW5zaW9uc30pXHJcblx0XHR9XHJcblx0XHQvLyBlbHNlIHtcclxuXHRcdC8vIFx0dEdvLm9wdGlvbnMuYm9hcmREaW1lbnNpb25zID0gb3B0aW9ucy5ib2FyZERpbWVuc2lvbnNcclxuXHRcdC8vIH1cclxuXHJcblx0XHRpZiAoc21hcnRnYW1lID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0c21hcnRnYW1lID0gcmVxdWlyZSgnc21hcnRnYW1lJylcclxuXHRcdH1cclxuXHRcdGlmIChzbWFydGdhbWVyID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0c21hcnRnYW1lciA9IHJlcXVpcmUoJ3NtYXJ0Z2FtZXInKVxyXG5cdFx0fVxyXG5cdFx0Ly8gY29uc29sZS5sb2codEdvKVxyXG5cdFx0bGV0IHBhcnNlZCA9IHNtYXJ0Z2FtZS5wYXJzZSh0U2dmKVxyXG5cdFx0XHQsIHdyYXBwZWRHYW1lID0gc21hcnRnYW1lcihwYXJzZWQpXHJcblx0XHRcdCwgbm9kZSA9IHdyYXBwZWRHYW1lLm5vZGUoKVxyXG5cdFx0XHQsIHBhc3NlcyA9IDBcclxuXHRcdFx0LCBwZW5kaW5nID0gW11cclxuXHRcdFx0LCBjdXJyZW50UGF0aCA9IHsgbTogMCB9XHJcblx0XHRpZiAobm9kZS5TWiAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdGxldCBzeiA9IE51bWJlcihub2RlLlNaKVxyXG5cdFx0XHQvLyBzeis9IDIqb3B0aW9ucy5wcm9qZWN0aW9uU2V0dGluZ3Mud3JhcGFyb3VuZFxyXG5cdFx0XHRvcHRpb25zLmJvYXJkRGltZW5zaW9ucyA9IFtzeiwgc3pdXHJcblx0XHRcdHRHby5vcHRpb25zLmJvYXJkRGltZW5zaW9ucyA9IG9wdGlvbnMuYm9hcmREaW1lbnNpb25zXHJcblx0XHRcdHNldFVwTWFya2VycygpXHJcblx0XHR9XHJcblx0XHRpZiAobm9kZS5LTSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdG9wdGlvbnMucnVsZXMgPSB7a29taTogcGFyc2VGbG9hdChub2RlLktNKSwgLi4uIG9wdGlvbnMucnVsZXMgfVxyXG5cdFx0fVxyXG5cdFx0bm9kZS5TWiA9IFwiXCIgKyAob3B0aW9ucy5ib2FyZERpbWVuc2lvbnNbMF0gKyAyICogb3B0aW9ucy5wcm9qZWN0aW9uU2V0dGluZ3Mud3JhcGFyb3VuZCkvL25vdCBzdXJlIGhvdyB0byBtYWtlIGEgcmVjdGFuZ3VsYXIgZ29iYW4hXHJcblx0XHQvL29mZnNldCBtb2R1bG9cclxuXHRcdG9wdGlvbnMucHJvamVjdGlvblNldHRpbmdzLm9mZnNldFswXSA9IG1vZHVsbyhvcHRpb25zLnByb2plY3Rpb25TZXR0aW5ncy5vZmZzZXRbMF0sIG9wdGlvbnMuYm9hcmREaW1lbnNpb25zWzBdKVxyXG5cdFx0b3B0aW9ucy5wcm9qZWN0aW9uU2V0dGluZ3Mub2Zmc2V0WzFdID0gbW9kdWxvKG9wdGlvbnMucHJvamVjdGlvblNldHRpbmdzLm9mZnNldFsxXSwgb3B0aW9ucy5ib2FyZERpbWVuc2lvbnNbMV0pXHJcblx0XHRsZXQgc2V0TGFiZWxzID0gKCkgPT4ge1xyXG5cdFx0XHQvL25vZGUuTEIgPSAkLndyYXBhcm91bmRBbmRDb29yZHNcclxuXHRcdFx0bGV0IGxhYmVscyA9IFtdXHJcblx0XHRcdGlmIChub2RlLkxCICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRsYWJlbHMgPSBub2RlLkxCXHJcblx0XHRcdFx0aWYgKCFBcnJheS5pc0FycmF5KGxhYmVscykpXHJcblx0XHRcdFx0XHRsYWJlbHMgPSBbbGFiZWxzXVxyXG5cclxuXHRcdFx0XHQvKiBqc2hpbnQgbG9vcGZ1bmM6IHRydWUgKi9cclxuXHRcdFx0XHRsZXQgbGFiZWxzMiA9IGxhYmVscy8vXy5jaGFpbihsYWJlbHMpXHJcblx0XHRcdFx0XHQubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LnNwbGl0KCc6JywgMikgfSkvL2Fzc3VtZSB0aGUgbGFiZWwgZG9lc27igJl0IGNvbnRhaW4g4oCcOuKAnVxyXG5cdFx0XHRcdFx0Lm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4gW3RyYW5zbGF0ZUNvb3JkaW5hdGVzKHhbMF0pLCB4WzFdXSB9KVxyXG5cdFx0XHRcdFx0Lm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4gWyQucHJvamVjdE9uRmxhdCh4WzBdKSwgeFsxXV0gfSlcclxuXHRcdFx0XHQvLyAudmFsdWUoKVxyXG5cdFx0XHRcdGxhYmVscyA9IFtdXHJcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsYWJlbHMyLmxlbmd0aDsgaSsrKVxyXG5cdFx0XHRcdFx0bGFiZWxzID0gbGFiZWxzLmNvbmNhdChcclxuXHRcdFx0XHRcdFx0bGFiZWxzMltpXVswXS5tYXAoZnVuY3Rpb24gKHgpIHtcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gJC5jb29yZHMyU3RyaW5nKHgpICsgXCI6XCIgKyBsYWJlbHMyW2ldWzFdXHJcblx0XHRcdFx0XHRcdH0pXHJcblx0XHRcdFx0XHQpXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG5vZGUuTEIgPSAkLndyYXBhcm91bmRBbmRDb29yZHMuY29uY2F0KGxhYmVscylcclxuXHRcdFx0aWYgKG5vZGUuTEIubGVuZ3RoID09PSAwKVxyXG5cdFx0XHRcdC8vIGRlbGV0ZSBub2RlWydMQiddXHJcblx0XHRcdFx0ZGVsZXRlIG5vZGUuTEJcclxuXHRcdH1cclxuXHJcblx0XHRzZXRMYWJlbHMoKVxyXG5cclxuXHRcdGlmIChub2RlLlNPICE9PSB1bmRlZmluZWQpXHJcblx0XHRcdG5vZGUuU08gPSB3cmFwcGVkR2FtZS5nYW1lLm5vZGVzWzBdLlNPICsgYCAoJHtzb3VyY2VTZ2ZNZXNzYWdlfSlgXHJcblx0XHQvL2Vsc2Ugbm9kZS5TTyA9IHNvdXJjZVNnZk1lc3NhZ2UvL3ByZWZlciBub3QgdG8gYWRkIHRoZSBtZXNzYWdlIHdoZW4gb3JpZ2luYWwgU2dmIGhhcyBubyBTTyBpbmZvLlxyXG5cclxuXHRcdG5vZGUuQVAgPSBcImdvLXZhcmlhbnRzLXRyYW5zZm9ybWVyXCJcclxuXHJcblxyXG5cdFx0bGV0IHN0YXRlID0geyB3cmFwcGVkR2FtZSwgbm9kZSwgcGVuZGluZywgY3VycmVudFBhdGgsIHRHbyB9XHJcblxyXG5cdFx0ZnVuY3Rpb24gY29tbWVudChpc1Bhc3MsIGlzQmxhY2ssIHNjb3JlKSB7XHJcblx0XHRcdGlmICghb3B0aW9ucy5hZGRDb21tZW50cyAmJiAhc2NvcmUpXHJcblx0XHRcdFx0cmV0dXJuXHJcblxyXG5cdFx0XHRsZXQgciA9ICFvcHRpb25zLmFkZENvbW1lbnRzID9cclxuXHRcdFx0XHQnJ1xyXG5cdFx0XHRcdDogJ21vdmUgJyArIHN0YXRlLmN1cnJlbnRQYXRoLm0gKyAnXFxuJyArICdXaGl0ZSBzdG9uZXMgY2FwdHVyZWQgYnkgQmxhY2s6ICcgKyB0R28uYm9hcmQuY2FwdHVyZWRbMV0gKyAnXFxuQmxhY2sgc3RvbmVzIGNhcHR1cmVkIGJ5IFdoaXRlOiAnICsgdEdvLmJvYXJkLmNhcHR1cmVkWzBdXHJcblx0XHRcdFx0Ly9sZXQgciA9ICAnQmxhY2sgY2FwdHVyZXM6ICcgKyB0R28uYm9hcmQuY2FwdHVyZWRbMV0gKyAnXFxyXFxuV2hpdGUgY2FwdHVyZXM6ICcgKyB0R28uYm9hcmQuY2FwdHVyZWRbMF1cclxuXHRcdFx0XHQrICghaXNQYXNzID8gJycgOiAnXFxuJyArIChpc0JsYWNrID8gJ0JsYWNrIHBhc3NlcycgOiAnV2hpdGUgcGFzc2VzJykpXHJcblx0XHRcdFx0KyAoIXNjb3JlID8gJycgOiAnXFxuJyArIGByZXN1bHQ6ICR7c2NvcmUuZGlzcGxheVJlc3VsdH1gKVxyXG5cclxuXHRcdFx0ciArPSAnXFxuLS0odGhlIGNvbnRlbnQgYWJvdmUgd2FzIGdlbmVyYXRlZCBhdXRvbWF0aWNhbGx5IGJ5IEdvVmFyaWFudHNUcmFuc2Zvcm1lciktLSdcclxuXHRcdFx0ciArPSAobm9kZS5DID09PSB1bmRlZmluZWQgPyAnJyA6ICdcXG4nICsgbm9kZS5DKVxyXG5cdFx0XHRub2RlLkMgPSByXHJcblx0XHRcdHJldHVyblxyXG5cdFx0fVxyXG5cclxuXHRcdG5vZGUgPSBnb1Rocm91Z2hUcmVlKHN0YXRlKVxyXG5cdFx0d2hpbGUgKG5vZGUgIT09IG51bGwpIHtcclxuXHJcblxyXG5cdFx0XHRsZXRcclxuXHRcdFx0XHRpc0JsYWNrID0gbm9kZS5CICE9PSB1bmRlZmluZWRcclxuXHRcdFx0XHQsIG1vdmUgPSBpc0JsYWNrID8gbm9kZS5CIDogbm9kZS5XXHJcblx0XHRcdFx0LCBpc1Bhc3MgPSBtb3ZlID09PSBcIlwiIHx8IChvcHRpb25zLmJvYXJkRGltZW5zaW9uc1swXSA9PT0gb3B0aW9ucy5ib2FyZERpbWVuc2lvbnNbMV1cclxuXHRcdFx0XHRcdCYmIG9wdGlvbnMuYm9hcmREaW1lbnNpb25zWzBdIDw9IDE5XHJcblx0XHRcdFx0XHQmJiBtb3ZlID09PSBcInR0XCIgLy93ZWlyZCBTR0ZbM10gd2F5IHRvIHNob3cgYSBwYXNzIG1vdmUhXHJcblx0XHRcdFx0KVxyXG5cdFx0XHRcdCwgc3RvbmVzTWFya2VkRm9yU2NvcmluZyA9IFtdXHJcblxyXG5cdFx0XHRpZiAobW92ZSA9PT0gdW5kZWZpbmVkICYmICFpc1Bhc3MpIHtcclxuXHRcdFx0XHRub2RlID0gZ29UaHJvdWdoVHJlZShzdGF0ZSlcclxuXHRcdFx0XHRjb250aW51ZVxyXG5cdFx0XHR9XHJcblx0XHRcdHNldExhYmVscygpXHJcblxyXG5cdFx0XHRpZiAoaXNQYXNzKSB7XHJcblx0XHRcdFx0ZGVsZXRlIG5vZGVbaXNCbGFjayA/ICdCJyA6ICdXJ11cclxuXHRcdFx0XHRjb21tZW50KGlzUGFzcywgaXNCbGFjaylcclxuXHRcdFx0XHRub2RlW2lzQmxhY2sgPyAnQUInIDogJ0FXJ10gPSBbXVxyXG5cdFx0XHRcdC8vIGlmIChwYXNzZXMgPT09IDIpIHtcclxuXHRcdFx0XHQvLyBcdC8vd3JhcHBlZEdhbWUuZ2FtZS5ub2Rlcy5zcGxpY2UoaSsxKS8vZ2V0IHJpZCBvZiBub2RlcyBhZnRlcndhcmRzIC0tIG1heSBub3Qgd29yayB3aXRoIHZhcmlhdGlvbnMhIHRvZG9cclxuXHRcdFx0XHQvLyBcdGJyZWFrOy8vc3RvcCBhZnRlciAzIHN1Y2Nlc3NpdmUgcGFzc2VzIGZvciBub3dcclxuXHRcdFx0XHQvLyB9XHJcblx0XHRcdFx0cGFzc2VzKytcclxuXHRcdFx0XHRpZiAocGFzc2VzID49IDEwMDApXHJcblx0XHRcdFx0XHRicmVhay8vanVzdCBpbiBjYXNlIVxyXG5cdFx0XHRcdG5vZGUgPSBnb1Rocm91Z2hUcmVlKHN0YXRlKVxyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdGNvbnN0IGNvb3JkcyA9IHRyYW5zbGF0ZUNvb3JkaW5hdGVzKG1vdmUpXHJcblx0XHRcdFx0bGV0IHBsYXlSZXN1bHQgPSBudWxsXHJcblx0XHRcdFx0Ly8gcnVuIG1vdmUgdGhyb3VnaCB0R28gYW5kIHVwZGF0ZSBnYW1lIGFjY29yZGluZ2x5XHJcblx0XHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRcdHBsYXlSZXN1bHQgPSB0R28ucGxheShpc0JsYWNrID8gJ2InIDogJ3cnLCBjb29yZHMpXHJcblxyXG5cdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XHJcblx0XHRcdFx0XHRpZiAoZXJyb3IubWVzc2FnZSAhPT0gJ3BvaW50IGlzIG5vdCBlbXB0eScgLyppZ25vcmUgdGhpcyAtIGl0IGhhcHBlbnMgd2l0aCBzb21lIHNnZiBmcm9tIGxpdHRsZUdvbGVtLiBUb2RvOiBsb29rIGludG8gc2NvcmluZyB0aGUgcG9zaXRpb24gaGVyZS4gKi8pXHJcblx0XHRcdFx0XHRcdHRocm93IChlcnJvcilcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Y29uc3QgcHJvamVjdGVkQ29vcmRzID0gJC5wcm9qZWN0T25GbGF0KGNvb3JkcylcclxuXHRcdFx0XHRsZXQgdG9BZGQgPSBwbGF5UmVzdWx0ID09PSBudWxsID8gW10gOiBwcm9qZWN0ZWRDb29yZHMubWFwKCQuY29vcmRzMlN0cmluZylcclxuXHRcdFx0XHRcdCwgdG9SZW1vdmUgPSBwbGF5UmVzdWx0ID09PSBudWxsID8gW10gOlxyXG5cdFx0XHRcdFx0XHQvLyBfLmNoYWluKHBsYXlSZXN1bHQucmVtb3ZlZClcclxuXHRcdFx0XHRcdFx0Ly8gXHQuZmxhdHRlbih0cnVlKVxyXG5cdFx0XHRcdFx0XHQvLyBcdC5tYXAoJC5wcm9qZWN0T25GbGF0KVxyXG5cdFx0XHRcdFx0XHQvLyBcdC5mbGF0dGVuKHRydWUpXHJcblx0XHRcdFx0XHRcdC8vIFx0Lm1hcCgkLmNvb3JkczJTdHJpbmcpXHJcblx0XHRcdFx0XHRcdC8vIFx0LnZhbHVlKClcclxuXHRcdFx0XHRcdFx0X2ZsYXR0ZW4oXHJcblx0XHRcdFx0XHRcdFx0X2ZsYXR0ZW4ocGxheVJlc3VsdC5yZW1vdmVkKVxyXG5cdFx0XHRcdFx0XHRcdFx0Lm1hcCgkLnByb2plY3RPbkZsYXQpKVxyXG5cdFx0XHRcdFx0XHRcdC5tYXAoJC5jb29yZHMyU3RyaW5nKVxyXG5cclxuXHRcdFx0XHQvL2FsdGVyIHRoZSBub2RlXHJcblx0XHRcdFx0aWYgKG9wdGlvbnMuYWRkUGFzc2VzKVxyXG5cdFx0XHRcdFx0bm9kZVtpc0JsYWNrID8gJ0InIDogJ1cnXSA9ICcnXHJcblx0XHRcdFx0ZWxzZSBkZWxldGUgbm9kZVtpc0JsYWNrID8gJ0InIDogJ1cnXVxyXG5cdFx0XHRcdC8vIG5vZGVbaXNCbGFjayA/ICdCJyA6ICdXJ10gPSAnJ1xyXG5cdFx0XHRcdG5vZGVbaXNCbGFjayA/ICdBQicgOiAnQVcnXSA9IHRvQWRkXHJcblx0XHRcdFx0aWYgKHRvQWRkLmxlbmd0aCA+IDApXHJcblx0XHRcdFx0XHRub2RlLkNSID0gdG9BZGRcclxuXHRcdFx0XHRpZiAodG9SZW1vdmUubGVuZ3RoID4gMClcclxuXHRcdFx0XHRcdG5vZGUuQUUgPSB0b1JlbW92ZVxyXG5cclxuXHRcdFx0XHRcdFx0LypcclxuXHRcdFx0XHRcdFx0dG9kbzogb3RoZXIgcHJvcGVydGllcyB3aXRoIGJvYXJkIGNvb3JkaW5hdGVzXHJcblx0XHRcdFx0XHRcdExlYXZlIGZvciBub3c6XHJcblx0XHRcdFx0XHRcdEFSXHJcblx0XHRcdFx0XHRcdExOXHJcblx0XHRcdFx0XHRcdCovXHJcblxyXG5cdFx0XHRcdFx0XHQ7Lypub3RlIHRoaXMgc2VtaWNvbG9uIGlzIG5lZWRlZCEgKi9cclxuXHRcdFx0XHRbXHJcblx0XHRcdFx0XHQvLydDUicsdG9kbzogYWRkIGlmIG5vdCBtYXJraW5nIHRoZSBtb3ZlXHJcblx0XHRcdFx0XHQnREQnLCAnTUEnLCAnU0wnLCAnU1EnLCAnVFInXS5mb3JFYWNoKGZ1bmN0aW9uIChzZ2ZQcm9wZXJ0eSkge1xyXG5cdFx0XHRcdFx0XHQvLyBfLm1hcChbJ0REJywnTUEnLCdTTCcsJ1NRJywnVFInXSwgZnVuY3Rpb24oc2dmUHJvcGVydHkpe1xyXG5cdFx0XHRcdFx0XHRpZiAobm9kZVtzZ2ZQcm9wZXJ0eV0gPT09IHVuZGVmaW5lZCkgcmV0dXJuXHJcblx0XHRcdFx0XHRcdGxldCBwb2ludHMgPSBbXVxyXG5cdFx0XHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheShub2RlW3NnZlByb3BlcnR5XSkpIHtcclxuXHRcdFx0XHRcdFx0XHRwb2ludHMgPSBub2RlW3NnZlByb3BlcnR5XVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdHBvaW50cyA9IFtub2RlW3NnZlByb3BlcnR5XV1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRpZiAobm9kZS5TQyAmJiBzZ2ZQcm9wZXJ0eSA9PT0gJ01BJykge1xyXG5cdFx0XHRcdFx0XHRcdHN0b25lc01hcmtlZEZvclNjb3JpbmcgPSB7IC4uLnBvaW50cyB9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0cG9pbnRzID1cclxuXHRcdFx0XHRcdFx0XHQvLyBfLmNoYWluKHBvaW50cylcclxuXHRcdFx0XHRcdFx0XHQvLyBcdC5tYXAodHJhbnNsYXRlQ29vcmRpbmF0ZXMpXHJcblx0XHRcdFx0XHRcdFx0Ly8gXHQubWFwKCQucHJvamVjdE9uRmxhdClcclxuXHRcdFx0XHRcdFx0XHQvLyBcdC5mbGF0dGVuKHRydWUpXHJcblx0XHRcdFx0XHRcdFx0Ly8gXHQubWFwKCQuY29vcmRzMlN0cmluZylcclxuXHRcdFx0XHRcdFx0XHQvLyBcdC52YWx1ZSgpXHJcblx0XHRcdFx0XHRcdFx0X2ZsYXR0ZW4oXHJcblx0XHRcdFx0XHRcdFx0XHRwb2ludHNcclxuXHRcdFx0XHRcdFx0XHRcdFx0Lm1hcCh0cmFuc2xhdGVDb29yZGluYXRlcylcclxuXHRcdFx0XHRcdFx0XHRcdFx0Lm1hcCgkLnByb2plY3RPbkZsYXQpXHJcblx0XHRcdFx0XHRcdFx0KVxyXG5cdFx0XHRcdFx0XHRcdFx0Lm1hcCgkLmNvb3JkczJTdHJpbmcpXHJcblx0XHRcdFx0XHRcdG5vZGVbc2dmUHJvcGVydHldID0gcG9pbnRzXHJcblx0XHRcdFx0XHR9KVxyXG5cdFx0XHRcdG5vZGUuTU4gPSBjdXJyZW50UGF0aC5tXHJcblxyXG5cdFx0XHRcdC8qXHJcblx0XHRcdFx0VXNlIGEgY3VzdG9tLCBuZXcgU0dGIHByb3BlcnR5LCBTQywgaW4gb3JkZXIgdG8gc2VlIGlmIHRoZSBjdXJyZW50IHBvc2l0aW9uIHNob3VsZCBiZSBzY29yZWQsIGFuZCBpZiBzbywgd2hhdCB0byBkbyB3aXRoIHRoZSBzY29yZS5cclxuXHRcdFx0XHRJdOKAmXMgYSBiaXQgZmxhZy4gIFxyXG5cdFx0XHRcdDFcdOKHkiB1cGRhdGUgdGhlIGNvbW1lbnRzIGZvciB0aGUgbm9kZSAoc3VjY2ludCkuIFdoZW4gZmxhZ2dlZCwgdGhlIG5leHQgb3B0aW9uIGlzIG5vdCBhdmFpbGFibGUuXHJcblx0XHRcdFx0Mlx04oeSIHVwZGF0ZSB0aGUgY29tbWVudHMgZm9yIHRoZSBub2RlICh2ZXJib3NlKVxyXG5cdFx0XHRcdDRcdOKHkiB1cGRhdGUgdGhlIGdhbWUgcmVzdWx0IChSRSkgZm9yIHRoZSByb290IG5vZGVcclxuXHRcdFx0XHRUeXBpY2FsIHVzYWdlOiBhZGQg4oCcU0NbNl3igJ0gdG8gdGhlIGxhc3Qgbm9kZSwgYW5kIOKAnFNDWzJd4oCdIHRvIHNjb3JlIGEgdmFyaWF0aW9uLlxyXG5cdFx0XHRcdCovXHJcblx0XHRcdFx0bGV0IHVwZGF0ZWRDb21tZW50ID0gZmFsc2VcclxuXHRcdFx0XHRpZiAobm9kZS5TQykge1xyXG5cdFx0XHRcdFx0bGV0IHNjb3JlID0gZW5naW5lLnNjb3JlKHN0b25lc01hcmtlZEZvclNjb3JpbmcpXHJcblx0XHRcdFx0XHRpZiAobm9kZS5TQyAmIDEgPT09IDEpIHtcclxuXHRcdFx0XHRcdFx0dXBkYXRlZENvbW1lbnQgPSB0cnVlXHJcblx0XHRcdFx0XHRcdGNvbW1lbnQoaXNQYXNzLCBpc0JsYWNrLCBzY29yZS5SRSlcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGVsc2UgLypkb24ndCB3YW50IHRvIHRyZWF0IHN1Y2NpbnQgYW5kIHZlcmJvc2UgYXQgdGhlIHNhbWUgdGltZSovIGlmIChub2RlLlNDICYgMiA9PT0gMikge1xyXG5cdFx0XHRcdFx0XHR1cGRhdGVkQ29tbWVudCA9IHRydWVcclxuXHRcdFx0XHRcdFx0Y29tbWVudChpc1Bhc3MsIGlzQmxhY2ssXHJcblx0XHRcdFx0XHRcdFx0YEJsYWNrOiAke3Njb3JlLnRvdGFsV2hpdGVEZWFkXHJcblx0XHRcdFx0XHRcdFx0KyBzY29yZS50b3RhbFdoaXRlQ2FwdHVyZWRcclxuXHRcdFx0XHRcdFx0XHQrIHNjb3JlLnRvdGFsQmxhY2tUZXJyaXRvcnl9ID0gJHtzY29yZS50b3RhbEJsYWNrVGVycml0b3J5fSB0ZXJyaXRvcnkgKyAke3Njb3JlLnRvdGFsV2hpdGVEZWFkICsgc2NvcmUudG90YWxXaGl0ZUNhcHR1cmVkfSBwcmlzb25lcnNcclxuV2hpdGU6ICR7c2NvcmUudG90YWxCbGFja0RlYWRcclxuXHRcdFx0XHRcdFx0XHQrIHNjb3JlLnRvdGFsQmxhY2tDYXB0dXJlZFxyXG5cdFx0XHRcdFx0XHRcdCsgc2NvcmUudG90YWxXaGl0ZVRlcnJpdG9yeX0gPSAke3Njb3JlLnRvdGFsV2hpdGVUZXJyaXRvcnl9IHRlcnJpdG9yeSArICR7c2NvcmUudG90YWxCbGFja0RlYWQgKyBzY29yZS50b3RhbEJsYWNrQ2FwdHVyZWR9IHByaXNvbmVycyArJHtlbmdpbmUucnVsZXMua29taX0ga29taWApXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiAobm9kZS5TQyAmIDQgPT09IDQpIHtcclxuXHRcdFx0XHRcdFx0d3JhcHBlZEdhbWUuZ2FtZS5ub2Rlc1swXS5SRSA9IHNjb3JlLlJFXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmICghdXBkYXRlZENvbW1lbnQpXHJcblx0XHRcdFx0XHRjb21tZW50KGlzUGFzcywgaXNCbGFjaylcclxuXHJcblx0XHRcdFx0Ly8gbW92ZSB0byBuZXh0IG5vZGVcclxuXHRcdFx0XHRub2RlID0gZ29UaHJvdWdoVHJlZShzdGF0ZSlcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0aWYgKG9wdGlvbnMudHJhbnNmb3JtVG9TdHJpbmcpXHJcblx0XHRcdHJldHVybiBzbWFydGdhbWUuZ2VuZXJhdGUoeyBnYW1lVHJlZXM6IFt3cmFwcGVkR2FtZS5nYW1lXSB9KTtcclxuXHRcdGVsc2UgcmV0dXJuIHdyYXBwZWRHYW1lXHJcblx0fVxyXG5cdCQudHJhbnNmb3JtID0gdHJhbnNmb3JtXHJcblx0cmV0dXJuICRcclxuXHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSB0cmFuc2Zvcm1lciIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xyXG4vKiBnbG9iYWwgR29Cb2FyZEFwaSAqL1xyXG4vKiBlc2xpbnQgbm8tY29uc29sZTogMCAqL1xyXG5kb2N1bWVudC5nb1ZhcmlhbnRzRWRpdG9yID0gZnVuY3Rpb24gKGVkaXRvck9wdGlvbnMpIHtcclxuXHRlZGl0b3JPcHRpb25zID0geyByb290SWQ6ICdzZ2ZFZGl0b3InLCBzaG93RXh0cmFzOiB0cnVlLCAuLi5lZGl0b3JPcHRpb25zIH1cclxuXHR2YXIgeyByb290SWQsIHNob3dFeHRyYXMgfSA9IGVkaXRvck9wdGlvbnNcclxuXHRcdCwgZWRpdG9yVGVtcGxhdGUgPSByZXF1aXJlKCcuL2VkaXRvci5qc3gnKVxyXG5cdFx0LCBnb192YXJpYW50c190cmFuc2Zvcm1lciA9IHJlcXVpcmUoJy4uL3NyYy90cmFuc2Zvcm1lcicpXHJcblx0Ly8gZG9jdW1lbnQudmlld2VyID0ge31cclxuXHQvLyB2YXIgdmlld2VyID0gZG9jdW1lbnQudmlld2VyXHJcblx0dmFyIHZpZXdlciA9IHt9XHJcblx0aWYgKHZpZXdlci5yYW4pIHJldHVyblxyXG5cdHZpZXdlci5yYW4gPSB0cnVlLy9qdXN0IHJ1biB0aGlzIGZ1bmN0aW9uIG9uY2VcclxuXHJcblx0ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocm9vdElkKS5hcHBlbmRDaGlsZChlZGl0b3JUZW1wbGF0ZShyb290SWQpKVxyXG5cclxuXHR2YXIgZ2V0RWxlbWVudEJ5SWRTdWZmaXggPSAoc3VmZml4KSA9PiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChyb290SWQgKyAnXycgKyBzdWZmaXgpXHJcblxyXG5cclxuXHRnZXRFbGVtZW50QnlJZFN1ZmZpeCgndXBkYXRlQnV0dG9uJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB1cGRhdGVWYXJpYW50U2dmKVxyXG5cclxuXHRcdDtbXS5mb3JFYWNoLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChgIyR7cm9vdElkfV92aWV3ZXJDb250cm9scyBpbnB1dFt0eXBlPWJ1dHRvbl1gKSwgZnVuY3Rpb24gKGVsKSB7XHJcblx0XHRcdGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50XHJcblx0XHRcdFx0c2hvd0JvYXJkKHsgcGFubmluZ0RpcmVjdGlvbjogdGFyZ2V0LnZhbHVlIH0pXHJcblx0XHRcdH0pXHJcblx0XHR9KVxyXG5cclxuXHRpZiAoc2hvd0V4dHJhcykge1xyXG5cdFx0W10uZm9yRWFjaC5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYCMke3Jvb3RJZH0gLmdvLXZhcmlhbnRzLWV4dHJhc2ApLCBmdW5jdGlvbiAoZWwpIHtcclxuXHRcdFx0ZWwuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUtYmxvY2snXHJcblx0XHR9KVxyXG5cclxuXHRcdC8vIDsvKmFub3RoZXIgc2VtaWNvbG9uIHRoYXQncyBuZWVkZWQuLi4qL1tdLmZvckVhY2guY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGAjJHtyb290SWR9IGZpZWxkc2V0LmdvLXZhcmlhbnRzLWV4dHJhc2ApLCBmdW5jdGlvbiAoZWwpIHtcclxuXHRcdC8vIFx0ZWwuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUtYmxvY2snXHJcblx0XHQvLyB9KVxyXG5cclxuXHJcblx0XHRsZXQgc2VsZWN0ID0gZ2V0RWxlbWVudEJ5SWRTdWZmaXgoJ3NpemVTZWxlY3QnKVxyXG5cdFx0Zm9yIChsZXQgaW5kZXggPSA0OyBpbmRleCA8IDIwOyBpbmRleCsrKSB7XHJcblx0XHRcdGNvbnN0IG9wdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpXHJcblx0XHRcdG9wdGlvbi52YWx1ZSA9ICcnICsgaW5kZXhcclxuXHRcdFx0b3B0aW9uLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGluZGV4KSlcclxuXHRcdFx0c2VsZWN0LmFwcGVuZENoaWxkKG9wdGlvbilcclxuXHRcdH1cclxuXHJcblx0fSBlbHNlIHtcclxuXHRcdFtdLmZvckVhY2guY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGAjJHtyb290SWR9IC5nby12YXJpYW50cy1leHRyYXNgKSwgZnVuY3Rpb24gKGVsKSB7XHJcblx0XHRcdC8vZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbClcclxuXHRcdFx0ZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xyXG5cdFx0fSlcclxuXHR9XHJcblxyXG5cdGdldEVsZW1lbnRCeUlkU3VmZml4KCdnb0J1dHRvbicpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xyXG5cdFx0c2hvd0JvYXJkKClcclxuXHR9KVxyXG5cdGdldEVsZW1lbnRCeUlkU3VmZml4KCdnb0xnQnV0dG9uJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XHJcblx0XHRnZXRMaXR0bGVHb2xlbVNnZkFuZFNob3dCb2FyZCgpXHJcblx0fSlcclxuXHRnZXRFbGVtZW50QnlJZFN1ZmZpeCgnbmV3QnV0dG9uJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XHJcblx0XHRnZXRFbGVtZW50QnlJZFN1ZmZpeChcInNnZkluXCIpLnZhbHVlID0gYCg7R01bMV1GRls0XUFQW2dvLXZhcmlhbnRzLXRyYW5zZm9ybWVyXVNaWyR7Z2V0RWxlbWVudEJ5SWRTdWZmaXgoJ3NpemVTZWxlY3QnKS52YWx1ZX1dKWBcclxuXHRcdHNob3dCb2FyZCgpXHJcblx0fSlcclxuXHJcblx0Z2V0RWxlbWVudEJ5SWRTdWZmaXgoJ3ZpZXdlckNvbnRyb2xzJykuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiXHJcblxyXG5cdC8vc3RhcnR1cFxyXG5cdHZhciBpbnB1dFNnZk5vZGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFxyXG5cdFx0Ly8gYCMke3Jvb3RJZH0gLmdvLXZhcmlhbnRzLWRhdGE6Zmlyc3Qtb2YtdHlwZWApXHJcblx0XHRgIyR7cm9vdElkfSAuZ28tdmFyaWFudHMtZGF0YWApXHJcblx0aWYgKGlucHV0U2dmTm9kZS5sZW5ndGggPiAwKSB7XHJcblx0XHRnZXRFbGVtZW50QnlJZFN1ZmZpeChcInNnZkluXCIpLnZhbHVlID0gaW5wdXRTZ2ZOb2RlWzBdLmlubmVyVGV4dFxyXG5cclxuXHRcdHNob3dCb2FyZCgpXHJcblx0fVxyXG5cdGVsc2Uge1xyXG5cdFx0bGV0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKG5ldyBVUkwod2luZG93LmxvY2F0aW9uKSkuc2VhcmNoLnNsaWNlKDEpKVxyXG5cdFx0aWYgKHBhcmFtcy5oYXMoJ3NnZicpKSB7XHJcblx0XHRcdGxldCBzZ2YgPSBwYXJhbXMuZ2V0KCdzZ2YnKVxyXG5cdFx0XHRpZiAobG9va3NMaWtlU2dmKHNnZikpIHtcclxuXHRcdFx0XHRnZXRFbGVtZW50QnlJZFN1ZmZpeChcInNnZkluXCIpLnZhbHVlID0gc2dmXHJcblx0XHRcdFx0c2hvd0JvYXJkKClcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIGlmIChwYXJhbXMuaGFzKCdsaXR0bGVnb2xlbWlkJykpIHtcclxuXHRcdFx0bGV0IGlkID0gcGFyYW1zLmdldCgnbGl0dGxlZ29sZW1pZCcpXHJcblx0XHRcdGlmICgvXlxcZCskL2cudGVzdChpZCkpIHtcclxuXHRcdFx0XHRnZXRFbGVtZW50QnlJZFN1ZmZpeCgnbGl0dGxlR29sZW1JZCcpLnZhbHVlID0gaWRcclxuXHRcdFx0XHRnZXRMaXR0bGVHb2xlbVNnZkFuZFNob3dCb2FyZCgpXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cclxuXHRmdW5jdGlvbiBzaG93Qm9hcmQob3B0aW9ucykge1xyXG5cdFx0aWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkgb3B0aW9ucyA9IHt9XHJcblx0XHR2YXIgeyB0U2dmLCBwYW5uaW5nRGlyZWN0aW9uLCBtb3ZlUmVmZXJlbmNlLCByZXNldCB9ID0gb3B0aW9uc1xyXG5cdFx0aWYgKHJlc2V0IHx8ICF2aWV3ZXIub2Zmc2V0KSB2aWV3ZXIub2Zmc2V0ID0gWzAsIDBdXHJcblx0XHRpZiAocGFubmluZ0RpcmVjdGlvbikge1xyXG5cdFx0XHR2YXIgcmlnaHQgPSB2aWV3ZXIub2Zmc2V0WzBdLCB1cCA9IHZpZXdlci5vZmZzZXRbMV1cclxuXHRcdFx0c3dpdGNoIChwYW5uaW5nRGlyZWN0aW9uKSB7XHJcblxyXG5cdFx0XHRcdGNhc2UgXCLihpFcIjpcclxuXHRcdFx0XHRcdHtcclxuXHRcdFx0XHRcdFx0dXAtLVxyXG5cdFx0XHRcdFx0XHRicmVha1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjYXNlIFwi4oaTXCI6XHJcblx0XHRcdFx0XHR7XHJcblx0XHRcdFx0XHRcdHVwKytcclxuXHRcdFx0XHRcdFx0YnJlYWtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRjYXNlIFwi4oaQXCI6XHJcblx0XHRcdFx0XHR7XHJcblx0XHRcdFx0XHRcdHJpZ2h0LS1cclxuXHRcdFx0XHRcdFx0YnJlYWtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Y2FzZSBcIuKGklwiOlxyXG5cdFx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0XHRyaWdodCsrXHJcblx0XHRcdFx0XHRcdGJyZWFrXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0dmlld2VyLm9mZnNldCA9IFtyaWdodCwgdXBdXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRTZ2YgPT09IHVuZGVmaW5lZCB8fCB0U2dmID09PSBudWxsKSB7XHJcblx0XHRcdHRTZ2YgPSBnZXRFbGVtZW50QnlJZFN1ZmZpeChcInNnZkluXCIpLnZhbHVlXHJcblx0XHR9XHJcblx0XHRpZiAodFNnZiA9PT0gJycpIHtcclxuXHRcdFx0aWYgKCF2aWV3ZXIud2FybmVkRW1wdHlTZ2YpIHtcclxuXHRcdFx0XHRhbGVydCgnTm8gU0dGIHdhcyBlbnRlcmVkLCBzbyBzaG93aW5nIGEgc2ltcGxlIHNhbXBsZSBpbnN0ZWFkLicpXHJcblx0XHRcdFx0dmlld2VyLndhcm5lZEVtcHR5U2dmID0gdHJ1ZVxyXG5cdFx0XHR9XHJcblx0XHRcdHRTZ2YgPSAnKDtHTVsxXUZGWzRdQ0FbVVRGLThdQVBbZ28tdmFyaWFudHMtdHJhbnNmb3JtZXJdU1RbMF1TWls0XUtNWzBdSEFbMF1QQltCbGFja11QV1tXaGl0ZV1DW0hlcmUgaXMgYSBzbWFsbCBzYW1wbGUgZ2FtZSBvZiBUb3JvaWRhbCBHby4gSXQgZW5kcyBpbiBhIHNla2kuXTtCW2FkXTtXW2JkXTtCW2JjXTtXW2FjXTtCW2JiXTtXW2FhXTtCW2FiXTtXW2RkXTtCW2NhXTtXW2NkXTtCW2RiXTtXW2RjXTtCW2NjXTtNQVtiYV1DW0l04oCZcyBhIHNla2k7IG5laXRoZXIgcGxheWVyIHNob3VsZCBwbGF5IGF0IFggbm93IC0gaWYgdGhleSBkbywgdGhleSBwdXQgdGhlaXIgb3duIHN0b25lcyBpbiBhdGFyaS4gVGhpcyBpcyBzaG93biBpbiB0aGUgbmV4dCB0d28gdmFyaWF0aW9ucy5dV1tkYV0oO0JbYmFdO1dbY2JdKSg7QltdO1dbYmFdO0JbYWRdKSknLy9mb3JrZWQgZnJvbSBzYW1wbGU3XHJcblx0XHRcdGdldEVsZW1lbnRCeUlkU3VmZml4KFwic2dmSW5cIikudmFsdWUgPSB0U2dmXHJcblx0XHR9XHJcblx0XHR2YXIgd3JhcGFyb3VuZCA9IE51bWJlcihnZXRFbGVtZW50QnlJZFN1ZmZpeCgnd3JhcGFyb3VuZFNlbGVjdCcpLnZhbHVlKVxyXG5cdFx0XHQsIHdyYXBhcm91bmRNYXJrZXJzVHlwZSA9IE51bWJlcihnZXRFbGVtZW50QnlJZFN1ZmZpeCgnd3JhcGFyb3VuZEJvcmRlclNlbGVjdCcpLnZhbHVlKVxyXG5cdFx0XHQsIGNvb3JkaW5hdGVzVHlwZSA9IE51bWJlcihnZXRFbGVtZW50QnlJZFN1ZmZpeCgnY29vcmRpbmF0ZVNlbGVjdCcpLnZhbHVlKVxyXG5cdFx0XHQsIGFkZENvbW1lbnRzID0gZ2V0RWxlbWVudEJ5SWRTdWZmaXgoJ2FkZENvbW1lbnRzJykuY2hlY2tlZFxyXG5cdFx0XHQsIHNnZiA9ICcnXHJcblx0XHR0cnkge1xyXG5cdFx0XHR2YXIgdHJhbnNmb3JtZXIgPSBnb192YXJpYW50c190cmFuc2Zvcm1lcih7XHJcblx0XHRcdFx0YWRkQ29tbWVudHMsXHJcblx0XHRcdFx0d3JhcGFyb3VuZE1hcmtlcnNUeXBlLFxyXG5cdFx0XHRcdGNvb3JkaW5hdGVzVHlwZSxcclxuXHRcdFx0XHRwcm9qZWN0aW9uU2V0dGluZ3M6IHtcclxuXHRcdFx0XHRcdG9mZnNldDogdmlld2VyLm9mZnNldCxcclxuXHRcdFx0XHRcdHdyYXBhcm91bmRcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pXHJcblx0XHRcdHNnZiA9IHRyYW5zZm9ybWVyLnRyYW5zZm9ybSh0U2dmKVxyXG5cdFx0XHRnZXRFbGVtZW50QnlJZFN1ZmZpeChcInNnZk91dFwiKS52YWx1ZSA9IHNnZlxyXG5cdFx0XHR2aWV3ZXIudHJhbnNmb3JtZXIgPSB0cmFuc2Zvcm1lclxyXG5cdFx0fVxyXG5cdFx0Y2F0Y2ggKGUpIHtcclxuXHRcdFx0YWxlcnQoJ2FuIGVycm9yIG9jY3VycmVkLicpXHJcblx0XHRcdHJldHVyblxyXG5cdFx0fVxyXG5cclxuXHRcdHZpZXdlci5zZ2YgPSBzZ2ZcclxuXHRcdGlmICghcGFubmluZ0RpcmVjdGlvbikge1xyXG5cclxuXHRcdFx0dmFyIG9HYW1lVHJlZSA9IEdvQm9hcmRBcGkuQ3JlYXRlX0dhbWVUcmVlKClcclxuXHRcdFx0dmlld2VyLm9HYW1lVHJlZSA9IG9HYW1lVHJlZVxyXG5cclxuXHRcdFx0R29Cb2FyZEFwaS5TZXRfT25HYW1lVHJlZU1vZGlmaWVkQ2FsbGJhY2sob0dhbWVUcmVlLCAoKSA9PiB7IH0pXHJcblx0XHRcdEdvQm9hcmRBcGkuVG9nZ2xlX1J1bGVycyhvR2FtZVRyZWUpXHJcblx0XHRcdEdvQm9hcmRBcGkuU2V0X0RyYXdIYW5kaWNhcE1hcmtzKG9HYW1lVHJlZSwgZmFsc2UpXHJcblx0XHRcdEdvQm9hcmRBcGkuU2V0X0NhcHR1cmluZ01vZGUob0dhbWVUcmVlLCBmYWxzZSlcclxuXHJcblx0XHRcdEdvQm9hcmRBcGkuQ3JlYXRlX0JvYXJkQ29tbWVudHNCdXR0b25zTmF2aWdhdG9yKG9HYW1lVHJlZSwgcm9vdElkICsgJ18nICsgXCJwbGF5ZXJEaXZcIilcclxuXHRcdFx0Ly8gR29Cb2FyZEFwaS5DcmVhdGVfRWRpdG9yVmVyKG9HYW1lVHJlZSwgXCJwbGF5ZXJEaXZcIik7XHJcblx0XHRcdGlmIChtb3ZlUmVmZXJlbmNlICE9PSB1bmRlZmluZWQpXHJcblx0XHRcdFx0R29Cb2FyZEFwaS5Mb2FkX1NnZih2aWV3ZXIub0dhbWVUcmVlLCBzZ2YsIHVuZGVmaW5lZCwgbW92ZVJlZmVyZW5jZSk7XHJcblx0XHRcdGVsc2VcclxuXHRcdFx0XHRHb0JvYXJkQXBpLkxvYWRfU2dmKG9HYW1lVHJlZSwgc2dmKTtcclxuXHJcblx0XHRcdEdvQm9hcmRBcGkuU2V0X09uR2FtZVRyZWVNb2RpZmllZENhbGxiYWNrKG9HYW1lVHJlZSwgZ2FtZVRyZWVNb2RpZmllZENhbGxiYWNrKVxyXG5cclxuXHRcdFx0d2luZG93Lm9ucmVzaXplID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRcdEdvQm9hcmRBcGkuVXBkYXRlX1NpemUob0dhbWVUcmVlKTtcclxuXHRcdFx0fTtcclxuXHJcblxyXG5cdFx0XHRnZXRFbGVtZW50QnlJZFN1ZmZpeCgndmlld2VyQ29udHJvbHMnKS5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIlxyXG5cdFx0XHRnZXRFbGVtZW50QnlJZFN1ZmZpeCgndXBkYXRlQnV0dG9uRGl2Jykuc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCJcclxuXHJcblx0XHRcdGlmIChzaG93RXh0cmFzKSB7XHJcblx0XHRcdFx0Z2V0RWxlbWVudEJ5SWRTdWZmaXgoJ3RyYW5zZm9ybWVkU2dmRnMnKS5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIlxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRlbHNlIHtcclxuXHRcdFx0R29Cb2FyZEFwaS5TZXRfT25HYW1lVHJlZU1vZGlmaWVkQ2FsbGJhY2sodmlld2VyLm9HYW1lVHJlZSwgKCkgPT4geyB9KVxyXG5cdFx0XHRtb3ZlUmVmZXJlbmNlID0gR29Cb2FyZEFwaS5HZXRfTW92ZVJlZmVyZW5jZSh2aWV3ZXIub0dhbWVUcmVlLCBmYWxzZSlcclxuXHRcdFx0R29Cb2FyZEFwaS5Mb2FkX1NnZih2aWV3ZXIub0dhbWVUcmVlLCBzZ2YsIHVuZGVmaW5lZCwgbW92ZVJlZmVyZW5jZSlcclxuXHRcdFx0R29Cb2FyZEFwaS5TZXRfT25HYW1lVHJlZU1vZGlmaWVkQ2FsbGJhY2sodmlld2VyLm9HYW1lVHJlZSwgZ2FtZVRyZWVNb2RpZmllZENhbGxiYWNrKVxyXG5cdFx0XHRnZXRFbGVtZW50QnlJZFN1ZmZpeCgnb2Zmc2V0VHInKS5pbm5lckhUTUwgPSAncGFubmVkOiBbJ1xyXG5cdFx0XHRcdCsgdmlld2VyLnRyYW5zZm9ybWVyLm1vZFgodmlld2VyLnRyYW5zZm9ybWVyLm9wdGlvbnMucHJvamVjdGlvblNldHRpbmdzLm9mZnNldFswXSlcclxuXHRcdFx0XHQrICcsICcgKyB2aWV3ZXIudHJhbnNmb3JtZXIubW9kWSgtdmlld2VyLnRyYW5zZm9ybWVyLm9wdGlvbnMucHJvamVjdGlvblNldHRpbmdzLm9mZnNldFsxXSkgKyAnXSdcclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBnYW1lVHJlZU1vZGlmaWVkQ2FsbGJhY2soKSB7XHJcblx0XHQvL3doZW4gYSBtb3ZlIGlzIHBsYXllZCwgdGhlIGNhbGxiYWNrIGlzIHJhaXNlZCB0d2ljZSBpbiBxdWljayBzdWNjZXNzaW9uLiBXZSB3YW50IHRvIG9ubHkgZG8gd29yayBvbiB0aGUgc2Vjb25kIGNhbGwuXHJcblx0XHRpZiAoIXZpZXdlci5jYWxsYmFja0xhc3RDYWxsZWQpIHtcclxuXHRcdFx0dmlld2VyLmNhbGxiYWNrTGFzdENhbGxlZCA9IERhdGUubm93KClcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0aWYgKERhdGUubm93KCkgLSB2aWV3ZXIuY2FsbGJhY2tMYXN0Q2FsbGVkIDwgMzAwKSB7XHJcblx0XHRcdHVwZGF0ZVZhcmlhbnRTZ2YoKVxyXG5cdFx0fVxyXG5cdFx0ZWxzZSB2aWV3ZXIuY2FsbGJhY2tMYXN0Q2FsbGVkID0gRGF0ZS5ub3coKVxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gbG9va3NMaWtlU2dmKHNnZiwgc2l6ZSkge1xyXG5cdFx0bGV0IHJlc3VsdCA9IHNnZi5zdGFydHNXaXRoKCcoJylcclxuXHRcdC8vICYmIHNnZi5pbmRleE9mKCdHTVsxXScpID4gMCAvL1NHRiBMRyBkb2Vzbid0IVxyXG5cclxuXHRcdGlmIChzaXplKSB7XHJcblx0XHRcdHJldHVybiByZXN1bHQgJiYgc2dmLmluZGV4T2YoYFNaWyR7c2l6ZX1dYCA+IDMpXHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmVzdWx0ICYmIC9TWlxcW1xcZCtdLy50ZXN0KHNnZilcclxuXHR9XHJcblx0ZnVuY3Rpb24gdXBkYXRlVmFyaWFudFNnZigpIHtcclxuXHRcdHZhciBzZ2YgPSBHb0JvYXJkQXBpLlNhdmVfU2dmKHZpZXdlci5vR2FtZVRyZWUpXHJcblx0XHRpZiAoc2dmID09IHZpZXdlci5zZ2YpIHtcclxuXHRcdFx0cmV0dXJuXHJcblx0XHR9XHJcblx0XHR2aWV3ZXIuc2dmID0gc2dmXHJcblx0XHR2YXIgbW92ZVJlZmVyZW5jZSA9IEdvQm9hcmRBcGkuR2V0X01vdmVSZWZlcmVuY2Uodmlld2VyLm9HYW1lVHJlZSwgZmFsc2UpXHJcblx0XHQvLyB2YXIgb3B0aW9ucyA9IHZpZXdlci50cmFuc2Zvcm1lci5vcHRpb25zXHJcblx0XHQvLyBvcHRpb25zLmJvYXJkRGltZW5zaW9ucyA9IG9wdGlvbnMuYm9hcmREaW1lbnNpb25zLm1hcCgoeCkgPT4geCAtIDIgKiBvcHRpb25zLnByb2plY3Rpb25TZXR0aW5ncy53cmFwYXJvdW5kKSBcclxuXHRcdHZhciB0U2dmID0gdmlld2VyLnRyYW5zZm9ybWVyLmludmVyc2VUcmFuc2Zvcm0oc2dmKVxyXG5cdFx0Z2V0RWxlbWVudEJ5SWRTdWZmaXgoXCJzZ2ZJblwiKS52YWx1ZSA9IHRTZ2ZcclxuXHRcdHNob3dCb2FyZCh7IHRTZ2YsIG1vdmVSZWZlcmVuY2UgfSlcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGdldExpdHRsZUdvbGVtU2dmQW5kU2hvd0JvYXJkKCkge1xyXG5cdFx0dmFyIGdhbWVJZCA9IGdldEVsZW1lbnRCeUlkU3VmZml4KCdsaXR0bGVHb2xlbUlkJykudmFsdWVcclxuXHRcdGlmIChnYW1lSWQgPT09ICcnKSB7XHJcblx0XHRcdC8vZ2FtZUlkID0gJzE4NjA3OTUnXHJcblx0XHRcdGFsZXJ0KCdlbnRlciB0aGUgSUQgb2YgYSBnYW1lIGZyb20gTGl0dGxlR29sZW0sIGUuZy4g4oCcMTg2MDc5NeKAnScpXHJcblx0XHRcdHJldHVyblxyXG5cdFx0fVxyXG5cdFx0Z2FtZUlkID0gZ2FtZUlkLnRyaW0oKVxyXG5cclxuXHRcdHZhciBwcm94eXVybCA9IFwiaHR0cHM6Ly9jb3JzLWFueXdoZXJlLmhlcm9rdWFwcC5jb20vXCJcclxuXHRcdHZhciB1cmwgPSBgaHR0cDovL2xpdHRsZWdvbGVtLm5ldC9zZXJ2bGV0L3NnZi8ke2dhbWVJZH0vZ2FtZSR7Z2FtZUlkfS5zZ2ZgXHJcblx0XHRpZiAoIS9eXFxkKyQvZy50ZXN0KGdhbWVJZCkpIHtcclxuXHRcdFx0YWxlcnQoJ2ludmFsaWQgSUQnKVxyXG5cdFx0XHRyZXR1cm5cclxuXHRcdH1cclxuXHRcdGdldEVsZW1lbnRCeUlkU3VmZml4KCdnb0xnTXNnJykuaW5uZXJUZXh0ID0gJ2xvYWRpbmfigKYnXHJcblx0XHR2YXIgbXlIZWFkZXJzID0gbmV3IEhlYWRlcnMoe1xyXG5cdFx0XHRcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL3NnZlwiXHJcblx0XHR9KTtcclxuXHRcdGNvbnN0IGZhaWxNc2cgPSAnbG9hZCBmcm9tIGxpdHRlbCBHb2xlbSBmYWlsZWQnXHJcblx0XHRmZXRjaChwcm94eXVybCArIHVybCwgeyBoZWFkZXJzOiBteUhlYWRlcnMgfSkudGhlbihcclxuXHRcdFx0ZnVuY3Rpb24gKHJlc3BvbnNlKSB7XHJcblx0XHRcdFx0aWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XHJcblx0XHRcdFx0XHRjb25zb2xlLmxvZygnTG9va3MgbGlrZSB0aGVyZSB3YXMgYSBwcm9ibGVtLiBTdGF0dXMgQ29kZTogJyArIHJlc3BvbnNlLnN0YXR1cyk7XHJcblxyXG5cdFx0XHRcdFx0Z2V0RWxlbWVudEJ5SWRTdWZmaXgoJ2dvTGdNc2cnKS5pbm5lclRleHQgPSBmYWlsTXNnXHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBFeGFtaW5lIHRoZSB0ZXh0IGluIHRoZSByZXNwb25zZVxyXG5cdFx0XHRcdHJlc3BvbnNlLnRleHQoKS50aGVuKGZ1bmN0aW9uIChzZ2YpIHtcclxuXHRcdFx0XHRcdGlmICghbG9va3NMaWtlU2dmKHNnZiwgMTEgLypMRyBpcyBhbHdheXMgMTF4MTEqLykpIHtcclxuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coJ2ludmFsaWQgU0dGLiBSZWNlaXZlZDonICsgc2dmKVxyXG5cclxuXHRcdFx0XHRcdFx0Z2V0RWxlbWVudEJ5SWRTdWZmaXgoJ2dvTGdNc2cnKS5pbm5lclRleHQgPSBmYWlsTXNnXHJcblx0XHRcdFx0XHRcdHJldHVyblxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0c2dmID0gc2dmLnJlcGxhY2UoJ1NaWzExXScsIGBTWlsxMV1TT1todHRwOi8vbGl0dGxlZ29sZW0ubmV0L2pzcC9nYW1lL2dhbWUuanNwP2dpZD0ke2dhbWVJZH1gKVxyXG5cclxuXHRcdFx0XHRcdGdldEVsZW1lbnRCeUlkU3VmZml4KFwic2dmSW5cIikudmFsdWUgPSBzZ2ZcclxuXHRcdFx0XHRcdHNob3dCb2FyZCgpXHJcblxyXG5cdFx0XHRcdFx0Z2V0RWxlbWVudEJ5SWRTdWZmaXgoJ2dvTGdNc2cnKS5pbm5lclRleHQgPSAnZ2FtZSBsb2FkZWQgZnJvbSBMaXR0bGUgR29sZW0nXHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHRcdCkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xyXG5cdFx0XHRjb25zb2xlLmxvZygnRmV0Y2ggRXJyb3IgOi1TJywgZXJyKTtcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblxyXG5cclxuXHJcbn1cclxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uICgpIHtcclxuXHRbXS5mb3JFYWNoLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmdvLXZhcmlhbnRzLWVkaXRvcicpLCBmdW5jdGlvbiAoZWwpIHtcclxuXHRcdHZhciBvcHRpb25zID0geyByb290SWQ6IGVsLmlkIH1cclxuXHRcdGlmIChlbC5jbGFzc0xpc3QuY29udGFpbnMoJ2dvLXZhcmlhbnRzLWhpZGUtZXh0cmFzJykpIHtcclxuXHRcdFx0b3B0aW9ucy5zaG93RXh0cmFzID0gZmFsc2VcclxuXHRcdH1cclxuXHRcdGRvY3VtZW50LmdvVmFyaWFudHNFZGl0b3Iob3B0aW9ucylcclxuXHR9KVxyXG59KSIsIm1vZHVsZS5leHBvcnRzID0gKHJvb3RJZCkgPT5cclxuICAgIDxkaXY+XHJcblxyXG4gICAgICAgIDxzdHlsZSB0eXBlPVwidGV4dC9jc3NcIj5cclxuICAgICAgICAgICAge2AjJHtyb290SWR9XHJcbi5tYXNvbnJ5IHtcclxuICAgIC1tb3otY29sdW1uLWNvdW50OiAzO1xyXG4gICAgLXdlYmtpdC1jb2x1bW4tY291bnQ6IDM7XHJcbiAgICBjb2x1bW4tY291bnQ6IDM7XHJcbiAgICBjb2x1bW4tZ2FwOiAxZW07XHJcbn1cclxuLml0ZW0ge1xyXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcclxuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcclxuICAgIG1hcmdpbjogMCAwIDFlbTtcclxuICAgIFxyXG4gICAgcGFkZGluZzogMnB4O1xyXG4gICAgYm9yZGVyOiAxcHggYmxhY2sgc29saWQ7XHJcbiAgICB3aWR0aDogMTAwJTtcclxufVxyXG59XHJcbi5nby12YXJpYW50cy1leHRyYXMge1xyXG5kaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7XHJcbn1gfVxyXG4gICAgICAgIDwvc3R5bGU+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cIm1hc29ucnlcIj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cIml0ZW0gZ28tdmFyaWFudHMtZXh0cmFzXCI+XHJcbiAgICAgICAgICAgICAgICBQYXN0ZSB0aGUgU0dGIGZvciBhIGdhbWUgb2YgdG9yb2lkYWwgR28sIChlLmcuIGZyb20gTGl0dGxlIEdvbGVtKSBpbiB0aGUgYm94LCBhbmQgdGhlbiBwdXNoIHRoZSBidXR0b24gdG8gdmlldyB0aGUgZ2FtZSFcclxuICAgICAgICAgICAgPGJyIC8+PGxhYmVsIGZvcj17YCR7cm9vdElkfV9zZ2ZJbmB9PlQtR28gU0dGOjwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgICA8dGV4dGFyZWEgaWQ9e2Ake3Jvb3RJZH1fc2dmSW5gfSByb3dzPVwiM1wiPjwvdGV4dGFyZWE+XHJcbiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cImJ1dHRvblwiIGlkPXtgJHtyb290SWR9X2dvQnV0dG9uYH0gdmFsdWU9XCJzaG93IGJvYXJkIChmcm9tIHQtR28gU0dGKVwiIC8+XHJcblxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJpdGVtIGdvLXZhcmlhbnRzLWV4dHJhc1wiPlxyXG4gICAgICAgICAgICAgICAgPGxhYmVsIGZvcj17YCR7cm9vdElkfV9saXR0bGVHb2xlbUlkYH0+TGl0dGxlR29sZW0gZ2FtZSBJRDo8L2xhYmVsPlxyXG4gICAgICAgICAgICAgICAgPGlucHV0IGlkPXtgJHtyb290SWR9X2xpdHRsZUdvbGVtSWRgfSB0eXBlPVwidGV4dFwiPjwvaW5wdXQ+XHJcbiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cImJ1dHRvblwiIGlkPXtgJHtyb290SWR9X2dvTGdCdXR0b25gfSB2YWx1ZT1cInNob3cgYm9hcmQgKGZyb20gbGl0dGxlR29sZW0gZ2FtZSBJRClcIiAvPjxzcGFuIGlkPXtgJHtyb290SWR9X2dvTGdNc2dgfSAvPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJpdGVtIGdvLXZhcmlhbnRzLWV4dHJhc1wiPlxyXG4gICAgICAgICAgICAgICAgPGxhYmVsIGZvcj17YCR7cm9vdElkfV9zaXplU2VsZWN0YH0+U2l6ZTo8L2xhYmVsPlxyXG4gICAgICAgICAgICAgICAgPHNlbGVjdCBpZD17YCR7cm9vdElkfV9zaXplU2VsZWN0YH0+XHJcbiAgICAgICAgICAgICAgICAgICAgey8qIG9wdGlvbnMgZmlsbGVkIGJ5IGVkaXRvci5qcyAqL31cclxuICAgICAgICAgICAgICAgIDwvc2VsZWN0PlxyXG4gICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJidXR0b25cIiBpZD17YCR7cm9vdElkfV9uZXdCdXR0b25gfSB2YWx1ZT1cIk5ldyBnYW1lXCIgLz5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDxkaXYgc3R5bGU9XCJkaXNwbGF5OiBub25lXCIgaWQ9e2Ake3Jvb3RJZH1fdHJhbnNmb3JtZWRTZ2ZGc2B9IGNsYXNzPVwiaXRlbSBnby12YXJpYW50cy1leHRyYXNcIj5cclxuICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9e2Ake3Jvb3RJZH1fc2dmT3V0YH0+VHJhbnNmb3JtZWQgU0dGOjwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgICA8dGV4dGFyZWEgaWQ9e2Ake3Jvb3RJZH1fc2dmT3V0YH0gcm93cz1cIjNcIj48L3RleHRhcmVhPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPGRpdiBpZD17YCR7cm9vdElkfV92aWV3ZXJDb250cm9sc2B9IHN0eWxlPVwiZGlzcGxheTpub25lXCIgY2xhc3M9XCJpdGVtXCI+XHJcblxyXG4gICAgICAgICAgICAgICAgPHRhYmxlIHRpdGxlPVwicGFubmluZ1wiIHN0eWxlPVwiZmxvYXQ6bGVmdFwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDx0cj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNvbHNwYW49XCIyXCIgc3R5bGU9XCJ0ZXh0LWFsaWduOiBjZW50ZXJcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwiYnV0dG9uXCIgdmFsdWU9XCLihpFcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8dGQgcm93c3Bhbj1cIjRcIiBzdHlsZT1cInZlcnRpY2FsLWFsaWduOiBtaWRkbGVcIj7igJxQYW5uaW5n4oCdXHJcbiAgICAgICAgICAgICAgICA8cD4gVXNlIHRoZSBidXR0b25zIHRvIHRoZSBsZWZ0IHRvIOKAnHBhbuKAnSB0aGUgYm9hcmQuPC9wPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvdHI+XHJcbiAgICAgICAgICAgICAgICAgICAgPHRyPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8dGQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cImJ1dHRvblwiIHZhbHVlPVwi4oaQXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHRkPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJidXR0b25cIiB2YWx1ZT1cIuKGklwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdGQ+XHJcbiAgICAgICAgICAgICAgICAgICAgPC90cj5cclxuICAgICAgICAgICAgICAgICAgICA8dHI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjb2xzcGFuPVwiMlwiIHN0eWxlPVwidGV4dC1hbGlnbjogY2VudGVyXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cImJ1dHRvblwiIHZhbHVlPVwi4oaTXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cclxuICAgICAgICAgICAgICAgICAgICA8L3RyPlxyXG4gICAgICAgICAgICAgICAgICAgIDx0cj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNvbHNwYW49XCIyXCIgc3R5bGU9XCJ0ZXh0LWFsaWduOiBjZW50ZXI7IGZvbnQtc2l6ZTogc21hbGxcIiBpZD17YCR7cm9vdElkfV9vZmZzZXRUcmB9ID5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhbm5lZDogWzAsMF1cclxuICAgICAgICAgICAgPC90ZD5cclxuICAgICAgICAgICAgICAgICAgICA8L3RyPlxyXG4gICAgICAgICAgICAgICAgPC90YWJsZT5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJpdGVtXCI+XHJcbiAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPXtgJHtyb290SWR9X3dyYXBhcm91bmRTZWxlY3RgfT5udW1iZXIgb2Ygd3JhcGFyb3VuZCBsaW5lcyB0byBhZGQ6PC9sYWJlbD5cclxuICAgICAgICAgICAgICAgIDxzZWxlY3QgaWQ9e2Ake3Jvb3RJZH1fd3JhcGFyb3VuZFNlbGVjdGB9PlxyXG4gICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIwXCI+MDwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIxXCI+MTwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIyXCI+Mjwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIzXCI+Mzwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCI0XCIgc2VsZWN0ZWQ+NDwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCI1XCI+NTwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCI2XCI+Njwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCI3XCI+Nzwvb3B0aW9uPlxyXG5cclxuICAgICAgICAgICAgICAgIDwvc2VsZWN0PlxyXG4gICAgICAgICAgICAgICAgPGJyIC8+XHJcbiAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVwiYWRkQ29tbWVudHNcIj5hZGQgY29tbWVudHM6PC9sYWJlbD5cclxuICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBpZD17YCR7cm9vdElkfV9hZGRDb21tZW50c2B9IC8+XHJcbiAgICAgICAgICAgICAgICA8YnIgLz5cclxuICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9e2Ake3Jvb3RJZH1fd3JhcGFyb3VuZEJvcmRlclNlbGVjdGB9PlR5cGUgb2YgYm9yZGVyIGZvciB3cmFwYXJvdW5kOjwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgICA8c2VsZWN0IGlkPXtgJHtyb290SWR9X3dyYXBhcm91bmRCb3JkZXJTZWxlY3RgfT5cclxuICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiMFwiPk5vIGJvcmRlcjwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIxXCIgc2VsZWN0ZWQ+RnVsbCBib3JkZXI8L29wdGlvbj5cclxuICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiMlwiPlBhcnRpYWwgYm9yZGVyIChjb3JuZXJzICZhbXA7IG1pZGRsZXMpPC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjNcIj5KdXN0IGNvcm5lcnM8L29wdGlvbj5cclxuICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiNFwiPkp1c3QgbWlkZGxlczwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgPC9zZWxlY3Q+XHJcbiAgICAgICAgICAgICAgICA8YnIgLz5cclxuICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9e2Ake3Jvb3RJZH1fY29vcmRpbmF0ZVNlbGVjdGB9PlR5cGUgb2YgY29vcmRpbmF0ZXM6PC9sYWJlbD5cclxuICAgICAgICAgICAgICAgIDxzZWxlY3QgaWQ9e2Ake3Jvb3RJZH1fY29vcmRpbmF0ZVNlbGVjdGB9PlxyXG4gICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIwXCIgc2VsZWN0ZWQ+Tm9uZTwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIxXCI+KOKGkuKGkTtBfDEtS3wxMSk6IFdlc3Rlcm48L29wdGlvbj5cclxuICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiMlwiPijihpLihpE7QXwxLUx8MTEpOiBXZXN0ZXJuLCBubyDigJxJ4oCdPC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjNcIj4o4oaS4oaTOzF8MS0xMXwxMSk6IExhdGluL0xhdGluLCB0b3AgdG8gYm90dG9tPC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjRcIj4o4oaS4oaTOzF8MS0xMXzljYHkuIApOiBMYXRpbi9DaGluZXNlLCB0b3AgdG8gYm90dG9tPC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICA8L3NlbGVjdD5cclxuICAgICAgICAgICAgICAgIDxiciAvPlxyXG4gICAgICAgICAgICAgICAgPGRpdiBpZD17YCR7cm9vdElkfV91cGRhdGVCdXR0b25EaXZgfSBzdHlsZT1cImRpc3BsYXk6bm9uZVwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwiYnV0dG9uXCIgaWQ9e2Ake3Jvb3RJZH1fdXBkYXRlQnV0dG9uYH0gdmFsdWU9XCJ1cGRhdGUgKGZyb20gYm9hcmQpXCIgLz4gUHJlc3MgdGhpcyBidXR0b24gYWZ0ZXIgYWRkaW5nIG1hcmtzIHRvIHRoZSBib2FyZCBwb3NpdGlvbiBpbiBvcmRlciB0byBnZXQgdGhlIHdyYXBhcm91bmQgZWZmZWN0LlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8ZGl2IGlkPXtgJHtyb290SWR9X3BsYXllckRpdmB9IHN0eWxlPVwicG9zaXRpb246cmVsYXRpdmU7IGhlaWdodDogNzV2aDt3aWR0aDogODV2d1wiPjwvZGl2PlxyXG4gICAgPC9kaXY+Il19"}